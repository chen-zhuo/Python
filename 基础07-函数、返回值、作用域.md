# 函数、返回值、作用域

### 函数

举例：游戏的通关操作是 `上下左右 上下左右 上下左右`，我们一共要操作12次才能通关，假如说我们自己把 `上下左右` 设置称为1个流程，那我们操作3次流程就可以通关了，这样就大大提高了我们的操作效率。我们就认为这样的流程就是函数。

##### 函数定义

**函数就是对实现特定功能的代码块的封装。**

**作用**：将功能封装在函数中，使用功能的时候，直接调用函数，不必重写，**提高代码使用效率**。

```python
def 函数名(形参列表):
    '''函数说明'''
    函数体

'''
def：声明函数的关键字
函数名：函数名称，最好见名知义。（命名规范参照PEP8）
()：固定格式，必须有
形参列表：函数接收外部传递的数据。（若没有数据接收，可以为空）
函数说明：对函数的功能和参数以及返回值进行说明
函数体：实现函数功能的代码块
'''
```

##### 函数调用

**函数一定要先定义，再调用。**

```python
# 调用方式
函数名(实参列表)
'''
函数名：调用的函数必须是已经声明过的，而且是先声明后调用
实参列表：给函数接内部传递数据（若没有数据传递，可以为空）
'''

# 函数调用过程
'''
1. 调用函数
2. 回到函数声明的地方
3. 使用实参给形参赋值
4. 执行函数体
5. 函数体执行完成后，回到函数调用的位置。
'''
```

**函数只有在调用的时候才会执行，一个函数可以调用多次。**

```python
def han1():
    print('开始学习函数')

han1()
han1()

'''
输出：
开始学习函数
开始学习函数
# 注释：函数调用一定要写在函数声明后面
'''
```

**函数里面可以调用其它的函数。**

```python
def han():
    print('函数A')

def han1():
    han()		   # 在函数han1里面调用函数han
    print('函数B')

han1()             # 调用函数han1 

'''
输出：
函数A               # 执行了函数han
函数B
'''
```

##### 嵌套函数

**函数内部是可以声明函数的，这样的函数称为嵌套函数。**

```python
def han():
    print('开始学习函数')
    def han1():    # 在函数han里面声明函数han1
        print('休息一下')
        
han()             # 调用了函数han

'''
输出：
开始学习函数		  # 虽然调用了函数han，但没有调用函数han1
'''
```

注意：调用外部函数时，内部函数不会执行，只在外部函数里面调用内部函数才会执行。

```python
def han():
    print('开始学习函数')
    def han1():
        print('休息一下')
    han1()				# 函数han内调用函数han1

han()

'''
输出：
开始学习函数
休息一下
'''
```

##### 理解调用

​	函数和变量是一样的，都是“一个名字对应内存地址中的一些内容” 根据这样的原则，我们就可以理解两个事情：

**test1表示的是函数的内存地址**

**test1()就是调用对在test1这个地址的内容，即函数**

**函数只能调用和它同级别以及上级的变量或函数。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。**

### 参数传递

**参数的作用：从函数的外面给函数传值**

##### 位置参数

指传参的时候，实参按**位置顺序**给形参赋值

    def func1(a, b, c):
        print('a=' + str(a))
        print('b=' + str(b))
        print('c=' + str(c))
    
    func1(10, 20, 30)
    
    输出：
    a=10
    b=20
    c=30

##### 关键字参数

指传参的时候按照**参数的名称**进行传递

格式：**函数名（参数=值）**

```
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

func1(b=20, a=10, c=30)

输出：
a=10
b=20
c=30
```

**注意：位置参数和关键字参数可以混合使用**

##### 默认参数

指函数声明的时候，参数可以设置默认值。

**注意：有默认值的参数必须放在所有没有默认值的参数后面。**

**注意：函数中有默认值的参数时，可以传参也可以不传参，如果有传参，以传参数据为准。**

```
def func11(a, b='cc', c='bb', d='a'):
    print(a, b, c, d)

func11(10,d='100')

输出：
10 cc bb 100
```

##### 不定参数

**形参*args**

函数实参的个数不确定，**就在形参的前面加一个*，将形参变成元祖**。

*args：**表示的就是将实参中按照位置传值，多出来的值都给args，且以元祖的方式呈现**。

```
def foo(x,*args):
    print(x)		# 1
    print(args)		# (2, 3, 4, 5)

# 其中的2,3,4,5都给了args
foo(1,2,3,4,5)
```

```
def foo(x, y=1, *args):
    print(x)		# 1
    print(y)		# 2
    print(args)		# (3, 4, 5)

# 其中的x为1，y=1的值被2重置了，3,4,5都给了args
foo(1,2,3,4,5)
```

**注意：不定参数，也可以不存在，对应的参数的值就是一个空的元祖**

```
def func1(char,*numbers):
    print(char, type(char))	        # a <class 'str'>
    print(numbers, type(numbers))	# () <class 'tuple'>

func1('a')
```

**形参\**kwargs**

\**kwargs：**表示的就是形参中按照关键字传值把多余的传值以字典的方式呈现**

```
def foo(x,**kwargs):
    print(x)			# 1
    print(kwargs)		# {'y': 1, 'a': 2, 'b': 3, 'c': 4}

#将y=1,a=2,b=3,c=4以字典的方式给了kwargs    
foo(1,y=1,a=2,b=3,c=4)
```

##### 参数位置

**注意：位置参数、默认参数、*args、\*\*kwargs混用时，四者的顺序必须是位置参数、默认参数、\*args、\*\*kwargs，不然就会报错。**

```
下面哪些声明函数是非法的？
def func(a, b=2, *arg): 		(正确)
def func(a=1, b=2, **kwargs, *arg): 	(顺序错误)
def func(a, b=2, c): 		        (顺序错误)
def func(a, b, c: int=3): 	        (正确，相当于 def func(a, b, c=3):)
```

正确事例：

```
def foo(x,*args,**kwargs):
    print(x)		# 1
    print(args)		# (2, 3, 4)
    print(kwargs)	# {'y': 1, 'a': 2, 'b': 3, 'c': 4}
    
foo(1,2,3,4,y=1,a=2,b=3,c=4)
# 将1传给了x，将2,3,4以元组方式传给了args，y=1,a=2,b=3,c=4以字典的方式给了kwargs
```

错误事例：

```
def foo(x,**kwargs,*args):
    print(x)
    print(args)
    print(kwargs)
    
foo(1,y=1,a=2,b=3,c=4,2,3,4)
# 报错，参数顺序错误
```

正确事例：

```
def foo(x,y=1,**kwargs):
    print(x)		# 1
    print(y)		# 1
    print(kwargs)	# {'a': 2, 'b': 3, 'c': 4}


foo(1,a=2,b=3,c=4)
#将1按照位置传值给x，y按照默认参数为1，a=2,b=3,c=4以字典的方式给了kwargs
```

# 函数返回值

### 返回值

##### 认识返回值

**每个函数执行完以后都会返回一个值，默认为None。**

**注意：在调用函数时，函数的返回值是不会被打印的。**

```
def han():
    pass

han()

#注释：结果为空
```

##### 打印返回值

打印函数的返回值，需要通过**打印函数名**来实现

**注意：函数的返回值一直都存在，只是没有被打印出来。**

```
def han():
    pass

print(han())

输出：
None
```

**注意：打印函数名，不仅会调用函数，也会打印函数的返回值。**

```
def han():
    print('函数被调用')

print(han())

输出：
函数被调用
None
```

### 关键字return

**return后面的表达式的值就是函数返回值。**

**注意：函数的返回值默认为None，是因为函数本身自带了 return  None 语句，只是没有显示而已。**

**注意：交互模式（cmd中输入python）下，写了return代码，返回值会自动打印出来，而作为脚本单独运行时则需要print函数才能显示。**

##### 设置返回值

通过return可以设置返回值

```
def han():
    return 10000	# 设置返回值为10000

print(han())

输出：
10000
```

**注意：函数的返回值可以有多个，就在return后面返回多个值，每个值是一个元祖**

```
def han():
    return 10, 100, 'a'

print(han(),type(han()))	# (10, 100, 'a') <class 'tuple'>
```

##### 结束函数

**调用函数，当函数执行到return时，就结束该函数，即使return后面有（函数体内的）代码也不执行。**

```
def han():
    print('函数开始')
    return 10000
    print('函数开始')

han()  # 这里调用函数

输出：
函数开始
```

### 函数赋值

##### 变量指向函数

变量指向函数，即**变量=函数（不带括号）**，指变量被赋值为函数地址。

```
def func(a,b):
    print(a+b)

a = func        # a被赋值为函数地址
a(5,3)          # a()就等于func()，a(5,3)就等于func(5,3)

输出：
8
```

##### 变量赋值函数返回值

变量赋值函数返回值，即**变量=函数（带括号）**，指变量被赋值为函数的返回值。

**注意：在变量被赋值为函数的返回值时，函数会被调用一次，相当于给变量赋值前会执行一次函数。**

```
def func1():
    print('aaa')

a = func1()  # 这里给变量赋值，就会调用一次函数

输出：
aaa
```

**注意：变量等于函数，相当于变量就是函数的返回值**

```
def func1():
    print(1)
    return 100

a = func1()  # 先调用一次函数，输出1，再将返回值100赋值给了变量a
print(a)     

输出：
1
100
```

**注意：直接调用函数的值，就是在使用函数的返回值**

```
def han():
    return 10000

fan = han()+1	 # 调用han()就是在使用han的返回值
print(fan)       # 1001
```

# 作用域

### 定义

##### 作用域

作用域：变量可以**被使用的范围**

##### 全局变量

全局变量：**从声明开始，到文件结束都可以使用的变量**

**注意：for、if、while、try等语句不会产生新的作用域，也就不影响变量的作用域**

```
a = 10  	        # a是全局变量
print('=====',a)

for x in range(1):
    b = 100  		# b是全局变量
    print(b)
    print(a)

print('=====', b)

输出：
===== 10
100
10
===== 100
```

##### 局部变量

局部变量：**在函数（类）中声明的变量**（作用域是从**声明开始到函数结束**）

**注意：def、class、lambda等语句会产生新的作用域，会影响变量作用域**

```
def func3():
    aaa = 10    # aaa在函数内声明，为局部变量，作用域是函数内部
    print(aaa)

func3()         # 10

print(aaa)      # 报错,aaa没定义
```

##### 作用域细则

变量名引用会分作用域进行查找：**首先是本地，然后是函数内（如果有的话），之后是全局，最后是内置**。

### 更改作用域

##### 关键字global

格式：**global  变量**

作用：**在函数（类）中声明一个全局变量**

```
def func3():
    global aaa  # 声明aaa为全局变量
    aaa = 10
    print(aaa)

func3()         # 10

print(aaa)      # 10
```

对于一个全局变量，你的函数里如果只使用到了它的值，而**没有对其赋值**（`变量 = XXX`）的话，就**不需要声明global**。相反，如果**对其赋了值**的话，那么你就**需要声明`global`**。声明`global`的话，就表示你是在**对一个全局变量进行赋值**，而不是在向一个局部变量赋值。

简单说，在一个作用域里面给一个**变量赋值的时候，自动认为这个变量是这个作用域的本地变量，并屏蔽作用域外的同名的变量**。

```
names = ['唱歌']

def func():
	# names.append只是使用了names,append不属于赋值，不用声明global
    names.append('跳舞')
    print(names)			
    
func()						# ['唱歌', '跳舞']
				

def func1():
	# 这里对name进行了赋值，自动name是func1的本地变量，并屏蔽作用域外的同名变量
    names += ['跳舞']		                # 报错，本地没有定义names变量

func1()


def func2():
    global names
    names += ['跳舞']
    print(names)		

func2()						# ['唱歌', '跳舞', '跳舞']

# 注释：因为列表是可变对象，里面的值改变都是在一个列表内进行的。
```

当参数在方法中被改变，**若把这个改变给积累下来，而不是每一次都是从头开始变化的话，那么这个参数就需要声明为全局变量**。

```
counter = 1
def st():
    global counter
    for i in (1, 2, 3):
        counter += 1

st()          # 首先要运行函数，才能改变函数内对全局变量的改变
print(counter)

输出：
4
```

##### 关键字nonlocal

格式：**nonlocal  变量**

作用：在**内层函数中声明**为**最外层函数的局部变量**

```
def func11():
    a_11 = 10
    print('外部函数', a_11)	  # 2.外部函数 10

    def func12():
        nonlocal a_11 	          # 4.声明a_ll为最外层函数（func11()）的局部变量
        a_11 = 100
        print('内部函数', a_11)	  # 5.内部函数 100

    func12()                      # 3.执行内部函数func12()
    print('外部函数', a_11)	  # 6.外部函数 100

func11()	 		  # 1.调用外部函数func11()

print(a_11)  			  # 7.a_ll是个局部变量，在外部不能打印。
```

# 特殊函数

### 匿名函数lambda

##### 定义

匿名函数：本质还是函数，以另外一种简单的方式来声明的

##### 关键字lambda

lambda：声明匿名函数

##### 匿名函数格式

函数名 = lambda 参数列表：返回值（**不需要return**）

##### 使用方法

普通函数

```
def my_sum1(x,y):
    return x+y

print(my_sum1(10, 20))			# 30
```

匿名函数

```
my_sum2 = lambda x, y: x+y

print(my_sum2(10, 20))			# 30
```

### 递归函数

##### 定义

在**函数中调用函数本身**的函数称为**递归函数**。

##### 效率

递归效率低下，每调用一次函数，系统都要为其分配内存空间

循环能做的事情，虽然递归函数也可以做，但**尽量不使用递归**。

##### 递归函数

```
def fun1():
    print('===')
    fun1()

fun1()	# 输出多个===后，出现递归错误：调用python对象超过了最大递归深度
```

### 总结

1. 实参是用来给形参赋值的，而且一定要保证每个形参都有值（若没有形参，实参也可以没有）。