# 函数、传参、返回值、作用域

### 函数

举例：游戏的通关操作是 `上下左右 上下左右 上下左右`，我们一共要操作12次才能通关，假如说我们自己把 `上下左右` 设置称为1个流程，那我们操作3次流程就可以通关了，这样就大大提高了我们的操作效率。我们就认为这样的流程就是函数。

##### 函数定义

**函数就是对实现特定功能的代码块的封装。**

**作用**：将功能封装在函数中，使用功能的时候，直接调用函数，不必重写，**提高代码使用效率**。

```python
def 函数名(形参列表):
    '''函数说明'''
    函数体

'''
def：声明函数的关键字
函数名：函数名称，最好见名知义。（命名规范参照PEP8）
()：固定格式，必须有
形参列表：函数接收外部传递的数据。（若没有数据接收，可以为空）
函数说明：对函数的功能和参数以及返回值进行说明
函数体：实现函数功能的代码块
'''
```

##### 函数调用

**函数一定要先定义，再调用。**

```python
# 调用方式
函数名(实参列表)
'''
函数名：调用的函数必须是已经声明过的，而且是先声明后调用
实参列表：给函数接内部传递数据（若没有数据传递，可以为空）
'''

# 函数调用过程
'''
1. 调用函数
2. 回到函数声明的地方
3. 使用实参给形参赋值
4. 执行函数体
5. 函数体执行完成后，回到函数调用的位置。
'''
```

**函数只有在函数外部调用的时候才会执行，一个函数可以调用多次。**

```python
def han1():
    print('开始学习函数')

han1()
han1()

'''
输出：
开始学习函数
开始学习函数
# 注释：函数调用一定要写在函数声明后面
'''
```

**函数内部调用该函数时，是不会执行的，而且函数内最好有结束函数的语句，否则容易函数死循环。**

```python
def han1():
    print('开始学习函数')
    han1()
# 函数han1在内部本身函数han1，是不会执行的
```

**函数里面可以调用其它的函数。**

```python
def han():
    print('函数A')

def han1():
    han()		   # 在函数han1里面调用函数han
    print('函数B')

han1()             # 调用函数han1 
'''
输出：
函数A               # 执行了函数han
函数B
'''
```

##### 嵌套函数

**嵌套函数**：在**函数内部**声明**其他的函数**。

1. **函数只能调用和它同级别以及上级的变量或函数**。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。
2. 在调用嵌套函数时，内部函数**在嵌套函数里**可以**直接**调用，在嵌套函数外**不能直接**调用。

```python
def han():               # 2.开始执行函数han
    print('开始学习函数')  # 3.输出：开始学习函数
    def han1():          # 4.定义函数han1
        print('休息一下')
        
han()                    # 1.执行函数han            
'''
输出：
开始学习函数	
# 注释：函数han1只是被定义了，但没有被调用，因此没有输出
'''

def han():               # 2.开始执行函数han
    print('开始学习函数')  # 3.输出：开始学习函数
    def han1():          # 4.定义函数han1
        print('休息一下')
       
han()                    # 1.执行函数han
han1()                   # 5.报错，han1未定义，函数han1在函数han内定义，不能在函数han外部调用
'''
输出：
开始学习函数	
# 注释：在调用嵌套函数时，内部函数不会执行，只在嵌套函数里面调用内部函数才会执行。
'''

# 在调用嵌套函数时，内部函数不会执行，只在嵌套函数里面调用内部函数才会执行。
def han():               # 2.开始执行函数han
    print('开始学习函数')  # 3.输出：开始学习函数
    def han1():          # 4.定义函数han1。6.开始执行函数han1
        print('休息一下') # 7. 输出：休息一下
    han1()               # 5.执行函数han1
        
han()                    # 1.执行函数han    
'''
输出：
开始学习函数
休息一下
'''
```

### 传参

##### 形参实参

举例：有一个计算圆的面积的函数，假如需要求半径为 `r` 的圆的面积，我们就需要把半径 `r` 传递给函数，让函数来计算，我们就可以认为半径 `r` 就是传递的参数。

**参数的作用**：传递数据的“邮递员”。

**形参**：定义在**声明函数**的**形参列表**里面的参数，是数据的接收方。

```python
# a, b, c都是形参，都在func1函数的形参列表里面
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))
```

**实参**：定义在**调用函数**的**实参列表**里面的参数，是数据的发送方。

```python
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

# 10, 20, 30都是实参，都在func1函数的实参列表里面
func1(10, 20, 30)
```

**注意：传递参数时，实际就是实参给形参赋值的过程，一定要保证每个形参都有对应的实参。**

##### 参数传递方式

**位置参数**：传参的时候，实参按**位置顺序**给形参赋值。

1. **传递位置参数的时候，形参的个数必须要和实参的个数完全一样，否则会报错**。

```python
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

func1(10, 20, 30)
'''
输出：
a=10
b=20
c=30
'''
```

**关键字参数**：传参的时候，按照**实参列表**中**形参的名称**进行传递。

1. 传递关键字参数的时候，形参的个数必须要和实参的个数完全一样，否则会报错。
2. **实参列表中，关键字参数必须放在所有位置参数后面**。

```python
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

func1(b=20, a=10, c=30)
'''
输出：
a=10
b=20
c=30
'''
```

**默认参数**：在函数声明的时候，形参可以设置默认值。

1. 默认参数在没有实参传递数据的情况下，使用默认值。
2. 默认参数在有实参传递数据的情况下，使用传递的值。
3. **形参列表中，默认参数必须放在所有位置参数后面**。

```python
def func11(a, b='cc', c='bb', d='a'):
    print(a, b, c, d)

func11(10,d='100')
'''
输出：
10 cc bb 100
'''
```

**不定参数**：在传递参数时存在**实参个数不确定**的情况，就需要将形参列表里面的形参变成容器类型。

`*args`：接收实参传递给形参过程中多出来的**位置参数**或者**空值**，以**元祖**的方式呈现。

```python
def foo(x, *args):
    print(x)        # 1
    print(args)     # (2, 3, 4, 5)
# 其中的2,3,4,5都给了args
foo(1,2,3,4,5)

def foo(x, y=1, *args):
    print(x)        # 1
    print(y)        # 2
    print(args)     # (3, 4, 5)
# 其中的x为1，y=1的值被2重置了，3,4,5都给了args
foo(1,2,3,4,5)


def func1(char, *numbers):
    print(char, type(char))         # a <class 'str'>
    print(numbers, type(numbers))   # ()<class 'tuple'>
# 不定参数，也可接收空值，对应的参数的值就是一个空的元祖
func1('a')
```

`**kwargs`：接收实参传递给形参过程中多出来的**关键字参数**或者**空值**，以**字典**的方式呈现。

```python
def foo(x, **kwargs):
    print(x)            # 1
    print(kwargs)       # {'y': 1, 'a': 2, 'b': 3, 'c': 4}

#将y=1,a=2,b=3,c=4以字典的方式给了kwargs    
foo(1,y=1,a=2,b=3,c=4)


# **kwargs必须要写在*args后面
def foo(x, *args, **kwargs):
    print(x)        # 1
    print(args)     # (2, 3, 4)
    print(kwargs)   # {'y': 1, 'a': 2, 'b': 3, 'c': 4}
# 将1传给了x，将2,3,4以元组方式传给了args，y=1,a=2,b=3,c=4以字典的方式给了kwargs
foo(1,2,3,4,y=1,a=2,b=3,c=4)
```

##### 参数位置

在**混用参数**的过程中，必须要规范化参数的所在位置，否则会报错。

**形参列表**：位置参数、默认参数、`*args`、`**kwargs`。

**实参列表**：位置参数、关键字参数。

```
def func(a, b=2, *args):             (正确)
def func(a=1, b=2, **kwargs, *args): (顺序错误，**kwargs必须要写在*args后面)
def func(a, b=2, c):                 (顺序错误，默认参数必须放在所有位置参数后面)
def func(a, b, c: int=3):            (正确，相当于 def func(a, b, c=3):)
```

### 返回值

##### 返回值定义

返回值：**每个函数运行结束以后，都会返回一个值，默认为None**。

1. **调用函数时，函数的返回值是不会被输出的（交互终端除外）**。
2. 在 `print` 函数里面调用函数，**最后**才会输出函数的返回值。

```python
def han():
    print('123')

han()
print(han())
'''
输出：
123   # 第一次调用函数han，输出123
123   # print里面第二次调用函数han，输出123
None  # 函数han运行结束后，print打印其返回值
'''
```

##### 关键字 `return`

`return`：**结束函数运行，并返回指定的值**。

1. `return` 会**结束函数**的运行，**其后面的代码一律不运行**。
2. `return` 会在函数结束以后，**会返回跟在后面的值（可以是多个值或空值）**，多个值得返回类型是**元祖**。
3. 函数的返回值默认为 `None`，是因为函数默认自带了 `return  None` 语句，只是没有显示而已。

使用`return` 结束函数：

```python
def han():
    print('函数开始')
    return 				# 这里结束函数
    print('函数结束')
    
han()  # 这里调用函数
'''
输出：
函数开始
'''
```

使用`return` 设置返回值：

```python
def han():
	print('123')
    return 10000	# 设置返回值为10000

print(han())
'''
输出：
123    # 函数han里面的print('123')输出
10000  # print输出函数han的返回值
'''

def han():
    return 10, 100, 'a'
# return后面返回多个值，返回类型是元祖
print(han(),type(han()))	# (10, 100, 'a') <class 'tuple'>
```

**函数的最终结果就是 `return` 后面的返回值。**

```python
def han():
    print('加油吧，年轻人！')
    return 10000

fan = han()+1	 # 调用han()就是在使用han的返回值
print(fan)       
'''
输出:
加油吧，年轻人！
10001
'''
```

### 作用域

##### 作用域定义

作用域：在函数的不同位置定义变量，变量的可使用范围是不一样的，简单讲，就是**变量的可使用范围**。

1. **定义新的函数或类会影响变量的作用域**，而 `for`、`if`、`while` 等语句不会影响变量的作用域。
2. **这里说的是使用变量（输出变量），而不是赋值变量（定义变量），这是两回事。**
3. 不同变量的作用域一般划为分为：**全局变量、局部变量**。

##### 全局变量

全局变量：**在程序任何位置都可以使用的变量**，作用域是从**声明开始到文件结束**。

```python
a = 10  	             # a是全局变量
print('第一次：',a)

if True:
    print('第二次：',a)

for x in range(1):
    print('第三次：',a)

def func():
    print('第四次：',a)   # a是全局变量，函数内部也可以使用。

func()
'''
输出：
第一次： 10
第二次： 10
第三次： 10
第四次： 10
'''
```

**在一个作用域给一个变量赋值时，会自动认为这个变量是这个作用域的本地变量，并屏蔽作用域外的同名的变量。**

```python
a = 1         # 这里的a是全局变量

def func():
    a = 2     # 函数func里面定义的变量a是本地变量，和上面的全局变量a类似于‘同名不同人’
    print(a)  # 输出本地变量a

print(a)      # 1，这里print在函数func外部，输出的是全局变量a
func()        # 2
```

**函数内部可以使用全局变量，但不能直接赋值全局变量。**

```python
a = 1           # 这里的a是全局变量

def func():
    print(a)    # 使用全局变量a
    
func()          # 1
print(a)        # 1


def func1():
    print(a+1)  # 使用全局变量a加1
    
func1()         # 2
print(a)        # 1


def func2():
    a += 1      # 报错，变量a默认为函数func2的本地变量，但未定义本地变量a
    print(a)    
    
func2()		    
print(a)        # 1
```

##### 局部变量

局部变量：**在函数或类中声明的变量**，作用域是从**声明开始到函数结束**。

```python
def func3():
    aaa = 10    # aaa在函数内声明，为局部变量，作用域是函数内部
    print(aaa)

func3()         # 10
print(aaa)      # 报错,aaa没定义
```

**嵌套的内层函数可以使用外层函数的局部变量，但直接不能赋值。**

```python
# 嵌套的内层函数可以使用外层函数的局部变量
def func1():
    a = 1
    def func2():
        print(a)	# 使用func1中的局部变量a
    func2()

func1()             # 1


def func1():
    a = 1
    def func2():	
        a += 1      # 变量a默认为函数func2的局部变量，但函数func2里面并未定义局部变量a
        print(a)
    func2()

func1()
```

**注意：变量名引用会分作用域进行查找，首先是本地，然后是函数内（如果有的话），之后是全局，最后是内置。**

##### 关键字 `global`

`global` 作用：**在函数或类中声明一个全局变量。**

1. **全局变量的声明和使用是两回事**。
2. 在函数中声明一个全局变量，**必须先执行该函数才能让变量成为可以全局使用的变量**。

```python
def func3():
    global a # 声明a为全局变量
    a = 10
    print(a)

def func4():
    print(a) # 因为在函数func3声明了a为全局变量，因此函数fun4也能使用变量a

# 正确输出顺序：
func3()      # 10，这里首先执行了函数func3，让a成为了全局可以使用的变量
print(a)     # 10，这里使用的变量a是有意义的
func4()      # 10，这里使用的变量a是有意义的

# 错误输出顺序：
func4()      # 报错，此时a还未被定义
print(a)     # 报错，此时a还未被定义
func3()      # 10，这里开始定义a是全局变量
```

声明全局变量的情况：

1. **全局变量赋值**：对一个全局变量赋值，就需要声明 `global` 表示在对一个全局变量进行赋值。
2. **积累变化**：当参数在方法中被改变，若需把变化积累下来，而不是每一次重新变化，就需要声明为全局变量。

```python
names = '唱歌'	   # 全局变量names

def func1():
    names += '跳舞'  # 报错，这里对names进行了赋值，但本地没有定义names变量
    print(names)

func1()             # 报错，本地没有定义names变量
print(names)        # '唱歌'

def func2():
    global names    # 声明函数func2内的变量names为全局变量
    names += '跳舞'  # 这里对names进行了字符串拼接的赋值操作
    print(names)    # 上面声明names为全局变量，这里输出全局变量

# 顺序一：
func2()             # '唱歌跳舞'
print(names)		# '唱歌跳舞'

# 顺序二(积累变化)：       
print(names)		# '唱歌'，这里在函数func2里面全局变量names重新赋值之前进行了输出
func2()             # '唱歌跳舞'
func2()             # '唱歌跳舞跳舞'
```

##### 关键字 `nonlocal`

`nonlocal` 作用：**在内层函数中声明最外层函数的局部变量**。

```python
def func1():
    a = 10
    print('func1函数', a)      # 2.输出：'func1函数10'
    
    def func2():
        nonlocal a            # 4.因为下面对变量a重新赋值，需要声明a为最外层函数func1的局部变量
        a += 10               # 5.对函数func1局部变量a重新赋值
        print('func2函数', a)  # 6.输出：'func2函数20'

    func2()                   # 3.执行内部函数func2()
    print('func1函数', a)      # 7.输出：'func1函数100'

func1()                       # 1.调用外部函数func1()
print(a)                      # 8.a还是函数func1里面的局部变量，在外部不能输出
```
