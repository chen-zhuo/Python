# 线程

线程（Thread）

### 认识线程

##### 核与线程

我们平时经常会听到8核、16核处理器，那这里的核与线程有什么关系呢？单核代表一个线程么？

单核可以有多个线程，只是它的多线程通过分时来实现，即把时间分成片，每片处理一个线程，所有的线程循环处理。

而多核可以同时实现多线程。比如双核系统开两个线程，运行效率将会翻倍。但并不代表效率可以无限提升，多线程个数等于核的个数时，效率达到最高。

打个形象的比喻：（每种动作代表一个线程）

单核单线程：一个人喝完酒，然后抽烟，最后吃烧鸭

单核多线程：一个人喝一口酒，抽一口烟，吃一口烤鸭，同时进行

多核多线程：三个人，一个人喝酒，一个人抽烟，一个人吃烤鸭，互不干扰

##### 线程和进程

**线程是对进程更小维度的划分，同时也是cpu调度的最小单位。**

进程有独立的内存地址空间，就相当于教室，线程就相当于教室里面的学生，他们共用这一间教室，共享内存。

**注意：一个进程可以有多个线程（至少有一个线程），多个线程共享这一个进程内存空间。**

**注意：所有的进程默认都有一个线程（一般叫这个线程为主线程），其他的线程叫子线程。想要在进程中添加其他的线程，就要创建线程对象**

##### 线程特点

优点：**线程没有独立的地址空间，共享数据、内存，内存消耗少，并发性高，运行效率高**

缺点：**一个线程死掉就等于整个进程死掉，多进程的程序要比多线程的程序健壮，不能使用多核，按时间片强制切换，不够灵活**

### 线程程序

##### 线程模块

Python提供了支持多线程的高级模块：**threading**

```
threading 模块提供的常用方法： 
	
	threading.Thread(target=函数名, args=['函数实参列表'])：创建子线程对象
	
	线程对象.start()：开始执子行线程
	
	线程对象.join()：等待子线程结束（join会阻塞线程到任务执行完为止）
	# 注意：若不等待子线程结束，主线程可能会比子线程更快执行完。
	
	threading.Lock()：创建一个线程锁
	with 线程锁对象:  ：可以对线程自动上锁、解锁
	
	threading.activeCount()：返回正在运行的线程数量。
	
	threading.Timer(10,函数名)：创建一个线程对象（通过start运行时，要等待10秒）
	
	threading.Barrier(3)：创建一个线程数为3的对象	
	线程数为3的对象.wait()：等待线程数到达3往下执行

	threading.currentThread()：返回当前的线程变量。 

	threading.enumerate()：返回一个包含正在运行的线程的list。

	threading.TIMEOUT_MAX：设置threading全局超时时间。
```

##### 主线程

**注意：只要运行代码就会有1个线程，这个线程就是进程默认的主线程。**

```
import threading
print('线程数量:', threading.activeCount())

输出：
线程数量: 1
```

##### 增加线程

```
import threading

print('线程数量:', threading.activeCount())

def run():
    print('启动线程')
    print('线程数量:', threading.activeCount())
    print('结束线程')

# 创建子线程对象t1，执行函数run()，注意这里执行函数不要加()
t1 = threading.Thread(target=run)

# 启动子线程t1
t1.start()

# 等待子线程t1结束
t1.join()

print('线程数量:', threading.activeCount())

输出：
线程数量: 1
启动线程
线程数量: 2
结束线程
线程数量: 1
```

##### 线程传参

```
import threading

def run(a,b,c):
    print('启动子线程')
    print(f'传递的参数为{a,b,c}')
    print('结束子线程')

# 加上要传递的参数args，元组类型
t1 = threading.Thread(target=run,args=(1,'2',{'c':3},))

# 启动子线程t1
t1.start()

# 等待子线程t1结束
t1.join()

print('程序结束')

输出：
启动子线程
传递的参数为(1, '2', {'c': 3})
结束子线程
程序结束
```

##### 多线程任务

**耗时间的任务基本上都用异步消息队列或者多线程的⽅式进⾏处理，避免请求被阻塞。**

**注意：CPU执行线程等待时，会执行其他的线程。**

```
import threading
import time

def game():
    for _ in range(3):
        print('打游戏')
        time.sleep(3)

def eat():
    for _ in range(3):
        print('吃龙虾')
        time.sleep(3)


if __name__ == '__main__':
    print('多个线程运行的情况*******************')
    a1 = time.time()
    # 创建子线程
    t1 = threading.Thread(target=game)
    t2 = threading.Thread(target=eat)
    # 启动子线程
    t1.start()
    t2.start()
    # 等待子线程结束
    t1.join()
    t2.join()
    a2 = time.time()
    print(f'用时：{a2-a1}')
    print('单个线程运行的情况*******************')
    a3 = time.time()
    game()
    eat()
    a4 = time.time()
    print(f'用时：{a4-a3}')


输出：
多个线程运行的情况*******************
打游戏
吃龙虾
吃龙虾
打游戏
打游戏
吃龙虾
用时：9.004380702972412
单个线程运行的情况*******************
打游戏
打游戏
打游戏
吃龙虾
吃龙虾
吃龙虾
用时：18.000823736190796
```

##### 线程锁

**当多个线程同时操作一个变量时，就会出现数据混乱，因为不知道以哪个线程为准。**

**注意：这里是操作变量，需要加锁，如果是操作消息队列就不用加锁，因为消息队列里面的数据，用一个少一个。**

```
import threading

num = 0

def run():
    global num
    for i in range(1000000):
        num += i
        num -= i

# 创建线程对象
t1 = threading.Thread(target=run)
t2 = threading.Thread(target=run)
# 启动线程
t1.start()
t2.start()
# 等待线程结束
t1.join()
t2.join()

print(num)

第一次输出：-1515072
第二次输出：-3135633

# 注释：受多个线程操控一个变量的影响，结果数据不一致。
```

为了决解上面出现数据不一致的情况，就需要给线程加锁，**有锁的线程才能操作数据，没有锁的线程就不能操作数据。当一个有锁的线程操作完数据以后，就要释放锁，给其他线程上锁操作数据。**

线程安全：就是多线程访问时，采用了加锁机制。不会出现数据不一致或者数据污染。

**注意：线程获得锁后，若不释放锁，就会出现死锁，其他线程无休止的等待锁的释放。**

```
import threading

num = 0

# 创建一个线程锁对象lock
lock = threading.Lock()

def run():
    global num
    for i in range(1000000):
        # with 线程锁对象：可以对线程自动上锁、解锁
        with lock:
            num += i
            num -= i

# 创建线程对象
t1 = threading.Thread(target=run)
t2 = threading.Thread(target=run)
# 启动线程
t1.start()
t2.start()
# 等待线程结束
t1.join()
t2.join()

print(num)

第一次输出：0
第二次输出：0
```

##### 凑线程

```
import threading
import time

# 创建一个线程数为3的对象bar
bar = threading.Barrier(3)

def run():
	# 因为是子线程，线程数量要减一
    print('子线程数量:', threading.activeCount()-1)
    time.sleep(1)
    
    # 等线程线程数达到3
    bar.wait()
    print('子线程数量达到3')

# 循环创建5个子线程并启动
for i in range(5):
    threading.Thread(target=run).start()
    
输出：
子线程数量: 1
子线程数量: 2
子线程数量: 3
子线程数量: 4
子线程数量: 5
# 这里线程1、2、3数量达到了3，上面代码就以每个线程输出了一次，共三次
子线程数量达到3
子线程数量达到3
子线程数量达到3
# 后面线程4、5数量达不到3，上面代码就一次不输出。
```

##### 定时线程

```
import threading

def run():
    print('启动线程')
    print('结束线程')

# 创建一个线程对象（通过start运行时，要等待5秒）
t1 = threading.Timer(5,run)
t1.start()
t1.join()
print('结束')

输出：
（5秒后）
启动线程
结束线程
结束
```

### GIL全局解释锁

##### 举例说明

例子一：

```
def run():
    while True:
        pass

if __name__ == '__main__':
    # 创建一个子线程
    x1 = threading.Thread(target=run)
    x1.start()
    print(threading.activeCount())	# 2(当前活动线程数：2，一个是主线程，另一个是创建的子线程x1)
    x1.join()
```

解释：例子一，创建了一个子线程x1，子线程是一个死循环，启动这个线程以后，观察任务管理器中CPU的使用率大概20%左右（因为是多核）。

例子二：

```

def run():
    while True:
        pass

if __name__ == '__main__':
    x1 = threading.Thread(target=run)
    x2 = threading.Thread(target=run)
    x1.start()
    x2.start()
    print(threading.activeCount())       # 3(一个主线程，一个是主线程，另两个是创建的子线程x1、x2)
    x1.join()
    x2.join()
```

解释：例子二，创建了一个子线程x1、x2，子线程是一个死循环，启动这两个线程以后，观察任务管理器中CPU的使用率还是只有20%左右。

**产生疑问**：例子二相比于例子一，多起了一个线程，相当于多运行了一个死循环，按常理CPU的使用率应该比例子一要高20%，为什么两个的CPU使用率差不多？

**答案：问题就出在GIL锁，因为它的存在，两个线程看似同时在运行，实则是在交替运行，在任意一个时间点只有一个线程处于执行状态。**

##### GIL全局解释锁

​	全局解释锁(GIL)，简单来说就是一个互斥体(或者说锁)，这样的机制只允许**一个线程来控制Python解释器**。它的作用就是单核的情况下可以实现多任务(并发)，这就意味着在任何一个时间点只有一个线程处于执行状态。

​	GIL对执行单线程任务的程序员们来说并没什么显著影响，但是它成为了计算密集型(CPU-bound)和多线程任务的性能瓶颈。**由于GIL即使在拥有多个CPU核的多线程框架下都只允许一次运行一个线程**，所以在Python众多功能中其声誉可谓是“臭名昭著”

解决办法：**用multiprocess替代Thread**，multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。**唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。**

### 任务类型

**时间和空间是不可调和矛盾。**

解释：当我们使用计算机执行任务的时候有两种模式，一种是用更少的计算机资源和更多的等待时间，另一种是用更多的计算机资源和更少的等待时间。我们通常会选择第二种。

##### I/O密集型

**\IO密集型任务, 是指磁盘 IO、网络 IO 占主要的任务, 计算量很小。**比如请求网页, 读写文件等，在Python中利用time.sleep达到IO密集型任务的效果。

IO 密集型特点：需要等待时间

适用方法：对于IO 密集型任务来说，需要高效率的使用Python解释器来执行线程，当Python解释器遇到IO操作时，立刻去执行其他的线程，避免出现等待，延长程序执行时间。因此最适合方法就是**多线程编程**。

##### CPU密集型

**\CPU密集型任务（也叫计算密集型任务）, 是指 CPU 计算占主要的任务, CPU 一直处于满负荷状态。**比如大量的循环、复杂的加减乘除运算等。

CPU密集型：需要CPU的算力

适用方法：对于CPU密集型任务来说，需要更多的利用CPU的算力，受GIL的束缚，多线程不能充分利用CPU。因此最适合方法就是**多进程编程**，可以非常有效的利用 CPU 。当然同一时间执行的进程数量取决于你电脑的 CPU 核心数。

##### 程序说明

函数run1、run2是CPU密集型，函数run3、run4是I/O密集型

```
import threading
import multiprocessing
import time

def run1():
    for _ in range(10**9):
        pass

def run2():
    for _ in range(10**9):
        pass

def run3():
    for _ in range(3):
        time.sleep(3)

def run4():
    for _ in range(3):
        time.sleep(3)

if __name__ == '__main__':
    # 计算密集型任务
    # 单线程
    t1 = time.time()
    run1()
    run2()
    t2 = time.time()
    print(t2-t1)                        # 46.864145278930664(消耗一般)
    # 多线程
    t1 = time.time()
    r1 = threading.Thread(target=run1)
    r2 = threading.Thread(target=run2)
    r1.start()
    r2.start()
    r1.join()
    r2.join()
    t2 = time.time()
    print(t2-t1)                        # 43.90505313873291(消耗一般)
    # 多进程
    t1 = time.time()
    r1 = multiprocessing.Process(target=run1)
    r2 = multiprocessing.Process(target=run2)
    r1.start()
    r2.start()
    r1.join()
    r2.join()
    t2 = time.time()
    print(t2-t1)                        # 23.373531341552734(消耗多)
#######################################################################################
    # I/O密集型任务
    # 单线程
    t1 = time.time()
    run3()
    run4()
    t2 = time.time()
    print(t2-t1)                        # 18.000738859176636(消耗少)
    # 多线程
    t1 = time.time()
    r1 = threading.Thread(target=run3)
    r2 = threading.Thread(target=run4)
    r1.start()
    r2.start()
    r1.join()
    r2.join()
    t2 = time.time()
    print(t2-t1)                        # 9.002403497695923(消耗一般)
    # 多进程
    t1 = time.time()
    r1 = multiprocessing.Process(target=run3)
    r2 = multiprocessing.Process(target=run4)
    r1.start()
    r2.start()
    r1.join()
    r2.join()
    t2 = time.time()
    print(t2-t1)                        # 9.294548511505127(消耗多)
```

### 补充说明

**python解释器是单线程的，进行多线程编程有必要吗？**

答案：有必要， **多线程能解决很多IO阻塞问题**，能产生IO阻塞的情况很多，比如网络、磁盘，等等。当发生阻塞时，Python是不耗CPU的，此时如果就一个线程就没法处理其他事情了。所以对于含有IO阻塞的环境。多线程至少有机会让你把一个CPU核心跑到100%。

**注意：每次运行程序，都会启用Python解释器。**

**注意：在程序没有运行结束的情况下，运行同一个或其他程序，会有新Python解释器被启用，为节省计算机资源，运行新的程序前，先结束掉未运行完成的程序。**

**注意：Python解释器是单线程，也就是一个进程就是一个Python解释器，每个Python解释器都有自己的GIL锁，这就是为什么多进程程序能摆脱GIL锁的束缚。**
