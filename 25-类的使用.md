# 类的使用

### 运行类

```
class A:
    print('hello')

输出：
hello
```

##### 说明

**运行程序的时候，类不需要被调用，直接运行。**

### 属性和方法

##### 属性

对象属性：**属于对象，不同对象对应的值可能不一样**（通过**对象.属性**来使用）

类的属性：**也称类的字段，声明在类里面，函数外面。类的属性属于类**（通过**类.属性**来使用）

##### 方法

对象方法：**自带一个self参数的函数**（通过**对象.方法（）**来调用）

类方法： 1.**使用装饰器@classmethod来修饰（带有@就是装饰器）**
        	2.**自带一个cls参数，这个参数不用传参，哪个类调用此方法，cls指向哪个类，类似于self**		   		3.**self指向的是对象，cls指向的是类；self可以直接当对象使用，cls也可以直接当类使用**
       	 4.通过**类.方法（）**来调用

静态方法：1.**使用@staticmethod修饰**
          	 2.**没有默认参数**
          	 3.通过**类.方法（）、对象.方法（）**都能调用

##### 选择

如何选择使用对象方法、类方法、静态方法？

1. 实现函数的功能**需要使用对象的属性，就声明成对象方法**
2. 实现函数的功能**需要使用类的字段或者调用类的方法，就声明成类方法**
3. 实现函数功能**既不需要对象属性也不需要类的字段，就声明成静态方法**

##### 举例说明

```
class Person:
    # number是类字段
    number = 61
    
    def __init__(self, name='', age=18):
        # name 和 age是对象属性
        self.name = name
        self.age = age

    # eat方法是对象方法
    def eat(self, food):
        print('%s 在吃 %s' % (self.name, food))

    # hurt_earth就是一个类方法
    @classmethod
    def hurt_earth(cls):
        # cls指向的是调用这个方法的类，cls可以当成类来使用
        # 可以使用cls创建对象
        pt = cls('张三')
        print(pt.name)
		
		# 可以通过cls使用类的字段
        print(cls.number)  
        print('人类破坏环境！！！')

    # protect_earth是一个静态方法
    @staticmethod
    def protect_earth():
        print('人类保护地球')


# 1.类字段要用类来使用
print(Person.number)		      # 61

# 2.对象的属性要通过对象来使用
p1 = Person('小明')
print(p1.name, p1.age)	              # 小明 18

# 3.对象方法用对象调用
p1.eat('面条')			      # 小明 在吃 面条

# 4.类方法通过类来调用
Person.hurt_earth()		      # 张三  61  人类破坏环境！！！

# 5.静态方法通过类或对象来调用
Person.protect_earth()	              # 人类保护地球
p1.protect_earth()		      # 人类保护地球
```

### 内置类属性

##### 类属性

自定义类属性：**人为设定的类字段（类属性）**

内置类属性：**类的自带属性**

```
类.__name__：获取类的名字（字符串）

类.__doc__：获取类的说明文档

类.__dict__：获取类中所有的类属性和对应的值，以键值对的形式存到字典中
对象.__dict__：将对象的属性和对应的值，转换成字典的元素（常用，记住）

类.__module__:获取当前类所在的模块的名字 

类.__bases__:获取当前类的父类
```

**注意：通过\_\_slots\_\_约束对象的属性后，对象\_\_dict\_\_不能使用。 如果父类设置了\_\_slots\_\_，子类对象也不能使用\_\_dict_\_**

##### 举例说明

```
class Cat:
    # 说明文档
    """猫类"""
    
    number = 0

    def __init__(self, name='', color=''):
        self.name = name
        self.color = color

    def run(self):
        print('%s在跑' % self.name)

    @staticmethod
    def shout():
        print('瞄~')

    @classmethod
    def get_number(cls):
        print('猫的数量：%d' % cls.number)


cat1 = Cat('小花', 'white')

print(Cat.__name__)		# Cat

print(Cat.__doc__)		# 猫类

print(Cat.__dict__)		# {'__module__': '__main__', '__doc__': '猫类', 'number': 0,...}
print(cat1.__dict__)	        # {'name': '小花', 'color': 'white'}

print(Cat.__module__)	        # __main__

print(Cat.__bases__)	        # (<class 'object'>,)，表示没有继承其他的父类
```

### 私有化

##### 定义

私有化：**指属性和方法的私有，在外部不能直接使用，但可以在类的内部使用。**

设置私有化：**直接在属性名或者方法名前加\__(双下划线)**

破解私有化属性：**通过  对象.\__dict__['\_类\_\_私有化对象属性']  就可使用对象私有化的属性**

​			       **通过  类.\__dict__['\_类\_\_私有化类属性']  就可使用类私有化的属性**

##### 举例说明

例子1：

```
class Person:

    def __init__(self, name='', age=20):
        self.name = name
        # self.__age将age属性私有化，age不能在外部被直接使用
        self.__age = age

p1 = Person('如花',18)
print(p1.name)							# 如花
print(p1.age)							# 报错，age不能在外部被直接使用
print(p1.__dict__)						# {'name': '如花', '_Person__age': 18}
print(p1.__dict__['_Person__age'])		                # 18
```

例子2：

```
class Person:

    def __init__(self, name='', age=20):
        self.name = name
        # age被私有化为__age
        self.__age = age

    def show_age(self):
    	# __age就只能在类的内部使用
    	# 打印时，还将__age减掉10
        print(self.__age-10)


p1 = Person('如花', 28)
print(p1.name)				# 如花
print(p1.show_age())		        # 18	
				        None（show_age返回值）
print(p1.__dict__['_Person__age'])	# 28
```

例子3：

```
class Person:

    def __init__(self, name='', age=0):
        self.name = name
        self.__age = age

    # 私有的对象方法__run()
    def __run(self):
        print('%s在跑' % self.name)

    def show(self):
    	# __run()只能在类的内部调用
        self.__run()

p1 = Person('如花', 28)
p1.__run()				# 报错，__run()只能在类的内部调用
p1.show()				# 如花在跑
```

例子4：

```
class Person:
    # 私有的类字段__number
    __number = 61

    # 类方法
    @classmethod
    def get_number(cls):
        # __number只能在内部使用
        print(cls.__number)


print(Person.__number)		                # 报错，__number只能在内部使用
print(Person.__dict__['_Person__number'])	# 61
Person.get_number()				# 61
```

### 属性赋值检查

##### 举例说明

一个学生类，希望通过对象给分数赋值的时候，设定分数的值在0-100之间，超出这个范围出现错误。

```
class Student:

    # 检查分数值
    def set_score(self, value):
        if value < 0 or value > 100:
            self.__score = '分数超出范围'
            # 结束函数
            return 
        # 将符合范围的数值的进行赋值
        self.__score = value

    # 获取分数值
    def get_score(self):
        return self.__score


p1 = Student()
p1.set_score(90)		
print(p1.get_score())	# 90

p1.set_score(101)
print(p1.get_score())	# 分数超出范围
```

##### 设置属性值

上面是通过**对象.方法（）**来检查赋值，略显复杂。

使用**getter来获取值**和**setter和设置值**，可以通过**对象.属性**就能检查赋值。

```
1.getter:获取属性的值
@property
def 属性名（去掉下划线）（self）:
    return 返回值

2. setter:设置属性赋值
@属性名（去掉下划线）.setter
def 属性名（去掉下划线）（self,变量名）：
    给带下划线的属性赋值

注意：一个属性必须先要有getter,才能添加setter.
注意：两个函数先后顺序、装饰器（@）顺序、功能都不能改变
注意：两个函数的属性名是一样的
```

```
class Student:

    # 获取分数值
    @property
    def score(self):
        return self.__score

    # 检查分数值
    @score.setter
    def score(self, value):
        if value < 0 or value > 100:
            self.__score = '分数超出范围'
            return
        self.__score = value


p1 = Student()
p1.score = 90
print(p1.score)		# 90

p1.score = 101
print(p1.score)		# 分数超出范围
```

### 类的继承

##### 定义

python中**类是可以继承的，并且支持多继承**。

父类（超类）：**被继承类**

子类：**继承父类的类**

继承：**直接拥有父类的属性和方法（继承后父类的属性和方法还是存在的）**

**注意：继承后，父类不能使用在子类中添加的属性和方法**

##### 继承方式

在声明子类的时候，**括号里添加已存在的父类**

```
class 子类（父类）：
    '''类的说明'''
    属性
    方法
```

**注意：所有的类都会默认继承python的基类：object**

##### 继承内容

1. **对象的属性和方法、类的字段和类方法、静态方法都可以继承（私有化的不能继承）**
2. **\__slots__不会被继承**
3. **getter和setter会被继承**

##### 举例说明

例子1：

```
class Person:

    number = 61

    def __init__(self):
        self.name = ''
        self.age = 18
        self.__length = 0

    def eat(self):
        print('%s在吃饭' % self.name)

    @classmethod
    def get_number(cls):
        print('人类数量：%d' % cls.number)

    @staticmethod
    def hurt_earth():
        print('人类破坏地球')

class Student(Person):
        pass


stu = Student()
stu.name = '小明'				
print(stu.name, stu.age)	# 小明 18
print(stu.__dict__)		# {'name': '小明', 'age': 18, '_Person__length': 0}

stu.eat()			# 小明在吃饭

print(Student.number)		# 61
Student.get_number()		# 人类数量：61
Student.hurt_earth()		# 人类破坏地球
```

例子2：

```
class A:
    name = 'A'
class B:
    name = 'B'
class C(A, B):
    pass
print(C.name)       # A
C.name = 'C'
print(A.name)       # A
print(B.name)       # B
print(C.name)       # C
```

### 类的重定义

##### 重写

重写：**改写子类从父类继承下来的方法**（**子类**再调用这个方法时，就**调用重写后的**）

方法的调用过程：**先看当前类是否有此方法，没有才查看父类有没有此方法，父类没有就看父类的父类有没有，直到找到基类（object）为止。**

重写方式：

1. 全部改写：根据方法的调用过程，**调用方法时会最先查看当前类，所以将子类的方法命名为和父类中要被重写方法一样的名称，即可实现对父类方法的重写。**
2. 部分改写：重写过程中**保留父类方法的功能**，只需要在重写的方法中添加**super（）. 父类方法（）**即可保留父类方法的功能

##### 重写例子

```
class Animal:
    def __init__(self):
        self.age = 0

    def eat(self):
        print('吃东西')

    def shot(self):
        print('叫唤')

class Dog(Animal):
    def look_after(self):
        print('看家')

    # 重写父类的shot
    def shot(self):
        print('汪汪汪~')

    # 重写父类的eat方法
    def eat(self):
        # 保留父类eat的功能
        super().eat()
        print('吃骨头')


dog = Dog()
dog.age = 3
print(dog.age)		# 3
dog.look_after()	# 看家
dog.shot()	        # 汪汪汪~
dog.eat()	        # 吃东西
	                  吃骨头
						  
an = Animal()
an.look_after		# 报错，父类不能使用在子类中添加的属性和方法
an.shot()		# 叫唤
an.eat()	        # 吃东西
```

##### 添加属性

对象属性的继承：是**通过继承init方法来继承**的

给当前类添加对象属性：**重写init方法**（**要保留父类的对象属性，需要使用super()去调用父类的init方法**）

```
class Person(object):
    def __init__(self, name, age=0):
        self.name = name
        self.age = age

class Staff(Person):
    # init方法中的参数：保证在创建对象的时候就可以给某些属性赋值
    def __init__(self, name, age, salary=0):
        # 继承父类的属性
        super().__init__(name, age)
        self.salary = salary


s1 = Staff('张三', 21, 15000)
print(s1.name)					# 张三
print(s1.age)					# 21
print(s1.salary)				# 15000
s1.salary = 10000
print(s1.salary)				# 10000
```
