# 验证码

在爬取数据的过程中，难免会遇到各种各样的验证码来阻挡爬虫，绝大部分的验证码对于人来说还是很好识别并验证成功的。但爬虫不是人，只是一段死板的程序，没有人灵活思维和高效的识别，所以如何破解验证码是爬虫的一个难点，因为它涉及到的不仅仅是爬取数据还有图片识别、轨迹计算等其他方面的分析。

### 图形验证码

##### 安装识别库

当前大多数验证码还是图形验证码，针对这类验证码我们就可以使用 Python 的 OCR 识别库来识别。

**OCR 技术**：图形验证码转换成电子文本，然后将识别的结果提交给服务器，达到自动识别验证码的过程。

**tesserocr**：**即 OCR 识别库** ，但其实是对 tesseract 做的一 层 Python API 封装，所以它的核心是 tesseract。 **因此，在安装 tesserocr 之前，我们需要先安装 tesseract 。**

```python
# 先安装tesseract
pip install tesseract
# 后安装tesserocr
pip install tesserocr
```

##### 安装识别软件

识别图片不仅仅需要识别库，还需要安装识别软件[tesseract-ocr](https://digi.bib.uni-mannheim.de/tesseract/)才能成功识别。

![20190910192903504](image/20190910192903504.png)

其中，文件名中带有dev的为开发版本，不带dev的为稳定版本，选择合适的版本进行安装。

安装过程中，其中可以勾选`Additional language data(download)`选项来安装OCR识别支持的语言包，识别多国语言。

![20190910193132115](image/20190910193132115.png)

将软件的安装路径添加到“系统变量”中Path中保存。

![QQ截图20200412162828](image/QQ截图20200412162828.png)

![QQ截图20200412162849](image/QQ截图20200412162849.png)

![20190910194054116](image/20190910194054116.png)

在后面使用过程中**可能会报这样的错误**：`RuntimeError: Failed to init API, possibly an invalid tessdata path:路径 `

**解决办法**：我们只需要将Tesseract_OCR安装路径下的tessdata的目录，拷贝到上面报错的`路径`中即可。

##### 无背景图片验证码

无背景验证码：指的是**内容背景是单色的，无其花纹的验证码**。

![QQ截图20200411221942](image/QQ截图20200411221942.png)

这类验证码相对简单，tesserocr的**识别率还比较高**的。

```python
# 导入tesserocr
import tesserocr
# 导入图像模块
from PIL import Image

# 方法一：以图片对象的形式来识别的验证码
# 读取image.jpg图片
image = Image.open('image.jpg')
# 识别图片
code1 = tesserocr.image_to_text(image)
# 输出识别结果
print(f'code1识别结果：{code1}')	

# 方法二：以图片文件的形式来识别的验证码（此方法中图片的名称不能有中文否则会报错）
code2 = tesserocr.file_to_text('image.jpg')
# 输出识别结果
print(f'code2识别结果：{code2}')

'''
输出：
code1识别结果：8713
code2识别结果：8713
'''
```

##### 有背景图片验证码

有背景验证码：指的是**背景颜色多样，有花纹的验证码**。

![QQ截图20200412153026](image/QQ截图20200412153026.png)

对于有嘈杂的背景的验证码，**直接识别的识别率会很低**，因此我们就要对图片进行一定的处理，来提高识别率。大体步骤有三点：

1. **灰度化：以黑色为基准色，用不同的饱和度的黑色来显示图像，灰度图像的每个像素点色值在0-255，0代表纯黑，255代表纯白**

![QQ截图20200412160358](image/QQ截图20200412160358.png)

2. **二值化：将小于阈值(129)的像素点统一设置为黑色(0)，反之统一设置为白色(255)，得到黑白图像。**

![QQ截图20200412160409](image/QQ截图20200412160409.png)

3. **去噪点：检测像素点周围邻近的8个像素点，如果有4个即以上的白色像素点，则认为当前像素点是噪点，设置为白色，反之，则不是噪点，设置为黑色。**

![QQ截图20200412160420](image/QQ截图20200412160420.png)

```python
import tesserocr
from PIL import Image

# 打开图片对象
image = Image.open('图片.jpg')
# 图片灰度化
image1 = image.convert("L")
# 显示图片
image1.show()

# 图片二值化，129是二值化的阈值
image2 = image1.point(lambda x: 255 if x > 129 else 0)
image2.show()

# 去噪函数
def denoising(image):
    pixdata = image.load()
    # 获取图片宽高
    w, h = image.size
    # 遍历像素点
    for j in range(1, h - 1):
        for i in range(1, w - 1):
            count = 0
            l = pixdata[i, j]
            if l == pixdata[i, j - 1]:
                count = count + 1
            if l == pixdata[i, j + 1]:
                count = count + 1
            if l == pixdata[i + 1, j - 1]:
                count = count + 1
            if l == pixdata[i + 1, j + 1]:
                count = count + 1
            if l == pixdata[i + 1, j]:
                count = count + 1
            if l == pixdata[i - 1, j + 1]:
                count = count + 1
            if l == pixdata[i - 1, j - 1]:
                count = count + 1
            if l == pixdata[i - 1, j]:
                count = count + 1
            if count < 4:
                pixdata[i, j] = 255
    return image
# 去噪点
image3 = denoising(image2)
image3.show()

# 识别处理后验证图片对象
res = tesserocr.image_to_text(image3)
print(res)

'''
输出：
FocZ
'''
```

我这里选择的是**中规中矩比较好识别的验证码，OCR才能成功识别**。但对于**字符有扭曲、变形的验证码，使用OCR去识别成功率率就很低了**，这就**需要软件将验证码字符进行切割处理为像素块来识别**，类似于下图，这里就不介绍了。**总的来说，OCR的识别成功率并不高**。

![QQ截图20200412161741](image/QQ截图20200412161741.png)

### 滑块验证码

##### 滑块验证码简介

普通图片验证码：即**方形缺口的图片验证码，将图片拖动至缺口位置即可验证成功**。

![QQ截图20200412164601](image/QQ截图20200412164601.png)

##### 网站验证分析

经过分析，当前网站(**不代表其他网站**)的**验证方式就是验证滑块的移动距离**。**若移动距离等于滑块到缺口的距离，则验证成功，其他情况就验证失败。**

![QQ截图20200412165924](image/QQ截图20200412165924.png)

当验证成功以后，访问网站的URL就会带上滑块的位移距离。

![QQ截图20200412170719](image/QQ截图20200412170719.png)

既然这样，我们就直接识别大背景图中白色缺口所在位置即可。因为是最终需要的是位移距离，因此问我们**只需要知道白色缺口的横坐标，即下图红线的长度**。

![下载](image/下载.png)

##### 像素点比对

```python
from PIL import Image

# 打开图片对象
image1 = Image.open('image.png')
# 白色像素点个数
count = 0
# 像素点遍历方式：从上往下，从左往右
# 遍历图片的X轴
for x in range(0, image1.size[0]):
    # 遍历图片的Y轴
    for y in range(0, image1.size[1]):
        # 获取当前坐标色素点的RGB值
        color = image1.load()[x, y]
        # 白色的RGB值(255,255,255)，但颜色识别会有误差，因此认为RGB值不小于(245,245,245)即为白色
        if color[0] >= 245 and color[1] >= 245 and color[2] >= 245:
            count +=1
        # 当连续出现25个白色像素点时，则认为找到白色方块缺口
        else:
            if count > 0:
                count -=1
        if count > 25:
            break
    if count > 25:
        break

# 输出X轴的横坐标
print(f'白色缺口横坐标：{x}')        # 白色缺口横坐标：153
```

### 极验验证码

##### 极验验证码简介

极验验证码：即**拼图缺口的图片验证码，将滑块的凹凸处拖动至缺口的凹凸处即可验证成功**。

![QQ截图20200412175446](image/QQ截图20200412175446.png)

##### 验证码区别

极验验证码相比滑块验证码，在缺口上多了凹凸，不仅如此还添加其他情况，验证更加严格：

1. **验证失效**：当频繁滑动极验验证码时，会偶尔出现“怪物吃掉拼图”、“请重新验证”等验证失效的情况。
2. **时间限制**：极验验证码生成时，若没有及时验证，即使后面验证通过，也会要求重新再验证一次。
3. **轨迹验证**：在拖动滑块时，会记录并上传滑块的移动轨迹，服务器会分析判定是否为人类行为还是机器行为。

##### 破解极验思路

这里就只先讲解一下破解极验的思路，因为操作要用到Selenium自动化测试工具，因此具体的破解代码就放到[爬虫15—Selenium自动化测试工具]()中再详细讲解。

1. **访问登录页面，确保必要的元素加载完成。**
2. 点击**按钮周围**节点，获取**不带缺口**的验证码。

![QQ截图20200412190423](image/QQ截图20200412190423.png)

3. 再点击**按钮**节点，获取**带缺口**的验证码。

![QQ截图20200412175446](image/QQ截图20200412175446.png)

4. 先将原图和有滑块的图进行像素对比，找到如图所标的两点位置;可以从右向左找到右边

   点的位置,











7. 通过遍历两张图片的像素点，比较RGB值
8. 超出一定范围的值认定为缺口，获得缺口位置
9. 根据缺口位置计算出滑块需要滑动的距离
10. **模拟人类操作，需要对滑块进行加速直线运动**，
11. **根据距离和加速度公式，生成移动轨迹**
12. **让滑块根据移动轨迹来滑动，到达缺口**

```
import time
from io import BytesIO
from PIL import Image
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

USER = '...'  # ⽤户名
PASSWORD = '...'  # 密码


class CrackGeetest():

	# 对象初始化
    def __init__(self):
        self.url = 'https://passport.bilibili.com/login'
        self.browser = webdriver.Chrome()
        self.wait = WebDriverWait(self.browser, 10)
        self.email = USER
        self.password = PASSWORD

	# 打开链接，等待节点加载，输入字符
    def open(self):
        self.browser.get(self.url)
        email = self.wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="login-username"]')))
        password = self.wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="login-passwd"]')))
        email.send_keys(self.email)
        password.send_keys(self.password)

	# 获取验证码元素，返回验证码位置元组
    def get_position(self):
        img = self.wait.until(EC.presence_of_element_located((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_widget gt_clean gt_show"]')))
        time.sleep(2)
        location = img.location
        top, bottom, left, right = location['y'] + 60, location['y'] + 205, location['x'] + 218, location['x'] + 480
        return top, bottom, left, right

	# 获取⽹⻚截图，返回截图对象
    def get_screenshot(self):
        screenshot = self.browser.get_screenshot_as_png()
        screenshot = Image.open(BytesIO(screenshot))
        return screenshot

	# 获取验证码图⽚，返回图⽚对象
    def get_geetest_image(self, name='captcha.png'):
        top, bottom, left, right = self.get_position()
        print('验证码位置', top, bottom, left, right)
        screenshot = self.get_screenshot()
        captcha = screenshot.crop((left, top, right, bottom))
        captcha.save(name)
        return captcha

	# 获取按钮周围节点，返回按钮对象
    def get_geetest_button(self):
        button = self.wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_guide_tip gt_show"]')))
        return button
	
	# 获取滑块按钮节点，返回按钮对象
    def get_slider(self):
        button = self.wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_slider_knob gt_show"]')))
        return button

	# 判断两个像素是否相同
    def is_pixel_equal(self, image1, image2, x, y):
        """
        :param image1: 图⽚1
        :param image2: 图⽚2
        :param x: 位置x
        :param y: 位置y
        :return: 像素是否相同
        """
        # 取两个图⽚的像素点
        pixel1 = image1.load()[x, y]
        pixel2 = image2.load()[x, y]
        threshold = 80
        # ⽐较像素点的RGB值,本⽂设置的差值在80以内,可以根据情况调整
        if abs(pixel1[0] - pixel2[0]) < threshold and abs(pixel1[1] - pixel2[1]) < threshold and abs(pixel1[2] - pixel2[2]) < threshold:
            return True
        else:
            return False
	
	# 返回图⽚左边多余不⽤进⾏对⽐的距离
    def get_gap_1(self):
        return 15

	# 遍历图片像素点，返回缺⼝偏移量
    def get_gap_2(self, image1, image2):
        """
        :param image1: 不带缺⼝图⽚
        :param image2: 带缺⼝图⽚
        """
        left = 15  # left 是图⽚左边多余不⽤进⾏对⽐的距离
        high = 37  # 图⽚下⾯多余不⽤进⾏对⽐的距离
        for i in range(image1.size[0] - 1, left, -1):
            for j in range(image1.size[1] - high):
                if not self.is_pixel_equal(image1, image2, i, j):
                    left = i
                    return left
        return left
        
	# 根据偏移量，计算移动距离，返回移动轨迹
    def get_track(self, distance):
        """
        :distance: 偏移量
        """
        # 移动轨迹
        track = []
        # 当前位移
        current = 0
        # 计算间隔
        t = 0.2
        # 初速度
        v = 0
        # 只有正加速，速度越大，后面距离偏差越大，适当减少
        if distance <= 70:
            pass
        elif distance <= 100:
            distance -= 5
        elif distance <= 110:
            distance -= 7
        elif distance <= 120:
            distance -= 10
        elif distance <= 130:
            distance -= 12
        elif distance <= 140:
            distance -= 14
        elif distance <= 150:
            distance -= 16
        elif distance <= 160:
            distance -= 18
        elif distance <= 180:
            distance -= 22
        elif distance <= 190:
            distance -= 27
        elif distance <= 200:
            distance -= 32
        elif distance <= 210:
            distance -= 35
        while current < distance:
            # 加速度
            a = 4
            # 初速度v0
            v0 = v
            # 当前速度v = v0 + at
            v = v0 + a * t
            # 移动距离x = v0t + 1/2 * a * t^2
            move = v0 * t + 1 / 2 * a * t * t
            # 当前位移
            current += move
            # 加⼊轨迹
            track.append(round(move))
        return track

	# 根据移动轨迹来拖动滑块到缺口处
    def move_to_gap(self, slider, track):
        """
        :param slider: 滑块
        :param track: 轨迹
        """
        ActionChains(self.browser).click_and_hold(slider).perform()
        for x in track:
            ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform()
        time.sleep(0.5)
        ActionChains(self.browser).release().perform()

	# 汇总使用上面方法
    def crack(self):
        # 输⼊⽤户名密码
        self.open()
        # 点击验证按钮
        button = self.get_geetest_button()
        button.click()
        # 获取验证码图⽚
        image1 = self.get_geetest_image('captcha1.png')
        # 点按呼出缺⼝
        slider = self.get_slider()
        slider.click()
        # 获取带缺⼝的验证码图⽚
        image2 = self.get_geetest_image('captcha2.png')
        # 获取缺⼝1位置
        gap1 = self.get_gap_1()
        # 获取缺⼝2位置
        gap2 = self.get_gap_2(image1, image2)
        gap = gap2 - gap1
        print('缺⼝1位置', gap1)
        print('缺⼝2位置', gap2)
        print('缺⼝距离', gap)
        # 获取移动轨迹
        track = self.get_track(gap)
        print('滑动轨迹', track)
        # 拖动滑块
        self.move_to_gap(slider, track)


def main():
    crack = CrackGeetest()
    crack.crack()
    # 验证成功后，休息50秒
    time.sleep(50)


if __name__ == '__main__':
    main()
```
