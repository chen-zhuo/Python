# 生成器、迭代器、装饰器

### 生成器（`generator`）

##### 生成器定义

```python
# 将列表[0，1，2，3，4，5，6，7，8，9]中的每个值加1，实现方法：

# 遍历法
info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
b = []
for i in info:
    b.append(i+1)
print(b)                      # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 列表生成式
a = [i+1 for i in range(10)]
print(a)                      # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

假如列表里面有1亿个元素，但仅需使用前10个元素，通过上面的方法，不仅会浪费时间，而且不必要元素还会占用很大的存储空间。因此我们需要**一种不必创建完整的列表，而列表元素可以按照某种算法推算出来的机制**。

**生成器（`generator`）**：**`Python` 中一边循环一边计算的机制**。

##### 创建生成器

方法一：通过修改列表生成式的符号，将列表生成式中的 `[]`改为 `()`，就创建一个生成器

```python
# 列表生成式
lis = [x*x for x in range(5)]
print(lis)				# [0, 1, 4, 9, 16]

# 生成器
generator_ex = (x*x for x in range(5))
print(generator_ex)		# <generator object <genexpr> at 0x000002A4CBF9EBA0>
```

方法二：通过使用 `xrange` 函数来生成生成器。

**`xrange` 函数**：`Python` 中生成生成器的函数。

1. 在生成很长的数字序列的时候，`xrange` 比 `range` 性能优很多，**因为不用一上来就开辟很大的内存空间**。

```python
range函数：range(start, end, step)，根据start与end指定的范围以及step设定的步长，生成一个序列。
>>> range(5)
[0, 1, 2, 3, 4]
>>> range(1,5)
[1, 2, 3, 4]
>>> range(0,6,2)
[0, 2, 4]

xrange 函数说明：用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。
>>> xrange(5)
xrange(5)
>>> list(xrange(5))
[0, 1, 2, 3, 4]

>>> xrange(1,5) 
xrange(1, 5)
>>> list(xrange(1,5))
[1, 2, 3, 4]

>>> xrange(0,6,2)
xrange(0, 6, 2)
>>> list(xrange(0,6,2))
[0, 2, 4]
```

##### 生成数据

生成器可以看成一个**存储数据的容器**，需要数据的时候就用 `next()` 或 `__next__()` 方法取一个。

1. 数据**只能从前往后一个一个生产，不能跳跃，也不能从后往前**。
2. **每个数据只能生成一次**，生成后的数据，不能再次生成。
3. **没有数据能生成时，使用 `next()` 方法会报错**。

```python
# 方法一：多次使用next()或__next__()来生成数据，但没有数据生成会报错
generator_ex = (x*x for x in range(3))
print(next(generator_ex))
print(next(generator_ex))
print(generator_ex.__next__())
print(generator_ex.__next__())

'''
输出：
0
1
4
报错，没有数据能生成
'''

# （推荐）方法二：使用for循环来取数据
generator_ex = (x*x for x in range(3))
for i in generator_ex:
    print(i)
'''
输出：
0
1
4
'''
```

##### 关键字 `yield`

**关键字 `yield`**：在**函数**的**任何位置**声明**有 `yield` 关键字**就是一个**生成器**。

1. `return`，返回后面的值，结束函数，函数。
2. `yield`，返回后面的值，暂停函数，生成器。
3. `yield` 会暂停循环，**当使用 `next()` 或 `__next__()` 取数据时，又从暂停的位置继续循环，直到下一个 `yield`**，用多少，取多少，不占内存。

```python
# 普通函数
def fun():
    print(1)

fun()
print(fun())
'''
输出：
1     # 由fun()输出
1     # 由print(fun())里面的fun()输出
None  # 由print(fun())输出
'''

# 生成器
def fun():
    print(1)
    yield 2         # 有yield是生成器
    print(3)
    yield 4         # 有yield是生成器

fun()               # 这里fun()不会有任何输出，因为有yield存在，fun()变成了一个生成器
print(fun())
print(next(fun()))  # 生成器，需要配合next()方法来使用
print(next(fun()))
c = fun()           # 同样这里也不会有任何输出
print(c)
print(next(c))
print(next(c))
'''
输出：
<generator object fun at 0x00000077C755CF10>  # 由print(fun())输出生成器
1   # 由第一个print(next(fun()))输出
2   # 由第一个print(next(fun()))输出
1   # 由第二个print(next(fun()))输出，因为是重新调用了生成器，所以重新输出了上面的值
2   # 由第二个print(next(fun()))输出，因为是重新调用了生成器，所以重新输出了上面的值
<generator object fun at 0x00000077C755CF10>  # 由print(c)输出
1   # 由第一个print(next(c))输出
2   # 由第一个print(next(c))输出
3   # 由第二个print(next(c))输出，因为是第二次调用同一生成器，所以输出的值与上面不同
4   # 由第二个print(next(c))输出，因为是第二次调用同一生成器，所以输出的值与上面不同

# 注释：这是由于Python的对象引用计数机制，函数的使用次数没有计数，而函数赋值的变量使用次数有计数。
'''
```

`send(msg)`方法

 `next()` 等于 `send(None)` ， `send(msg)` 可以传递 `yield msg` 的值。

```python
def s():
    print('study yield')
    m = yield 1
    print(m)
    yield 2

c = s()
print(next(c))         # 相当于send(None)
print(next(c)) 
d = s()
print(next(d))
print(d.send('new'))

'''
输出：
study yield  # 由第一个print(next(c))输出
1            # 由第一个print(next(c))输出
None         # 由第二个print(next(c))输出，将yield 1变成了None并赋值给了m
2            # 由第二个print(next(c))输出
study yield  # 由print(next(d))输出
1            # 由print(next(d))输出
new          # 由print(d.send('new'))输出，将yield 1变成了new并赋值给了m
2            # 由print(d.send('new'))输出
'''
```

**for循环**

**需要不断调用yield代码，程序才不会暂停中断**。正确方法使用for循环。

```
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
for i in fib(5):
    print(i)
     
结果：
1
1
2
3
5

```

但是用for循环拿不到return语句的返回值，如果想要拿到返回值，必须捕获StopIteration错误。

```
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'

g = fib(5)
while True:
    try:
        x = next(g)
        print('generator: ',x)
    except StopIteration as e:
        print("生成器返回值：",e.value)
        break

结果：
generator:  1
generator:  1
generator:  2
generator:  3
generator:  5
生成器返回值： done

```

**中断generator**

上面的例子中，当没有可执行程序的时候，会抛出一个StopIteration, 开发过程中，中断Generator是一个非常灵活的技巧

```
def g4():
    yield 1
    yield 2
    yield 3

g = g4()
print(next(g))      # 1
print(next(g))      # 2
g.close()           # 中断generator
print(next(g))      # StopIteration，因为上面中断生成器，所以yield 3并不会输出。

```

# 迭代器

**注意：迭代的含义就是循环。**

### 迭代对象

for循环可以作用于两类数据：1.集合数据类型（list、dict、str等）；2.函数中带yield的生成器。

##### 定义

**可以直接作用于for 循环的对象**统称为**可迭代对象**：**Iterable**

**注意：这里也可以说，生成器是可迭代对象。**

##### isinstance()判断

使用isinstance()就可以判断一个对象是否为可迭代对象

```
>>> from collections import Iterable
>>> isinstance([], Iterable)
True
>>> isinstance({}, Iterable)
True
>>> isinstance('abc', Iterable)
True
>>> isinstance((x for x in range(10)), Iterable)
True
>>> isinstance(100, Iterable)
False
```

### 迭代器

生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值。

##### 定义

**可以被next()函数调用并不断返回下一个值的对象**称为**迭代器**：**Iterator**

**注意：这里也可以说，生成器是迭代器。**

##### isinstance()判断

可以使用isinstance()判断一个对象是否为迭代器

```
>>> from collections import Iterator
>>> isinstance((x for x in range(10)), Iterator)
True
>>> isinstance([], Iterator)
False
>>> isinstance({}, Iterator)
False
>>> isinstance('abc', Iterator)
False
```

##### iter()函数

`list`、`dict`、`str`虽然是`Iterable（可迭代对象）`，却不是`Iterator（迭代器）`。**使用`iter()`函数，把迭代对象变为迭代器**：

```
>>> isinstance(iter({}), Iterator)
True
>>> isinstance(iter('abc'), Iterator)
True
```

### 生成器和迭代器

##### 区别

```
1.通过实现迭代器协议对应的__iter__()和next()方法，可以自定义迭代器类型。
2.可迭代对象，可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。
3.生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义__iter__()和next()方法。
4.生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。
```

# 装饰器

### 什么是装饰器？

​	装饰器实际上就是为了给某程序增添功能，但该程序已经上线或已经被使用，那么就不能大批量的修改源代码，这样是不科学的也是不现实的，因为就产生了装饰器。

​	简单来说，可以把装饰器理解为一个包装函数的函数，它一般将传入的函数或者是类做一定的处理，返回修改之后的对象。所以我们能够在不修改原函数的基础上，在执行原函数前后执行别的代码，比较常用的场景有日志插入，事物处理等。

**装饰器三要点：**

1. 不能修改被装饰的函数的源代码
2. 不能修改被装饰的函数的调用方式
3. 满足1、2的情况下给程序增添功能

**< 函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 = 装饰器 >**

这个式子是贯穿装饰器的灵魂所在！

### 装饰器的实现

假设有代码：

```
improt time
def test():
    time.sleep(2)
    print("test is running!")
test()
```

很显然，这段代码运行的结果一定是：等待约2秒后，输出

> test is running

- 那么要求在满足三原则的基础上，给程序添加统计运行时间（2 *second*）功能

在行动之前，我们先来看一下文章开头提到的原因1（关于函数“变量”（或“变量”函数）的理解）

##### 函数“变量”（或“变量”函数）

假设有代码：

```
x = 1
y = x
def test1():
    print("Do something")
test2 = lambda x:x*2
```

那么在内存中，应该是这样的：

![img](http://i.imgur.com/XG8SykL.jpg)

很显然，函数和变量是一样的，都是“一个名字对应内存地址中的一些内容” 
那么根据这样的原则，我们就可以理解两个事情：

1. test1表示的是函数的内存地址
2. test1()就是调用对在test1这个地址的内容，即函数

如果这两个问题可以理解，那么我们就可以进入到下一个原因(关于高阶函数的理解)

##### 高阶函数

那么对于高阶函数的形式可以有两种：

1. 把一个函数名当作实参传给另外一个函数（“实参高阶函数”）
2. 返回值中包含函数名（“返回值高阶函数”）

那么这里面所说的函数名，实际上就是函数的地址，也可以认为是函数的一个标签而已，并不是调用，是个名词。如果可以把函数名当做实参，那么也就是说可以把函数传递到另一个函数，然后在另一个函数里面做一些操作，根据这些分析来看，这岂不是满足了装饰器三原则中的第一条，即不修改源代码而增加功能。那我们看来一下具体的做法：

还是针对上面那段代码：

```
import time

def test():
    time.sleep(2)
    print("test is running!")

def deco(func):  
    start = time.time()
    func() #2
    stop = time.time()
    print(stop-start)

deco(test) #1
```

我们来看一下这段代码，在#1处，我们把test当作实参传递给形参func，即func=test。注意，这里传递的是地址，也就是此时func也指向了之前test所定义的那个函数体，可以说在deco()内部，func就是test。在#2处，把函数名后面加上括号，就是对函数的调用（执行它）。因此，这段代码运行结果是：

> test is running! 
> the run time is 3.0009405612945557

我们看到似乎是达到了需求，即执行了源程序，同时也附加了计时功能，但是这只满足了原则1（不能修改被装饰的函数的源代码），但这修改了调用方式。假设不修改调用方式，那么在这样的程序中，被装饰函数就无法传递到另一个装饰函数中去。

那么再思考，如果不修改调用方式，就是一定要有test()这条语句，那么就用到了第二种高阶函数，即返回值中包含函数名

如下代码：

```
import time

def test():
    time.sleep(2)
    print("test is running!")

def deco(func):  
    print(func)
    return func 
t = deco(test) #3
#t()#4

test()
```

我们看这段代码，在#3处，将test传入deco()，在deco()里面操作之后，最后返回了func，并赋值给t。因此这里test => func => t，都是一样的函数体。最后在#4处保留了原来的函数调用方式。 
看到这里显然会有些困惑，我们的需求不是要计算函数的运行时间么，怎么改成输出函数地址了。是因为，单独采用第二张高阶函数（返回值中包含函数名）的方式，并且保留原函数调用方式，是无法计时的。如果在deco()里计时，显然会执行一次，而外面已经调用了test()，会重复执行。这里只是为了说明第二种高阶函数的思想，下面才真的进入重头戏。

##### 嵌套函数

嵌套函数指的是在函数内部定义一个函数，而不是调用，如：

```
def func1():
    def func2():
        pass
而不是
def func1():
    func2()
```

另外还有一个题外话，函数只能调用和它同级别以及上级的变量或函数。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。

那么我们再回到我们之前的那个需求，想要统计程序运行时间，并且满足三原则。

代码：

```
improt time

def timer(func) #5
    def deco():  
        start = time.time()
        func()
        stop = time.time()
        print(stop-start)
    return deco

test = timer(test) #6

def test():
    time.sleep(2)
    print("test is running!")   
test() #7
```

这段代码可能会有些困惑，怎么忽然多了这么多，暂且先接受它，分析一下再来说为什么是这样。

首先，在#6处，把test作为参数传递给了timer()，此时，在timer()内部，func = test，接下来，定义了一个deco()函数，当并未调用，只是在内存中保存了，并且标签为deco。在timer()函数的最后返回deco()的地址deco。

然后再把deco赋值给了test，那么此时test已经不是原来的test了，也就是test原来的那些函数体的标签换掉了，换成了deco。那么在#7处调用的实际上是deco()。

那么这段代码在本质上是修改了调用函数，但在表面上并未修改调用方式，而且实现了附加功能。

那么通俗一点的理解就是：

把函数看成是盒子，*test是小盒子*，*deco是中盒子*，*timer是大盒子*。程序中，把*小盒子test*传递到*大盒子temer*中的*中盒子deco*，然后再把*中盒子deco*拿出来，打开看看（调用）

这样做的原因是：

我们要保留test()，还要统计时间，而test()只能调用一次（调用两次运行结果会改变，不满足），再根据函数即“变量”，那么就可以通过函数的方式来回闭包。于是乎，就想到了，把test传递到某个函数，而这个函数内恰巧内嵌了一个内函数，再根据内嵌函数的作用域（可以访问同级及以上，内嵌函数可以访问外部参数），把test包在这个内函数当中，一起返回，最后调用这个返回的函数。而test传递进入之后，再被包裹出来，显然test函数没有弄丢（在包裹里），那么外面剩下的这个test标签正好可以替代这个包裹（内含test()）。

![img](http://i.imgur.com/hDBssgi.jpg)

至此，一切皆合，大功告成，单只差一步。

### 真正的装饰器

根据以上分析，装饰器在装饰时，需要在每个函数前面加上：

> test = timer(test)

显然有些麻烦，Python提供了一种语法糖，即：

> @timer

这两句是等价的，只要在函数前加上这句，就可以实现装饰作用。

以上为无参形式

### 装饰有参函数

```
import time

def timer(func):
    def deco():  
        start = time.time()
        func()
        stop = time.time()
        print(stop-start)
    return deco

@timer
def test(parameter): #8
    time.sleep(2)
    print("test is running!")   
test() 
```

对于一个实际问题，往往是有参数的，如果要在#8处，给被修饰函数加上参数，显然这段程序会报错的。错误原因是test()在调用的时候缺少了一个位置参数的。而我们知道test = func = deco，因此test()=func()=deco() 
,那么当test(parameter)有参数时，就必须给func()和deco()也加上参数，为了使程序更加有扩展性，因此在装饰器中的deco()和func()，加如了可变参数*agrs和 **kwargs。

完整代码如下：

```
improt time

def timer(func)
    def deco(*args, **kwargs):  
        start = time.time()
        func(*args, **kwargs)
        stop = time.time()
        print(stop-start)
    return deco

@timer
def test(parameter): #8
    time.sleep(2)
    print("test is running!")   
test() 
```

那么我们再考虑个问题，如果原函数test()的结果有返回值呢？比如：

```
def test(parameter): 
    time.sleep(2)
    print("test is running!")   
    return "Returned value"
```

那么面对这样的函数，如果用上面的代码来装饰，最后一行的test()实际上调用的是deco()。有人可能会问，func()不就是test()么，怎么没返回值呢？

其实是有返回值的，但是返回值返回到deco()的内部，而不是test()即deco()的返回值，那么就需要再返回func()的值，因此就是：

```
def timer(func)
    def deco(*args, **kwargs):  
        start = time.time()
        res = func(*args, **kwargs)#9
        stop = time.time()
        print(stop-start)
        return res#10
    return deco
```

其中，#9的值在#10处返回。

完整程序为：

```
import time

def timer(func)
    def deco(*args, **kwargs):  
        start = time.time()
        res = func(*args, **kwargs)
        stop = time.time()
        print(stop-start)
        return res
    return deco

@timer
def test(parameter): #8
    time.sleep(2)
    print("test is running!")   
    return "Returned value"
test() 
```

### 带参数的装饰器

又增加了一个需求，一个装饰器，对不同的函数有不同的装饰。那么就需要知道对哪个函数采取哪种装饰。因此，就需要装饰器带一个参数来标记一下。例如：

> @decorator(parameter = value)

比如有两个函数：

```
def task1():
    time.sleep(2)
    print("in the task1")

def task2():
    time.sleep(2)
    print("in the task2")

task1()
task2()
```

要对这两个函数分别统计运行时间，但是要求统计之后输出：

> the task1/task2 run time is : 2.00……

于是就要构造一个装饰器timer，并且需要告诉装饰器哪个是task1，哪个是task2，也就是要这样：

```
@timer(parameter='task1') #
def task1():
    time.sleep(2)
    print("in the task1")

@timer(parameter='task2') #
def task2():
    time.sleep(2)
    print("in the task2")

task1()
task2()
```

那么方法有了，但是我们需要考虑如何把这个*parameter*参数传递到装饰器中，我们以往的装饰器，都是传递函数名字进去，而这次，多了一个参数，要怎么做呢？ 
于是，就想到再加一层函数来接受参数，根据嵌套函数的概念，要想执行内函数，就要先执行外函数，才能调用到内函数，那么就有：

```
def timer(parameter): #
    print("in the auth :", parameter)

    def outer_deco(func): #
        print("in the outer_wrapper:", parameter)

        def deco(*args, **kwargs):

        return deco

    return outer_deco
```

首先timer(parameter)，接收参数*parameter*=’task1/2’，而@timer(parameter)也恰巧带了括号，那么就会执行这个函数， 那么就是相当于：

```
timer = timer(parameter)
task1 = timer(task1)
```

后面的运行就和一般的装饰器一样了：

```
import time

def timer(parameter):

    def outer_wrapper(func):

        def wrapper(*args, **kwargs):
            if parameter == 'task1':
                start = time.time()
                func(*args, **kwargs)
                stop = time.time()
                print("the task1 run time is :", stop - start)
            elif parameter == 'task2':
                start = time.time()
                func(*args, **kwargs)
                stop = time.time()
                print("the task2 run time is :", stop - start)

        return wrapper

    return outer_wrapper

@timer(parameter='task1')
def task1():
    time.sleep(2)
    print("in the task1")

@timer(parameter='task2')
def task2():
    time.sleep(2)
    print("in the task2")

task1()
task2()
```

至此，装饰器的全部内容结束。

**注意：在调用被装饰器装饰的函数时，后面不带（），就上面例子直接写task1，task2，就行了，加了括号也能运行出结果，但是会报一个错误TypeError: 'NoneType' object is not callable（对象是不可调用的），这只是因为带括号的写法对装饰器不友好造成的**

