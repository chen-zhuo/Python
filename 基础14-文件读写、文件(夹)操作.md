# 文件读写、文件(夹)操作

## 文件读写

### 文件读写概念

文件类型大体分为两类：

1. **文本文件**：存储有效字符信息的文件。
2. **二进制文件**：音频文件、视频文件、图片文件等。

**文件读写流程：打开文件 -> 读写文件（文本文件需要设置编码，二进制文件不需要设置） -> 关闭文件**

!> 当文本文件的编码和读写操作设置的编码不相对应时，打开文本文件可能会出现乱码情况。

### 文件读写方法

```python
# 打开文件
open(文件路径，打开方式，编码方式)
'''
文件路径 ————> 决定打开哪个文件
绝对路径：文件在磁盘中的完整位置，一般放在工程外面的文件使用绝对路径
# C:\酌\Desktop\新建文本文档.txt
相对路径：相对于当前进行操作的文件的位置./或../，一般文件在工程目录下的某个位置使用相对路径（推荐）
# ./test1.txt   # 表示test1文件和操作文件在同一文件夹下
# ../test1.txt  # 表示test1文件和操作文件在不同一文件夹下

打开方式 ————> 进行什么样的操作
文本文件：
'r': 读操作（默认，读出来是字符串）
'w': 写操作（清空原有数据，将文本数据写入文件）
'a': 写操作（保留以前的数据，将新的数据写入文件）
'r+': 可读、可写，文件不存在会报错，写操作时会覆盖
'w+': 可读、可写，文件不存在先创建，会覆盖
'a+': 可读、可写，文件不存在先创建，不会覆盖，追加在末尾
二进制文件：
'rb'/'br'  - 读操作（读出来的数据是二进制）
'wb'/'bw'  - 写操作（清空原有数据，将二进制数据写入文件）
注意：以读的方式'r'或'rb'打开文件，如果这个文件不存在，会报错；以写的方式'w'或'wb'打开文件，如果这个文件不存在，就会创建这个文件

编码方式 ————> 针对文本文件的读写，二进制文件读写不设置
'utf-8'、'gbk'、'gb2312'...
'''
# 写操作
文件对象.write('写入的内容')

# 读操作
接受变量 = 文件对象.read(n)	    # n为读取长度，n为空代表读取全部
接受变量 = 文件对象.readline()  # 只读取文本第一行的内容，以字符串的形式返回结果
接受变量 = 文件对象.readlines() # 读取文本全部内容，以列表的形式返回结果，每行信息为一个列表元素

# 关闭操作
文件对象.close()

# 文本文件打开关闭操作示例：
f1 = open('./test1.txt', 'w', encoding='utf-8') # 打开方式'w'，并设置编码格式utf-8
f1.write('疑是地上霜') # 向文件里面写入'疑是地上霜'
f1.close()           # 关闭文件

f2 = open('./test1.txt', 'r', encoding='utf-8') # 打开方式'r'，并设置编码格式utf-8
content1 = f2.read() # 读文件里面内容'疑是地上霜'
f2.close()           # 关闭文件
```

**使用关键字 `with` 结合 `open()` 方法来打开文件会更快捷，在文件操作结束后会自动去关闭文件，也就没有 `close()` 关闭操作。**

```python
with open() as 文件对象：
     文件读写操作
```

### 文本文件读写

```python
with open('./test1.txt', 'w', encoding='utf-8')as f: # 打开方式'w'，并设置编码格式utf-8
    f.write('疑是地上霜') # 向文件里面写入'疑是地上霜'

with open('./test1.txt', 'r', encoding='utf-8') as f: # 打开方式'r'，并设置编码格式utf-8
    content1 = f.read()       
    print(content1)           # 疑是地上霜
    content2 = f.readline()   
    print(content2)           # 疑是地上霜
    content3 = f.readlines()  
    print(content3)           # ['疑是地上霜']
```

### 二进制文件读写

```python
with open('./img.jpg', 'rb') as f: # 打开方式'rb'，打开有图像的图片img.jpg，
    image_date = f.read()          # 读取图片的二进制数据
    print(image_date)              # b'\xff\xd8\xff\xe0\...（b开头的二进制流数据）

with open('./lew.jpg', 'wb') as f: # 打开方式'wb'，打开无图像的图片lew.jpg，
    f.write(image_date)	           # 将上面的图片img.jpg的二进制数据写入图片lew.jpg当中
```

### Json文件读写

**json文件：是一种存储 `json` 格式数据且后缀名为 `.json` 的文本文件。**

1. **`json` 有两种格式，对象格式：`{"key1":obj,"key2":obj...}`，数组/集合格式：`[obj,obj,obj...]`。**
2. 支持的数据类型：字符串、数字、布尔值、列表、字典。
3. **`json` 格式中的字符串全为双引号，没有单引号**。

`Python` 中有内置的 `json` 模块，专门处理 `json` 格式数据的，直接导入就可用。

```python
# 导入json模块
import json     
```

`json.loads()`：**将 `json` 格式解码成 `Python` 数据类型。**

```python
# 导入json模块
import json

encoded_json = ["iplaypython", [1, 2, 3], {"name": "xiaoming"}]
# 将 json 格式解码成 Python 数据类型
analys_json = json.loads(encoded_json)
print(analys_json, type(analys_json))
'''
输出：
['iplaypython', [1, 2, 3], {'name': 'xiaoming'}] <class 'list'>
# 注释：变量encoded_json里面的双引号全部变成了单引号。
'''
```

`json.dumps()`：**将 `Python` 数据类型编码为 `json` 格式。**

```python
# 导入json模块
import json                                          

# 创建一个l列表
l = ['iplaypython', [1, 2, 3], {'name': 'xiaoming'}]

# 将l列表，进行json格式化编码
encoded_json = json.dumps(l)                        
print(encoded_json, type(encoded_json))

# indent参数代表缩进级别，1就是缩进1个空格的距离，可以按照json样式可视化显示
encoded_json1 = json.dumps(l, indent=1)              
print(encoded_json1, type(encoded_json1))
'''
输出：
# 注释：将一个list列表对象，进行了json格式的编码，单引号变双引号。
["iplaypython", [1, 2, 3], {"name": "xiaoming"}] <class 'str'>
# 注释：按照json样式可视化显示
[
 "iplaypython",
 [
  1,
  2,
  3
 ],
 {
  "name": "xiaoming"
 }
]<class 'str'>
'''

# 这里还有一个参数ensure_ascii默认为True，默认将汉字转为Unicode编码，可以指定False不转码汉字
py_dict = {'国家':'中国', '省会':{'四川': '成都', '湖北':'武汉'}}
print(json.dumps(py_dict, indent=1))
print('-'*40)
print(json.dumps(py_dict, indent=1, ensure_ascii=False))
'''
输出：
{
 "\u56fd\u5bb6": "\u4e2d\u56fd",
 "\u7701\u4f1a": {
  "\u56db\u5ddd": "\u6210\u90fd",
  "\u6e56\u5317": "\u6b66\u6c49"
 }
}
----------------------------------------
{
 "国家": "中国",
 "省会": {
  "四川": "成都",
  "湖北": "武汉"
 }
}
'''
```

`json.load()`：**将文件中的 `json` 数据读取出来。**

```python
import json

with open('./tt.json','r') as f:
    print(json.load(f)) # [{"a": "aaa", "b": "bbb", "c": [1, 2, 3, [4, 5, 6]]}, 33, "tantengvip", true]
```

`json.dump(x,f)`： **将数据对象 `x` 写入文件对象 `f` 中。**

```python
import json

data = [{"a": "aaa", "b": [1, 2, (4, 5)]}, 33, 'tantengvip', True]
data2 = json.dumps(data)  # 将list类型数据转化为json类型数据

with open('./tt.json','a') as f: # 将新文件对象和操作类型赋值给f（a代表追加写入）
    json.dump(data2,f)           # 将data2的json类型数据写入到f中
'''
最终生成了一个tt.json文件，里面保存了json格式数据如下：
"[{\"a\": \"aaa\", \"b\": \"bbb\", \"c\": [1, 2, 3, [4, 5, 6]]}, 33, \"tantengvip\", true]"
'''
```

### Excel文件读写

**Microsoft Excel是Microsoft为使用Windows和Apple Macintosh操作系统的电脑编写的一款电子表格软件。**对于普通人来说，数据的读取和存储，除了使用数据库之外，最常见的就是微软的Excel。

Excel文件有 `xls` 和 `xlsx` 两种格式，它们之间的区别是：

**文件格式不同**：xls是一个特有的二进制格式，其核心结构是复合文档类型的结构，而xlsx的核心结构是XML类型的结构，采用的是基于 XML的压缩方式，使其占用的空间更小。

**版本不同**：xls是Excel2003及以前版本生成的文件格式，而xlsx是Excel2007及以后版本生成的文件格式。

**兼容性不同**：xlsx格式是向下兼容的，可兼容xls格式。

Python自带的模块中有针对xls格式的xlrd和xlwt模块，但这两个库仅仅是针对xls的操作，当我们要操作xlsx格式文件时，则需要使用到第三方库。例举以下操作库：

```
xlrd：一个从Excel文件读取数据和格式化信息的库，支持.xls以及.xlsx文件（备注：2.0.1版本不支持xlsx，重装1.2.0版本可以解决）
xlwt：一个用于将数据和格式化信息写入旧Excel文件的库（如.xls）。
xlutils：一个处理Excel文件的库，依赖于xlrd和xlwt，支持.xls文件，支持Excel操作。
xlwings：一个可以实现python中调用Excel的库，支持.xls读，支持.xlsx文件读写，支持Excel操作，支持VBA。
openpyxl：一个用于读取和编写xlsx/xlsm/xltx/xltm文件的库，支持.xlsx文件的读写，支持Excel操作。
xlsxwriter：一个用于创建.xlsx文件的库，支持.xlsx文件的写，支持VBA。
win32com：一个读写和处理Excel文件的库，存在于pywin32中，支持.xls、.xlsx文件的读写，支持.xlsx文件的写，Excel操作。
DataNitro：一个内嵌在Excel中的插件，使用时需依托软件本身，支持.xls，.xlsx文件的读写，支持Excel操作，支持VBA。
Pandas：通过对Excel文件的读写实现数据输入输出，支持.xls，.xlsx文件的读写。
```

![20180524145252753](image/20180524145252753.png)

```python
# 导入openpyxl库
from openpyxl import Workbook

# 生成一个工作薄对象
wb = Workbook()
# 活动工作薄
ws = wb.active
# 第一行标题栏
ws['A1'] = 'ID'
ws['B1'] = '公司名称'
ws['C1'] = '项目名称'
# 构造数据
A = ('1', '2', '3', '4')
B = ('甲公司', '乙公司', '丙公司')
C = ('道路建设', '房屋修建')
for i in (A, B, C):
    # 从第二行开始插入数据
    index = 2
    for item in i:
        if item in A:
            ws[f'A{index}'] = item
        elif item in B:
            ws[f'B{index}'] = item
        else:
            ws[f'C{index}'] = item
        index += 1
# 保存数据在当前路径的企业业绩.xlsx文件中
wb.save("企业业绩.xlsx")
```

![QQ截图20210620235054](image/QQ截图20210620235054.png)

```python
# 导入openpyxl库
from openpyxl import Workbook
# 生成一个工作薄对象
wb = Workbook()
# 抓取活动工作薄
ws = wb.active
# 定义默认的sheet工作薄名称为"资质转让"
ws.title = "资质转让"
# 新建工作薄名称为"资质求购"，在索引为0的位置
wb.create_sheet("资质求购", 0)
# 新建工作薄名称为"服务商"，在索引为1的位置
wb.create_sheet("服务商", 1)
# 保存数据在当前路径的企业业绩.xlsx文件中
wb.save("企业业绩.xlsx")
```

![QQ截图20210630161551](image/QQ截图20210630161551.png)

```python
# 导入openpyxl库
import openpyxl
# 使用load_workbook读取excel文件
wb = openpyxl.load_workbook('路径\excel文件.后缀名')
# 选定需要读取的工作薄
ws = wb['excel工作薄名']
# ws.max_row最大行，ws.max_column最大列
for row in range(1, ws.max_row + 1):
    # 读取每行第10列的单元格中的值
    print(ws.cell(row=row, column=10).value)
```

### CSV文件读写

**CSV（Comma Separated Values）全称逗号分隔值文件是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。**因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，使用文本编辑器或类似于Excel电子表格这类工具打开和编辑CSV文件时，你甚至感觉不到CSV和Excel文件的区别。**而且很多编程语言中都提供了对读写CSV文件的支持，很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，因此CSV格式在数据处理和数据科学中被广泛应用。**

CSV文件有以下特点：

1. 纯文本，使用某种字符集（如ASCII、Unicode、GB2312等）；
2. 由一条条的记录组成（典型的是每行一条记录）；
3. 每条记录被分隔符（如逗号、分号、制表符）分隔为字段（列）；
4. 每条记录都有同样的字段序列。

在Python标准库中就有对应处理CSV文件的 `csv` 模块，该，具体的代码如下所示。

```python
# 导入csv模块
import csv
import random

with open('scores.csv', 'w') as file:
    # writer函数返回一个csvwriter对象
    writer = csv.writer(file)
    # 通过对象的writerow或writerows方法就可以将数据写入到CSV文件中
    writer.writerow(['姓名', '语文', '数学', '英语'])
    names = ['关羽', '张飞', '赵云', '马超', '黄忠']
    for i in range(5):
        verbal = random.randint(50, 100)
        math = random.randint(40, 100)
        english = random.randint(30, 100)
        writer.writerow([names[i], verbal, math, english])
```

![QQ截图20211215003348](image/QQ截图20211215003348.png)



上面的 `writer` 函数除了传入要写入数据的文件对象外，还可以 `dialect` 参数，它表示CSV文件的方言，默认值是 `excel`。除此之外，还可以通过 `delimiter`、`quotechar`、`quoting` 参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。

```python
# 将上面第7行代码修改为下面的代码
writer = csv.writer(file, delimiter='|', quoting=csv.QUOTE_ALL)
```

![QQ截图20211215003804](image/QQ截图20211215003804.png)

如果要读取刚才创建的CSV文件，可以使用 `reader` 函数创建出 `csvreader` 对象，该对象是一个迭代器，可以通过 `next` 函数或 `for-in` 循环读取到文件中的数据：

```python
import csv

with open('scores.csv', 'r') as file:
    reader = csv.reader(file, delimiter='|')
    for line in reader:
        print(reader.line_num, end='\t')
        for elem in line:
            print(elem, end='\t')
        print()
'''
读取上面文件输出：
1	姓名	语文	数学	英语	
2	
3	关羽	77	93	56	
4	
5	张飞	75	41	98	
6	
7	赵云	59	63	71	
8	
9	马超	51	93	61	
10	
11	黄忠	91	55	30	
12	
'''
```

!> 注意上面的代码对 `csvreader` 对象做 `for` 循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。

### Word文件读写

**Word是微软公司开发的文字处理程序，日常办公中很多正式的文档都是用Word进行撰写和编辑的，目前使用的Word文件后缀名一般为 `.docx`。**通过下面的命令来安装`python-docx`三方库

```
pip install python-docx
```

我们可以使用如下所示的代码来生成一个简单的Word文档：

```python
from docx import Document
from docx.shared import Cm, Pt
from docx.document import Document as Doc

# 创建代表Word文档的Doc对象
document = Document()  # type: Doc
# 添加大标题
document.add_heading('快快乐乐学Python', 0)
# 添加段落
p = document.add_paragraph('Python是一门非常流行的编程语言，它')
run = p.add_run('简单')
run.bold = True
run.font.size = Pt(18)
p.add_run('而且')
run = p.add_run('优雅')
run.font.size = Pt(18)
run.underline = True
p.add_run('。')

# 添加一级标题
document.add_heading('Heading, level 1', level=1)
# 添加带样式的段落
document.add_paragraph('Intense quote', style='Intense Quote')
# 添加无序列表
document.add_paragraph(
    'first item in unordered list', style='List Bullet'
)
document.add_paragraph(
    'second item in ordered list', style='List Bullet'
)
# 添加有序列表
document.add_paragraph(
    'first item in ordered list', style='List Number'
)
document.add_paragraph(
    'second item in ordered list', style='List Number'
)

# 添加图片（注意路径和图片必须要存在）
document.add_picture('resources/guido.jpg', width=Cm(5.2))

# 添加分节符
document.add_section()

records = (
    ('骆昊', '男', '1995-5-5'),
    ('孙美丽', '女', '1992-2-2')
)
# 添加表格
table = document.add_table(rows=1, cols=3)
table.style = 'Dark List'
hdr_cells = table.rows[0].cells
hdr_cells[0].text = '姓名'
hdr_cells[1].text = '性别'
hdr_cells[2].text = '出生日期'
# 为表格添加行
for name, sex, birthday in records:
    row_cells = table.add_row().cells
    row_cells[0].text = name
    row_cells[1].text = sex
    row_cells[2].text = birthday

# 添加分页符
document.add_page_break()

# 保存文档
document.save('demo.docx')
```

?> 提示：上面代码第7行中的注释`# type: Doc`是为了在PyCharm中获得代码补全提示，因为如果不清楚对象具体的数据类型，PyCharm无法在后续代码中给出`Doc`对象的代码补全提示。

执行上面的代码，打开生成的Word文档，效果如下图所示:

![v2-467130b6dc7058d52ed3306effd15c32_720w](image/v2-467130b6dc7058d52ed3306effd15c32_720w.jpg)

![v2-b5b41eb46fcab491648a7117ede7eff8_720w](image/v2-b5b41eb46fcab491648a7117ede7eff8_720w.jpg)

对于一个已经存在的Word文件，我们可以通过下面的代码去遍历它所有的段落并获取对应的内容。

```python
from docx import Document
from docx.document import Document as Doc

doc = Document('resources/离职证明.docx')  # type: Doc
for no, p in enumerate(doc.paragraphs):
    print(no, p.text)
```

读取到的内容如下所示：

```
0 
1 离 职 证 明
2 
3 兹证明 王大锤 ，身份证号码： 100200199512120001 ，于 2018 年 8 月 7 日至 2020 年 6 月 28 日在我单位  开发部 部门担任 Java开发工程师 职务，在职期间无不良表现。因 个人 原因，于 2020 年 6 月 28 日起终止解除劳动合同。现已结清财务相关费用，办理完解除劳动关系相关手续，双方不存在任何劳动争议。
4 
5 特此证明！
6 
7 
8 公司名称（盖章）:成都风车车科技有限公司
9               2020 年 6 月 28 日
```

讲到这里，相信很多读者已经想到了，我们可以把上面的离职证明制作成一个模板文件，把姓名、身份证号、入职和离职日期等信息用占位符代替，这样通过对占位符的替换，就可以根据实际需要写入对应的信息，这样就可以批量的生成Word文档。

按照上面的思路，我们首先编辑一个离职证明的模板文件，如下图所示：

![v2-5bc42eac7751939991b4fc5ec689d3e2_720w](image/v2-5bc42eac7751939991b4fc5ec689d3e2_720w.jpg)

接下来我们读取该文件，将占位符替换为真实信息，就可以生成一个新的Word文档，如下所示。

```python
from docx import Document
from docx.document import Document as Doc

# 将真实信息用字典的方式保存在列表中
employees = [
    {
        'name': '骆昊',
        'id': '100200198011280001',
        'sdate': '2008年3月1日',
        'edate': '2012年2月29日',
        'department': '产品研发',
        'position': '架构师',
        'company': '成都华为技术有限公司'
    },
    {
        'name': '王大锤',
        'id': '510210199012125566',
        'sdate': '2019年1月1日',
        'edate': '2021年4月30日',
        'department': '产品研发',
        'position': 'Python开发工程师',
        'company': '成都谷道科技有限公司'
    },
    {
        'name': '李元芳',
        'id': '2102101995103221599',
        'sdate': '2020年5月10日',
        'edate': '2021年3月5日',
        'department': '产品研发',
        'position': 'Java开发工程师',
        'company': '同城企业管理集团有限公司'
    },
]
# 对列表进行循环遍历，批量生成Word文档 
for emp_dict in employees:
    # 读取离职证明模板文件
    doc = Document('resources/离职证明模板.docx')  # type: Doc
    # 循环遍历所有段落寻找占位符
    for p in doc.paragraphs:
        if '{' not in p.text:
            continue
        # 不能直接修改段落内容，否则会丢失样式
        # 所以需要对段落中的元素进行遍历并进行查找替换
        for run in p.runs:
            if '{' not in run.text:
                continue
            # 将占位符换成实际内容
            start, end = run.text.find('{'), run.text.find('}')
            key, place_holder = run.text[start + 1:end], run.text[start:end + 1]
            run.text = run.text.replace(place_holder, emp_dict[key])
    # 每个人对应保存一个Word文档
    doc.save(f'{emp_dict["name"]}离职证明.docx')
```

执行上面的代码，会在当前路径下生成三个Word文档，如下图所示：

![v2-0db4543bc6e5fca519b69e87ad03828d_720w](image/v2-0db4543bc6e5fca519b69e87ad03828d_720w.jpg)

### PPT文件读写

**PowerPoint是微软公司开发的演示文稿程序，是微软的Office系列软件中的一员，被商业人士、教师、学生等群体广泛使用，通常也将其称之为“幻灯片”。**在Python中可以使用名为 `python-pptx` 的三方库来生成PowerPoint，首先我们需要安装名为`python-pptx`的三方库，命令如下所示：

```
pip install python-pptx
```

用Python操作PowerPoint的内容，因为实际应用场景不算很多，我不打算在这里进行赘述，有兴趣的读者可以自行阅读`python-pptx`的[官方文档](https://link.zhihu.com/?target=https%3A//python-pptx.readthedocs.io/en/latest/)，下面仅展示一段来自于官方文档的代码：

```python
from pptx import Presentation

# 创建幻灯片对象
pres = Presentation()

# 选择母版添加一页
title_slide_layout = pres.slide_layouts[0]
slide = pres.slides.add_slide(title_slide_layout)
# 获取标题栏和副标题栏
title = slide.shapes.title
subtitle = slide.placeholders[1]
# 编辑标题和副标题
title.text = "Welcome to Python"
subtitle.text = "Life is short, I use Python"

# 选择母版添加一页
bullet_slide_layout = pres.slide_layouts[1]
slide = pres.slides.add_slide(bullet_slide_layout)
# 获取页面上所有形状
shapes = slide.shapes
# 获取标题和主体
title_shape = shapes.title
body_shape = shapes.placeholders[1]
# 编辑标题
title_shape.text = 'Introduction'
# 编辑主体内容
tf = body_shape.text_frame
tf.text = 'History of Python'
# 添加一个一级段落
p = tf.add_paragraph()
p.text = 'X\'max 1989'
p.level = 1
# 添加一个二级段落
p = tf.add_paragraph()
p.text = 'Guido began to write interpreter for Python.'
p.level = 2

# 保存幻灯片
pres.save('test.pptx')
```

运行上面的代码，生成的PowerPoint文件如下图所示：

![v2-1d8bd0984051f13875d246f93f43a425_720w](image/v2-1d8bd0984051f13875d246f93f43a425_720w.jpg)

### PDF文件读写

**PDF是Portable Document Format的缩写，这类文件通常使用`.pdf`作为其扩展名。**在Python中，可以使用名为 `PyPDF2` 的三方库来读取PDF文件，可以使用下面的命令来安装它。

```bash
pip install PyPDF2
```

`PyPDF2` 没有办法从PDF文档中提取图像、图表或其他媒体，但它可以提取文本，并将其返回为Python字符串。

```python
import PyPDF2

reader = PyPDF2.PdfFileReader('test.pdf')
page = reader.getPage(0)
print(page.extractText())
```

当然，`PyPDF2`并不是什么样的PDF文档都能提取出文字来，这个问题就我所知并没有什么特别好的解决方法，尤其是在提取中文的时候。网上也有很多讲解从PDF中提取文字的文章，推荐大家自行阅读[《三大神器助力Python提取pdf文档信息》](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1395339)一文进行了解。

要从PDF文件中提取文本也可以直接使用三方的命令行工具，具体的做法如下所示。

```bash
pip install pdfminer.six
pdf2text.py test.pdf
```

上面的代码中通过创建 `PdfFileReader` 对象的方式来读取PDF文档，该对象的`getPage`方法可以获得PDF文档的指定页并得到一个 `PageObject` 对象，通过 `PageObject` 对象的 `rotateClockwise` 和 `rotateCounterClockwise` 方法可以实现页面的顺时针和逆时针方向旋转，通过 `PageObject` 对象的 `addBlankPage` 方法可以添加一个新的空白页，代码如下所示：

```python
import PyPDF2
from PyPDF2.pdf import PageObject

# 创建一个读PDF文件的Reader对象
reader = PyPDF2.PdfFileReader('resources/XGBoost.pdf')
# 创建一个写PDF文件的Writer对象
writer = PyPDF2.PdfFileWriter()
# 对PDF文件所有页进行循环遍历
for page_num in range(reader.numPages):
    # 获取指定页码的Page对象
    current_page = reader.getPage(page_num)  # type: PageObject
    if page_num % 2 == 0:
        # 奇数页顺时针旋转90度
        current_page.rotateClockwise(90)
    else:
        # 偶数页反时针旋转90度
        current_page.rotateCounterClockwise(90)
    writer.addPage(current_page)
# 最后添加一个空白页并旋转90度
page = writer.addBlankPage()  # type: PageObject
page.rotateClockwise(90)
# 通过Writer对象的write方法将PDF写入文件
with open('resources/XGBoost-modified.pdf', 'wb') as file:
    writer.write(file)
```

使用 `PyPDF2` 中的 `PdfFileWrite` 对象可以为PDF文档加密，如果需要给一系列的PDF文档设置统一的访问口令，使用Python程序来处理就会非常的方便。

```python
import PyPDF2

reader = PyPDF2.PdfFileReader('resources/XGBoost.pdf')
writer = PyPDF2.PdfFileWriter()
for page_num in range(reader.numPages):
    writer.addPage(reader.getPage(page_num))
# 通过encrypt方法加密PDF文件，方法的参数就是设置的密码
writer.encrypt('foobared')
with open('resources/XGBoost-encrypted.pdf', 'wb') as file:
    writer.write(file)
```

上面提到的 `PageObject` 对象还有一个名为 `mergePage` 的方法，可以两个PDF页面进行叠加，通过这个操作，我们很容易实现给PDF文件添加水印的功能。例如要给上面的“XGBoost.pdf”文件添加一个水印，我们可以先准备好一个提供水印页面的PDF文件，然后将包含水印的 `PageObject` 读取出来，然后再循环遍历“XGBoost.pdf”文件的每个页，获取到 `PageObject` 对象，然后通过 `mergePage` 方法实现水印页和原始页的合并，代码如下所示。

```python
import PyPDF2

from PyPDF2.pdf import PageObject

reader1 = PyPDF2.PdfFileReader('resources/XGBoost.pdf')
reader2 = PyPDF2.PdfFileReader('resources/watermark.pdf')
writer = PyPDF2.PdfFileWriter()
# 获取水印页
watermark_page = reader2.getPage(0)
for page_num in range(reader1.numPages):
    current_page = reader1.getPage(page_num)  # type: PageObject
    current_page.mergePage(watermark_page)
    # 将原始页和水印页进行合并
    writer.addPage(current_page)
# 将PDF写入文件
with open('resources/XGBoost-watermarked.pdf', 'wb') as file:
    writer.write(file)
```

如果愿意，还可以让奇数页和偶数页使用不同的水印，大家可以自己思考下应该怎么做。

创建PDF文档需要三方库 `reportlab` 的支持，安装的方法如下所示。

```bash
pip install reportlab
```

下面通过一个例子为大家展示`reportlab`的用法。

```python
from reportlab.lib.pagesizes import A4
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen import canvas

pdf_canvas = canvas.Canvas('resources/demo.pdf', pagesize=A4)
width, height = A4

# 绘图
image = canvas.ImageReader('resources/guido.jpg')
pdf_canvas.drawImage(image, 20, height - 395, 250, 375)

# 显示当前页
pdf_canvas.showPage()

# 注册字体文件
pdfmetrics.registerFont(TTFont('Font1', 'resources/fonts/Vera.ttf'))
pdfmetrics.registerFont(TTFont('Font2', 'resources/fonts/青呱石头体.ttf'))

# 写字
pdf_canvas.setFont('Font2', 40)
pdf_canvas.setFillColorRGB(0.9, 0.5, 0.3, 1)
pdf_canvas.drawString(width // 2 - 120, height // 2, '你好，世界！')
pdf_canvas.setFont('Font1', 40)
pdf_canvas.setFillColorRGB(0, 1, 0, 0.5)
pdf_canvas.rotate(18)
pdf_canvas.drawString(250, 250, 'hello, world!')

# 保存
pdf_canvas.save()
```

上面的代码如果不太理解也没有关系，等真正需要用Python创建PDF文档的时候，再好好研读一下 `reportlab` 的[官方文档](https://link.zhihu.com/?target=https%3A//www.reportlab.com/docs/reportlab-userguide.pdf)就可以了。

### BOM影响

之前**文本文档的编码**中由提到过，UTF-8编码有两种：UTF-8、带BOM的UTF-8，下面来看看BOM在Python程序中读取的影响：

```python
# 读取编码为UTF-8的文件
with open("Task.txt", "r",encoding='utf-8')as f:
    nr = f.read()
    print(nr, f'字符长度：{len(nr)}')              # 新华社 字符长度：3

with open("Task.txt", "r", encoding='utf-8')as f:
    nr = f.readlines()
    print(nr)                                    # ['新华社']
    print(nr[0], f'字符长度：{len(nr[0])}')        # 新华社 字符长度：3
    print(nr[0].encode())                        # b'\xe6\x96\xb0\xe5\x8d\x8e\xe7\xa4\xbe'
    
# 读取编码为带BOM的UTF-8的文件
with open("Task.txt", "r",encoding='utf-8')as f:
    nr = f.read()
    print(nr, f'字符长度：{len(nr)}')              # ﻿新华社 字符长度：4

with open("Task.txt", "r", encoding='utf-8')as f:
    nr = f.readlines()
    print(nr)                                    # ['\ufeff新华社']
    print(nr[0], f'字符长度：{len(nr[0])}')        # ﻿新华社 字符长度：4
    print(nr[0].encode())                        # b'\xef\xbb\xbf\xe6\x96\xb0\xe5\x8d\x8e\xe7\xa4\xbe'

# 注释：可以看到带BOM的UTF-8比UTF-8多了一个﻿，在列表中内容为\ufeff，编码中内容为\xef\xbb\xbf，当中ef bb bf就恰好对应了带BOM的UTF-8开头的字节流EF BB BF。
```

去掉BOM有两种方法：

1. 打开文本文件，将其另存为**不带有BOM的UTF-8**。（最好是在专业版Windows系统中能显示有两个UTF-8编码选项下操作）
2. 将字符进行 `utf-8` 编码，再以 `utf-8-sig` 解码。

```python
# 读取编码为带BOM的UTF-8的文件
with open("Task.txt", "r",encoding='utf-8')as f:
    nr = f.readlines()
    nr = nr[0]
    print(nr, f'字符长度：{len(nr)}')              # ﻿新华社 字符长度：4

with open("Task.txt", "r", encoding='utf-8')as f:
    nr = f.readlines()
    nr = nr[0].encode().decode('utf-8-sig')      
    print(nr, f'字符长度：{len(nr)}')              # 新华社 字符长度：3
```

### 大文件读写

如果要复制的图片文件很大，一次将文件内容直接读入内存中可能会造成非常大的内存开销，为了减少对内存的占用，可以为 `read` 方法传入 `size` 参数来指定每次读取的字节数，通过循环读取和写入的方式来完成上面的操作：

```python
try:
    with open('guido.jpg', 'rb') as file1, open('吉多.jpg', 'wb') as file2:
        data = file1.read(512)
        while data:
            file2.write(data)
            data = file1.read()
except FileNotFoundError:
    print('指定的文件无法打开.')
except IOError:
    print('读写文件时出现错误.')
print('程序执行结束.')
```

## 文件(夹)操作

### 复制|移动|删除

`shutil` 是Python的一个高级的文件，文件夹，压缩包处理模块，拥有许多文件（夹）操作的功能，包括复制、移动、重命名、删除等等。

```python
# 使用前，需导入该模块
import shutil

# copyfile直接通过文件名，将1.txt内容以覆盖形式拷贝到2.txt中
shutil.copyfile("1.txt", "2.txt")
# copymode仅拷贝1.txt权限给2.txt，但内容、组、用户均不变
shutil.copymode("1.txt", "2.txt")
# copystat拷贝1.txt状态的信息给2.txt，包括：mode、bits、atime、mtime、flags
shutil.copystat("1.txt", "2.txt")

# 以“r读方式”打开文件1.txt，以“w写方式”打开文件2.txt
with open("1.txt",'r',encoding="utf-8") as f1, open("2.txt","w",encoding="utf-8") as f2:
    # copyfileobj通过打开的文件对象，将1.txt内容以覆盖形式拷贝到2.txt中
    shutil.copyfileobj(f1, f2)

# copy（文件及路径，目标路径）：复制文件（目标文件要是不存在会自动创建）
# 当前目录下的文件，拷贝到目标路径下
shutil.copy('文件名.后缀名', '目标路径')
# 非当前目录下的文件，拷贝到目标路径下
shutil.copy('路径\文件名.后缀名', '目标路径')

# copy2（文件及路径，目标路径）：复制文件，保留原有文件的信息（操作时间和权限等）
# 当前目录下的文件，拷贝到目标路径下
shutil.copy2('文件名.后缀名', '目标路径')
# 非当前目录下的文件，拷贝到目标路径下
shutil.copy2('路径\文件名.后缀名', '目标路径')

# copytree（来源路径，目标路径）：拷贝整个文件夹
shutil.copytree('来源路径', '目标路径')

# move：递归移动文件或者文件夹（慎用）
# 当前目录下的文件，移动到目标路径下
shutil.move('文件名.后缀名', '目标路径')
# 非当前目录下的文件，移动到目标路径下
shutil.move('路径\文件名.后缀名', '目标路径')
# 将文件夹移动到目标路径下
shutil.move('路径\文件夹', '目标路径')

# rmtree：递归删除文件或者文件夹，它不是原子操作（如同rm -rf一样危险，慎用）
# 删除当前目录下的文件
shutil.rmtree('文件名.后缀名')
# 删除非当前目录下的文件
shutil.rmtree('路径\文件名.后缀名')
# 删除文件夹
shutil.rmtree('路径\文件夹')

# disk_usage（盘符）：查看磁盘使用量（参数如果是路径，那么结果仍然是路径所在盘符的使用量）
print(shutil.disk_usage('C:')) # usage(total=120031539200, used=78561628160, free=41469911040)
```

### 压缩|解压

`shutil` 模块也可以进行各种格式的压缩操作。

```python
# make_archive方法创建压缩包并返回文件路径
'''
参数详解：
base_name：文件名时，则保存至当前目录；路径时，则保存至指定路径
如：data_bak=>保存至当前路径
如：/tmp/data_bak=>保存至/tmp/
format：压缩包种类，“zip”, “tar”, “bztar”，“gztar”
root_dir：要压缩的文件夹路径（默认当前目录）
owner：用户，默认当前用户
group：组，默认当前组
logger：用于记录日志，通常是logging.Logger对象
'''
# 将/data下的文件打包放置/tmp/目录
shutil.make_archive("/tmp/data_bak", 'gztar', root_dir='/data')
```

**zipfile压缩解压**：压缩和解压文件的格式都是 `.zip` 的压缩包。

```python
import zipfile

# 压缩
z = zipfile.ZipFile('dream.zip', 'w')
z.write('test.log') #将test.log压缩为dream.zip文件
z.close()

# 解压
z = zipfile.ZipFile('dream.zip', 'r')
z.extractall(path='解压路径') #将dream.zip文件解压出来，文件名以压缩包中的为准。
z.close()
```

**tarfile压缩解压**：压缩和解压文件的格式都是 `.rar` 的压缩包。

```python
import tarfile

# 压缩
tar = tarfile.open('dream.tar','w')
#将压缩包再压缩，在dream.tar中进行压缩，将dream1.zip添加进去并取别名bbs2.zip
tar.add('E:/PycharmProjects/PythonStudy/test/dream1.zip', arcname='bbs2.zip')
#将压缩包再压缩，在dream.tar中进行压缩，将dream2.zip添加进去并取别名cmdb.zip
tar.add('E:/PycharmProjects/PythonStudy/test/dream2.zip', arcname='cmdb.zip')
tar.close()

# 解压
tar = tarfile.open('dream.tar','r')
# 解压dream.tar，分别解压出两个文件bbs2.zip、cmdb.zip
tar.extractall()  # 可设置解压地址
tar.close()
```

