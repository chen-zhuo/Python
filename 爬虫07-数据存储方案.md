# 数据存储方案

在爬虫程序运行的过程当中会产生许多的数据，有些数据是我们希望永久化存储的，**然而这些数据都是存储在内存当中的，内存有个特点就是只能保存即时数据，断电后数据消失，也就是说，电脑一关机内存里面的数据就没有了，因此内存不能用作数据的持久化存储。**这时学习数据持久化存储的方法就显得特别重要了。

数据持久化存储的方式总体上就分为两大类：

1. **文件存储：最常见的数据持久化存储方式。**

2. **数据库存储：最适用的数据持久化存储方式。**

## 文件存储

平常操作计算机的时候，我们会接触到各种格式的文件，**例如文本文件、json文件、图片文件、视频文件、文本文件、音频文件、Word文件、Excel文件、PPT文件等等，其实它们都是数据的载体，都可以用来持久化存储数据，这是因为文件都是存储在硬盘当中的，计算机关机断电不会对硬盘造成影响，这些文件依然存储在硬盘当中。因此说，文件存储是最常见的数据存储方式。**这里介绍我们日常生活中常用的文件读写方法和脚本程序，例如文本、Excel、Word、PPT等文件：

### 文本文件读写

用文件来存储数据，肯定不了对文件的读写操作。例如，前面我们学习了二进制文件读写、文本文件读写：

```python
# 文本文件读写
with open('./test1.txt', 'w', encoding='utf-8')as f: # 打开方式'w'，并设置编码格式utf-8
    f.write('疑是地上霜') # 向文件里面写入'疑是地上霜'

with open('./test1.txt', 'r', encoding='utf-8') as f: # 打开方式'r'，并设置编码格式utf-8
    content1 = f.read()       
    print(content1)           # 疑是地上霜
    content2 = f.readline()   
    print(content2)           # 疑是地上霜
    content3 = f.readlines()  
    print(content3)           # ['疑是地上霜']

# 二进制文件读写
with open('./img.jpg', 'rb') as f: # 打开方式'rb'，打开有图像的图片img.jpg，
    image_date = f.read()          # 读取图片的二进制数据
    print(image_date)              # b'\xff\xd8\xff\xe0\...（b开头的二进制流数据）

with open('./lew.jpg', 'wb') as f: # 打开方式'wb'，打开无图像的图片lew.jpg，
    f.write(image_date)	           # 将上面的图片img.jpg的二进制数据写入图片lew.jpg当中
```

### Json文件读写

**json文件：是一种存储 `json` 格式数据且后缀名为 `.json` 的文本文件。**

在网络响应中，有种最常见的数据格式就是Json数据格式：

1. **`json` 有两种格式，对象格式：`{"key1":obj,"key2":obj...}`，数组/集合格式：`[obj,obj,obj...]`。**
2. 支持的数据类型：字符串、数字、布尔值、列表、字典。
3. **`json` 格式中的字符串全为双引号，没有单引号**。

`Python` 中有内置的 `json` 模块，专门处理 `json` 格式数据的，直接导入就可用。

```python
# 导入json模块
import json
```

`json.loads()`：**将 `json` 格式解码成 `Python` 数据类型。**

```python
# 导入json模块
import json

encoded_json = ["iplaypython", [1, 2, 3], {"name": "xiaoming"}]
# 将 json 格式解码成 Python 数据类型
analys_json = json.loads(encoded_json)
print(analys_json, type(analys_json))
'''
输出：
['iplaypython', [1, 2, 3], {'name': 'xiaoming'}] <class 'list'>
# 注释：变量encoded_json里面的双引号全部变成了单引号。
'''
```

`json.dumps()`：**将 `Python` 数据类型编码为 `json` 格式。**

```python
# 导入json模块
import json                                          

# 创建一个l列表
l = ['iplaypython', [1, 2, 3], {'name': 'xiaoming'}]

# 将l列表，进行json格式化编码
encoded_json = json.dumps(l)                        
print(encoded_json, type(encoded_json))

# indent参数代表缩进级别，1就是缩进1个空格的距离，按照json样式可视化显示
encoded_json1 = json.dumps(l, indent=1)              
print(encoded_json1, type(encoded_json1))
'''
输出：
# 注释：将一个list列表对象，进行了json格式的编码，单引号变双引号。
["iplaypython", [1, 2, 3], {"name": "xiaoming"}] <class 'str'>
# 注释：按照json样式可视化显示
[
 "iplaypython",
 [
  1,
  2,
  3
 ],
 {
  "name": "xiaoming"
 }
]<class 'str'>
'''

# 这里还有一个参数ensure_ascii默认为True，默认将汉字转为Unicode编码，可以指定False不转码汉字
py_dict = {'国家':'中国', '省会':{'四川': '成都', '湖北':'武汉'}}
print(json.dumps(py_dict, indent=1))
print('-'*40)
print(json.dumps(py_dict, indent=1, ensure_ascii=False))
'''
输出：
{
 "\u56fd\u5bb6": "\u4e2d\u56fd",
 "\u7701\u4f1a": {
  "\u56db\u5ddd": "\u6210\u90fd",
  "\u6e56\u5317": "\u6b66\u6c49"
 }
}
----------------------------------------
{
 "国家": "中国",
 "省会": {
  "四川": "成都",
  "湖北": "武汉"
 }
}
'''
```

`json.load()`：**将文件中的 `json` 数据读取出来。**

```python
import json

with open('./tt.json','r') as f:
    print(json.load(f))  # [{"a": "aaa", "b": "bbb", "c": [1, 2, 3, [4, 5, 6]]}, 33, "tantengvip", true]
```

`json.dump(x,f)`： **将数据对象 `x` 写入文件对象 `f` 中。**

```python
import json

data = [{"a": "aaa", "b": [1, 2, (4, 5)]}, 33, 'tantengvip', True]
data2 = json.dumps(data)  # 将list类型数据转化为json类型数据

with open('./tt.json','a') as f: # 将新文件对象和操作类型赋值给f（a代表追加写入）
    json.dump(data2,f)           # 将data2的json类型数据写入到f中
'''
最终生成了一个tt.json文件，里面保存了json格式数据如下：
"[{\"a\": \"aaa\", \"b\": \"bbb\", \"c\": [1, 2, 3, [4, 5, 6]]}, 33, \"tantengvip\", true]"
'''
```

### Excel文件读写

**Microsoft Excel是Microsoft为使用Windows和Apple Macintosh操作系统的电脑编写的一款电子表格软件。**对于普通人来说，数据的读取和存储，除了使用数据库之外，最常见的就是微软的Excel。

Excel文件有 `xls` 和 `xlsx` 两种格式，它们之间的区别是：

**文件格式不同**：xls是一个特有的二进制格式，其核心结构是复合文档类型的结构，而xlsx的核心结构是XML类型的结构，采用的是基于 XML的压缩方式，使其占用的空间更小。

**版本不同**：xls是Excel2003及以前版本生成的文件格式，而xlsx是Excel2007及以后版本生成的文件格式。

**兼容性不同**：xlsx格式是向下兼容的，可兼容xls格式。

Python自带的模块中有针对xls格式的xlrd和xlwt模块，但这两个库仅仅是针对xls的操作，当我们要操作xlsx格式文件时，则需要使用到第三方库。例举以下操作库：

```
xlrd：一个从Excel文件读取数据和格式化信息的库，支持.xls以及.xlsx文件（备注：2.0.1版本不支持xlsx，重装1.2.0版本可以解决）
xlwt：一个用于将数据和格式化信息写入旧Excel文件的库（如.xls）。
xlutils：一个处理Excel文件的库，依赖于xlrd和xlwt，支持.xls文件，支持Excel操作。
xlwings：一个可以实现python中调用Excel的库，支持.xls读，支持.xlsx文件读写，支持Excel操作，支持VBA。
openpyxl：一个用于读取和编写xlsx/xlsm/xltx/xltm文件的库，支持.xlsx文件的读写，支持Excel操作。
xlsxwriter：一个用于创建.xlsx文件的库，支持.xlsx文件的写，支持VBA。
win32com：一个读写和处理Excel文件的库，存在于pywin32中，支持.xls、.xlsx文件的读写，支持.xlsx文件的写，Excel操作。
DataNitro：一个内嵌在Excel中的插件，使用时需依托软件本身，支持.xls，.xlsx文件的读写，支持Excel操作，支持VBA。
Pandas：通过对Excel文件的读写实现数据输入输出，支持.xls，.xlsx文件的读写。
```

![20180524145252753](image/20180524145252753.png)

```python
'''
新建不同的工作薄
'''
# 导入openpyxl库
from openpyxl import Workbook
# 生成一个工作薄对象
wb = Workbook()
# 抓取活动工作薄
ws = wb.active
# 定义默认的sheet工作薄名称为"资质转让"
ws.title = "资质转让"
# 新建工作薄名称为"资质求购"，在索引为0的位置
wb.create_sheet("资质求购", 0)
# 新建工作薄名称为"服务商"，在索引为1的位置
wb.create_sheet("服务商", 1)
# 切换到最后一个工作薄
ws = wb[wb.sheetnames[-1]]
# 保存数据在当前路径的企业业绩.xlsx文件中
wb.save("企业业绩.xlsx")
```

![QQ截图20210630161551](image/QQ截图20210630161551.png)

```python
'''
新建工作薄写入数据
'''
# 导入openpyxl库
from openpyxl import Workbook

# 生成一个工作薄对象
wb = Workbook()
# 活动工作薄
ws = wb.active
# 第一行标题栏
ws['A1'] = 'ID'
ws['B1'] = '公司名称'
ws['C1'] = '项目名称'
# 构造数据
A = ('1', '2', '3', '4')
B = ('甲公司', '乙公司', '丙公司')
C = ('道路建设', '房屋修建')
for i in (A, B, C):
    # 从第二行开始插入数据
    index = 2
    for item in i:
        if item in A:
            ws[f'A{index}'] = item
        elif item in B:
            ws[f'B{index}'] = item
        else:
            ws[f'C{index}'] = item
        index += 1
# 保存数据在当前路径的企业业绩.xlsx文件中
wb.save("企业业绩.xlsx")
```

![QQ截图20210620235054](image/QQ截图20210620235054.png)

```python
'''
只读取工作簿当中的数据
'''
# 导入openpyxl库
import openpyxl
# 使用load_workbook读取excel文件
wb = openpyxl.load_workbook('路径\excel文件.后缀名')
# 选定需要读取的工作薄
ws = wb['excel工作薄名']
# ws.max_row最大行，ws.max_column最大列
for row in range(1, ws.max_row + 1):
    # 读取每行第3列的单元格中的值
    print(ws.cell(row=row, column=3).value)
'''
输出：项目名称、道路建设、房屋维修、空、空
注释：因为最大行是5，因此最后输出了两‘空’
'''
```

![QQ截图20220214164552](image/QQ截图20220214164552.png)

```python
'''
修改表格中的数据另存为新excel文件
'''
# 导入openpyxl库
import openpyxl
# 使用load_workbook读取excel文件
wb = openpyxl.Write_excel('路径\excel文件.后缀名')
# 选定工作薄
ws = wb['excel工作薄名']
# 将第4行2列的值修改为‘丁公司’
ws.cell(row=4, column=2).value = '丁公司'
# 另存为一个新的excel文件
wb.save('路径\新excel文件.后缀名')
```

![QQ截图20220214170932](image/QQ截图20220214170932.png)

?> 提示：修改excel这样写也是可以的，`ws.cell(row=1, column=1).value = ws.cell(row=1, column=1).value`，前面代表新的excel文件内容，后面代表旧的excel文件，简单说就是新文件和旧文件的第一行第一列内容一样。

### CSV文件读写

**CSV（Comma Separated Values）全称逗号分隔值文件是一种简单、通用的文件格式，被广泛的应用于应用程序（数据库、电子表格等）数据的导入和导出以及异构系统之间的数据交换。**因为CSV是纯文本文件，不管是什么操作系统和编程语言都是可以处理纯文本的，使用文本编辑器或类似于Excel电子表格这类工具打开和编辑CSV文件时，你甚至感觉不到CSV和Excel文件的区别。**而且很多编程语言中都提供了对读写CSV文件的支持，很多数据库系统都支持将数据导出到CSV文件中，当然也支持从CSV文件中读入数据保存到数据库中，因此CSV格式在数据处理和数据科学中被广泛应用。**

CSV文件有以下特点：

1. 纯文本，使用某种字符集（如ASCII、Unicode、GB2312等）；
2. 由一条条的记录组成（典型的是每行一条记录）；
3. 每条记录被分隔符（如逗号、分号、制表符）分隔为字段（列）；
4. 每条记录都有同样的字段序列。

在Python标准库中就有对应处理CSV文件的 `csv` 模块，该，具体的代码如下所示。

```python
# 导入csv模块
import csv
import random

with open('scores.csv', 'w') as file:
    # writer函数返回一个csvwriter对象
    writer = csv.writer(file)
    # 通过对象的writerow或writerows方法就可以将数据写入到CSV文件中
    writer.writerow(['姓名', '语文', '数学', '英语'])
    names = ['关羽', '张飞', '赵云', '马超', '黄忠']
    for i in range(5):
        verbal = random.randint(50, 100)
        math = random.randint(40, 100)
        english = random.randint(30, 100)
        writer.writerow([names[i], verbal, math, english])
```

![QQ截图20211215003348](image/QQ截图20211215003348.png)



上面的 `writer` 函数除了传入要写入数据的文件对象外，还可以 `dialect` 参数，它表示CSV文件的方言，默认值是 `excel`。除此之外，还可以通过 `delimiter`、`quotechar`、`quoting` 参数来指定分隔符（默认是逗号）、包围值的字符（默认是双引号）以及包围的方式。其中，包围值的字符主要用于当字段中有特殊符号时，通过添加包围值的字符可以避免二义性。

```python
# 将上面第7行代码修改为下面的代码
writer = csv.writer(file, delimiter='|', quoting=csv.QUOTE_ALL)
```

![QQ截图20211215003804](image/QQ截图20211215003804.png)

如果要读取刚才创建的CSV文件，可以使用 `reader` 函数创建出 `csvreader` 对象，该对象是一个迭代器，可以通过 `next` 函数或 `for-in` 循环读取到文件中的数据：

```python
import csv

with open('scores.csv', 'r') as file:
    reader = csv.reader(file, delimiter='|')
    for line in reader:
        print(reader.line_num, end='\t')
        for elem in line:
            print(elem, end='\t')
        print()
'''
读取上面文件输出：
1	姓名	语文	数学	英语	
2	
3	关羽	77	93	56	
4	
5	张飞	75	41	98	
6	
7	赵云	59	63	71	
8	
9	马超	51	93	61	
10	
11	黄忠	91	55	30	
12	
'''
```

!> 注意上面的代码对 `csvreader` 对象做 `for` 循环时，每次会取出一个列表对象，该列表对象包含了一行中所有的字段。

### Word文件读写

**Word是微软公司开发的文字处理程序，日常办公中很多正式的文档都是用Word进行撰写和编辑的，目前使用的Word文件后缀名一般为 `.docx`。**通过下面的命令来安装`python-docx`三方库

```
pip install python-docx
```

我们可以使用如下所示的代码来生成一个简单的Word文档：

```python
from docx import Document
from docx.shared import Cm, Pt
from docx.document import Document as Doc

# 创建代表Word文档的Doc对象
document = Document()  # type: Doc
# 添加大标题
document.add_heading('快快乐乐学Python', 0)
# 添加段落
p = document.add_paragraph('Python是一门非常流行的编程语言，它')
run = p.add_run('简单')
run.bold = True
run.font.size = Pt(18)
p.add_run('而且')
run = p.add_run('优雅')
run.font.size = Pt(18)
run.underline = True
p.add_run('。')

# 添加一级标题
document.add_heading('Heading, level 1', level=1)
# 添加带样式的段落
document.add_paragraph('Intense quote', style='Intense Quote')
# 添加无序列表
document.add_paragraph(
    'first item in unordered list', style='List Bullet'
)
document.add_paragraph(
    'second item in ordered list', style='List Bullet'
)
# 添加有序列表
document.add_paragraph(
    'first item in ordered list', style='List Number'
)
document.add_paragraph(
    'second item in ordered list', style='List Number'
)

# 添加图片（注意路径和图片必须要存在）
document.add_picture('resources/guido.jpg', width=Cm(5.2))

# 添加分节符
document.add_section()

records = (
    ('骆昊', '男', '1995-5-5'),
    ('孙美丽', '女', '1992-2-2')
)
# 添加表格
table = document.add_table(rows=1, cols=3)
table.style = 'Dark List'
hdr_cells = table.rows[0].cells
hdr_cells[0].text = '姓名'
hdr_cells[1].text = '性别'
hdr_cells[2].text = '出生日期'
# 为表格添加行
for name, sex, birthday in records:
    row_cells = table.add_row().cells
    row_cells[0].text = name
    row_cells[1].text = sex
    row_cells[2].text = birthday

# 添加分页符
document.add_page_break()

# 保存文档
document.save('demo.docx')
```

?> 提示：上面代码第7行中的注释`# type: Doc`是为了在PyCharm中获得代码补全提示，因为如果不清楚对象具体的数据类型，PyCharm无法在后续代码中给出`Doc`对象的代码补全提示。

执行上面的代码，打开生成的Word文档，效果如下图所示:

![v2-467130b6dc7058d52ed3306effd15c32_720w](image/v2-467130b6dc7058d52ed3306effd15c32_720w.jpg)

![v2-b5b41eb46fcab491648a7117ede7eff8_720w](image/v2-b5b41eb46fcab491648a7117ede7eff8_720w.jpg)

对于一个已经存在的Word文件，我们可以通过下面的代码去遍历它所有的段落并获取对应的内容。

```python
from docx import Document
from docx.document import Document as Doc

doc = Document('resources/离职证明.docx')  # type: Doc
for no, p in enumerate(doc.paragraphs):
    print(no, p.text)
```

读取到的内容如下所示：

```
0 
1 离 职 证 明
2 
3 兹证明 王大锤 ，身份证号码： 100200199512120001 ，于 2018 年 8 月 7 日至 2020 年 6 月 28 日在我单位  开发部 部门担任 Java开发工程师 职务，在职期间无不良表现。因 个人 原因，于 2020 年 6 月 28 日起终止解除劳动合同。现已结清财务相关费用，办理完解除劳动关系相关手续，双方不存在任何劳动争议。
4 
5 特此证明！
6 
7 
8 公司名称（盖章）:成都风车车科技有限公司
9               2020 年 6 月 28 日
```

讲到这里，相信很多读者已经想到了，我们可以把上面的离职证明制作成一个模板文件，把姓名、身份证号、入职和离职日期等信息用占位符代替，这样通过对占位符的替换，就可以根据实际需要写入对应的信息，这样就可以批量的生成Word文档。

按照上面的思路，我们首先编辑一个离职证明的模板文件，如下图所示：

![v2-5bc42eac7751939991b4fc5ec689d3e2_720w](image/v2-5bc42eac7751939991b4fc5ec689d3e2_720w.jpg)

接下来我们读取该文件，将占位符替换为真实信息，就可以生成一个新的Word文档，如下所示。

```python
from docx import Document
from docx.document import Document as Doc

# 将真实信息用字典的方式保存在列表中
employees = [
    {
        'name': '骆昊',
        'id': '100200198011280001',
        'sdate': '2008年3月1日',
        'edate': '2012年2月29日',
        'department': '产品研发',
        'position': '架构师',
        'company': '成都华为技术有限公司'
    },
    {
        'name': '王大锤',
        'id': '510210199012125566',
        'sdate': '2019年1月1日',
        'edate': '2021年4月30日',
        'department': '产品研发',
        'position': 'Python开发工程师',
        'company': '成都谷道科技有限公司'
    },
    {
        'name': '李元芳',
        'id': '2102101995103221599',
        'sdate': '2020年5月10日',
        'edate': '2021年3月5日',
        'department': '产品研发',
        'position': 'Java开发工程师',
        'company': '同城企业管理集团有限公司'
    },
]
# 对列表进行循环遍历，批量生成Word文档 
for emp_dict in employees:
    # 读取离职证明模板文件
    doc = Document('resources/离职证明模板.docx')  # type: Doc
    # 循环遍历所有段落寻找占位符
    for p in doc.paragraphs:
        if '{' not in p.text:
            continue
        # 不能直接修改段落内容，否则会丢失样式
        # 所以需要对段落中的元素进行遍历并进行查找替换
        for run in p.runs:
            if '{' not in run.text:
                continue
            # 将占位符换成实际内容
            start, end = run.text.find('{'), run.text.find('}')
            key, place_holder = run.text[start + 1:end], run.text[start:end + 1]
            run.text = run.text.replace(place_holder, emp_dict[key])
    # 每个人对应保存一个Word文档
    doc.save(f'{emp_dict["name"]}离职证明.docx')
```

执行上面的代码，会在当前路径下生成三个Word文档，如下图所示：

![v2-0db4543bc6e5fca519b69e87ad03828d_720w](image/v2-0db4543bc6e5fca519b69e87ad03828d_720w.jpg)

### PPT文件读写

**PowerPoint是微软公司开发的演示文稿程序，是微软的Office系列软件中的一员，被商业人士、教师、学生等群体广泛使用，通常也将其称之为“幻灯片”。**在Python中可以使用名为 `python-pptx` 的三方库来生成PowerPoint，首先我们需要安装名为`python-pptx`的三方库，命令如下所示：

```
pip install python-pptx
```

用Python操作PowerPoint的内容，因为实际应用场景不算很多，我不打算在这里进行赘述，有兴趣的读者可以自行阅读`python-pptx`的[官方文档](https://link.zhihu.com/?target=https%3A//python-pptx.readthedocs.io/en/latest/)，下面仅展示一段来自于官方文档的代码：

```python
from pptx import Presentation

# 创建幻灯片对象
pres = Presentation()

# 选择母版添加一页
title_slide_layout = pres.slide_layouts[0]
slide = pres.slides.add_slide(title_slide_layout)
# 获取标题栏和副标题栏
title = slide.shapes.title
subtitle = slide.placeholders[1]
# 编辑标题和副标题
title.text = "Welcome to Python"
subtitle.text = "Life is short, I use Python"

# 选择母版添加一页
bullet_slide_layout = pres.slide_layouts[1]
slide = pres.slides.add_slide(bullet_slide_layout)
# 获取页面上所有形状
shapes = slide.shapes
# 获取标题和主体
title_shape = shapes.title
body_shape = shapes.placeholders[1]
# 编辑标题
title_shape.text = 'Introduction'
# 编辑主体内容
tf = body_shape.text_frame
tf.text = 'History of Python'
# 添加一个一级段落
p = tf.add_paragraph()
p.text = 'X\'max 1989'
p.level = 1
# 添加一个二级段落
p = tf.add_paragraph()
p.text = 'Guido began to write interpreter for Python.'
p.level = 2

# 保存幻灯片
pres.save('test.pptx')
```

运行上面的代码，生成的PowerPoint文件如下图所示：

![v2-1d8bd0984051f13875d246f93f43a425_720w](image/v2-1d8bd0984051f13875d246f93f43a425_720w.jpg)

### PDF文件读写

**PDF是Portable Document Format的缩写，这类文件通常使用`.pdf`作为其扩展名。**在Python中，可以使用名为 `PyPDF2` 的三方库来读取PDF文件，可以使用下面的命令来安装它。

```bash
pip install PyPDF2
```

`PyPDF2` 没有办法从PDF文档中提取图像、图表或其他媒体，但它可以提取文本，并将其返回为Python字符串。

```python
import PyPDF2

reader = PyPDF2.PdfFileReader('test.pdf')
page = reader.getPage(0)
print(page.extractText())
```

当然，`PyPDF2`并不是什么样的PDF文档都能提取出文字来，这个问题就我所知并没有什么特别好的解决方法，尤其是在提取中文的时候。网上也有很多讲解从PDF中提取文字的文章，推荐大家自行阅读[《三大神器助力Python提取pdf文档信息》](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1395339)一文进行了解。

要从PDF文件中提取文本也可以直接使用三方的命令行工具，具体的做法如下所示。

```bash
pip install pdfminer.six
pdf2text.py test.pdf
```

上面的代码中通过创建 `PdfFileReader` 对象的方式来读取PDF文档，该对象的`getPage`方法可以获得PDF文档的指定页并得到一个 `PageObject` 对象，通过 `PageObject` 对象的 `rotateClockwise` 和 `rotateCounterClockwise` 方法可以实现页面的顺时针和逆时针方向旋转，通过 `PageObject` 对象的 `addBlankPage` 方法可以添加一个新的空白页，代码如下所示：

```python
import PyPDF2
from PyPDF2.pdf import PageObject

# 创建一个读PDF文件的Reader对象
reader = PyPDF2.PdfFileReader('resources/XGBoost.pdf')
# 创建一个写PDF文件的Writer对象
writer = PyPDF2.PdfFileWriter()
# 对PDF文件所有页进行循环遍历
for page_num in range(reader.numPages):
    # 获取指定页码的Page对象
    current_page = reader.getPage(page_num)  # type: PageObject
    if page_num % 2 == 0:
        # 奇数页顺时针旋转90度
        current_page.rotateClockwise(90)
    else:
        # 偶数页反时针旋转90度
        current_page.rotateCounterClockwise(90)
    writer.addPage(current_page)
# 最后添加一个空白页并旋转90度
page = writer.addBlankPage()  # type: PageObject
page.rotateClockwise(90)
# 通过Writer对象的write方法将PDF写入文件
with open('resources/XGBoost-modified.pdf', 'wb') as file:
    writer.write(file)
```

使用 `PyPDF2` 中的 `PdfFileWrite` 对象可以为PDF文档加密，如果需要给一系列的PDF文档设置统一的访问口令，使用Python程序来处理就会非常的方便。

```python
import PyPDF2

reader = PyPDF2.PdfFileReader('resources/XGBoost.pdf')
writer = PyPDF2.PdfFileWriter()
for page_num in range(reader.numPages):
    writer.addPage(reader.getPage(page_num))
# 通过encrypt方法加密PDF文件，方法的参数就是设置的密码
writer.encrypt('foobared')
with open('resources/XGBoost-encrypted.pdf', 'wb') as file:
    writer.write(file)
```

上面提到的 `PageObject` 对象还有一个名为 `mergePage` 的方法，可以两个PDF页面进行叠加，通过这个操作，我们很容易实现给PDF文件添加水印的功能。例如要给上面的“XGBoost.pdf”文件添加一个水印，我们可以先准备好一个提供水印页面的PDF文件，然后将包含水印的 `PageObject` 读取出来，然后再循环遍历“XGBoost.pdf”文件的每个页，获取到 `PageObject` 对象，然后通过 `mergePage` 方法实现水印页和原始页的合并，代码如下所示。

```python
import PyPDF2

from PyPDF2.pdf import PageObject

reader1 = PyPDF2.PdfFileReader('resources/XGBoost.pdf')
reader2 = PyPDF2.PdfFileReader('resources/watermark.pdf')
writer = PyPDF2.PdfFileWriter()
# 获取水印页
watermark_page = reader2.getPage(0)
for page_num in range(reader1.numPages):
    current_page = reader1.getPage(page_num)  # type: PageObject
    current_page.mergePage(watermark_page)
    # 将原始页和水印页进行合并
    writer.addPage(current_page)
# 将PDF写入文件
with open('resources/XGBoost-watermarked.pdf', 'wb') as file:
    writer.write(file)
```

如果愿意，还可以让奇数页和偶数页使用不同的水印，大家可以自己思考下应该怎么做。

创建PDF文档需要三方库 `reportlab` 的支持，安装的方法如下所示。

```bash
pip install reportlab
```

下面通过一个例子为大家展示`reportlab`的用法。

```python
from reportlab.lib.pagesizes import A4
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen import canvas

pdf_canvas = canvas.Canvas('resources/demo.pdf', pagesize=A4)
width, height = A4

# 绘图
image = canvas.ImageReader('resources/guido.jpg')
pdf_canvas.drawImage(image, 20, height - 395, 250, 375)

# 显示当前页
pdf_canvas.showPage()

# 注册字体文件
pdfmetrics.registerFont(TTFont('Font1', 'resources/fonts/Vera.ttf'))
pdfmetrics.registerFont(TTFont('Font2', 'resources/fonts/青呱石头体.ttf'))

# 写字
pdf_canvas.setFont('Font2', 40)
pdf_canvas.setFillColorRGB(0.9, 0.5, 0.3, 1)
pdf_canvas.drawString(width // 2 - 120, height // 2, '你好，世界！')
pdf_canvas.setFont('Font1', 40)
pdf_canvas.setFillColorRGB(0, 1, 0, 0.5)
pdf_canvas.rotate(18)
pdf_canvas.drawString(250, 250, 'hello, world!')

# 保存
pdf_canvas.save()
```

上面的代码如果不太理解也没有关系，等真正需要用Python创建PDF文档的时候，再好好研读一下 `reportlab` 的[官方文档](https://link.zhihu.com/?target=https%3A//www.reportlab.com/docs/reportlab-userguide.pdf)就可以了。

### 简单总结

总体上来说，采用文件来存储数据的方式是最常见的，也是我们必须要掌握的，在后面的章节中会介绍各种类型文件的读写方式。

## 数据库存储

数据库存储数据在日常生活中应用的就更加广泛了，例如：

1. 身份证信息放在公安部的系统
2. 银行卡的余额和交易记录、转帐信息
3. 在酒店的开房信息（所以出现了数据库被盗和信息泄漏）
4. 飞机、火车、汽车联网购票记录
5. QQ聊天记录、网上购物、贴吧、喜欢听的音乐、电影的收藏信息
6. 手机电话机录、余额、公交卡余额、水费、电费、彩票的购买记录
7. 打游戏的装备、等级、魔力、力量、攻击能力等信息

相比于文件存储来说，数据库存储的优势主要在于以下几方面：

1. **数据库的数据存储量比文件存储更大。**
2. 数据库加载数据的速度比打开一个大文件速度更快。
3. **数据库和文件一样都是在硬盘当中，断后不丢失数据。**
4. **易于数据的增、删、改、查操作，能极大的减少了工作量。**
5. **数据库可以很简单的设置密码保护，提高了保护数据的安全性。**

### 连接池技术

使用数据库就必须要先连接到数据库，**其实数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。**针对数据库的连接问题，提出了专门负责分配、管理和释放数据库连接的连接池技术，**它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。**应用这项技术能明显提高对数据库操作的性能。

**在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。连接的建立、断开都由连接池自身来管理，同时还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等**，也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

**最小连接数：限定连接池中最小数据库连接数量。**数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数制约。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。

**最大连接数：限定连接池中最大数据库连接数量。**如果当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中，这会影响之后的数据库操作。

?> 正常情况下，每次执行方法都会获取或创建一个连接，每次执行完方法都会释放连接，所以都保持最小连接数。但是如果一直没有释放连接，直到超过最大连接数就会报错。

### PyMySQL库

这里我们开始学习如何使用Python来连接数据库、将数据存储在数据库中以及对数据库中的数据进行CRUD（增删改查）操作。**首先介绍PyMySQL库是一个专门用于连接并操作MySQL数据库的第三方库。**

在执行下面操作时，确保电脑中安装了MySQL，且将MySQL的路径添加到了环境变量中，然后再在命令行窗口输入下面命令，启动MySQL服务：

```
net start mysql
```

安装PyMySQL：

```
pip install pymysql
```

#### 连接MySQL

安装好了PyMySQL库，首先第一步就是要连接到MySQL数据库上：

```python
# 导入pymysql
import pymysql

# 生成连接db对象，负责开启\关闭连接MySQL数据库、提交执行结果
db = pymysql.connect(
    host='127.0.0.1', 
    user='root', 
    password='123456', 
    database='lb',
    port = 3306,
    charset='utf8',
    cursorclass=pymysql.cursors.DictCursor  # 生成以字典形式返回结果的游标（可选）
)

# 生成游标cursor操作对象，负责操作数据库。
with db.cursor() as cursor:
    # 操作MySQL
    sql = '...'
    # 执行sql语句
    cursor.execute(sql)
    # 提交操作，除了查询操作外的其他操作都需要进行提交，否则操作无效。
    db.commit()

'''
注释：cursor和db.cursor()是有区别的，使用cursor去执行sql语句，自始至终只有一个操作游标，如果使用db.cursor()去执行sql语句，则会生成多个操作游标，而且还可能会报错。

常见错误：
(1049, Unknown database 'lb') # 没有名称为lb的数据库
(1045, Access denied for user 'rooot'@'localhost'(using password: YES)) # 密码或用户名错误
'''
```

#### 执行SQL

```python
# SQL建表语句：创建一张名为USER的数据表，表中三个字段，id字段为主键、自增型，NAME字段为字符串类型最大长度为10，HOBBY字段为字符串类型最大长度为100。
sql1 = "CREATE TABLE USER(\
            Id INT PRIMARY KEY AUTO_INCREMENT, \
			NAME VARCHAR(10), \
			HOBBY VARCHAR(100))"
# 操作游标cursor使用execute方法执行sql1中的SQL语句
cursor.execute(sql1)

# SQL插入语句：向USER表中的NAME、HOBBY字段插入变量name、hobby的值(%s代表插入的变量是字符型)
sql2 = 'INSERT INTO USER(NAME, HOBBY) VALUES("%s", "%s")' % ('chen', 'sport')
# 执行sql2中的SQL语句
cursor.execute(sql2)

# SQL插入语句：向USER表中的NAME、HOBBY字段中插入值为"zhuo"、"computer"的字符串
sql3 = "INSERT INTO USER(NAME, HOBBY) VALUES('zhuo', 'computer')"
# 执行sql3中的SQL语句
cursor.execute(sql3)

# SQL插入语句：数据的插入是通过SQL语句实现的
sql4 = 'INSERT INTO students(id, name, age) values(%s, %s, %s)
# 有一个极其不方便的地方，比如突然增加了某一个字段sex，此时SQL语句就要改成：
sql4 = 'INSERT INTO students(id, name, age, sex) values(%s, %s, %s, %s)
# 这显然不是我们想要，这时我们就需要一个通用的插入动态变化的字典的方法：
table = 'students'
data = {
        'id': 1,
        'name': 'chen',
        'age': 20
    	}
keys = ','.join(data.keys())
values = ','.join(['%s'] * len(data))
sql4 = f'INSERT INTO {table}({keys}) VALUES({values})'
# 执行sql4中的SQL语句
cursor.execute(sql4)

# 使用连接对象db提交要执行的操作数据，若不提交，以上操作全部无效
db.commit()
```

#### 错误回滚

```python
try:
   if cursor.execute(sql, tuple(data.values())):
        # 尝试执行SQL语句，如果成功提交操作数据
     	print('Successful')
        db.commit()
except:
   # 操作失败就回滚再次执行SQL语句
   print('Failed')
   db.rollback()
```

#### 返回结果

```python
# sql查询语句
sql = f'SELECT cookie FROM 表名 WHERE 条件语句'
# 执行sql
cursor.execute(sql)
# fetchall()以元组的形式返回所有的结果
res = cursor.fetchall()
print(res)     # ((数据1), (数据2), (数据3)...)
print(res[0])  # (数据1)
# fetchmany(size=None)以元组的形式返回所有指定长度的结果
res = cursor.fetchmany(size=3)
print(res)     # ((数据1), (数据2), (数据3))
print(res[0])  # (数据1)
# fetchone()以元组的形式返回一条结果，如果没有结果返回None
res = cursor.fetchone()
print(res)     # (数据1)
print(res[0])  # 数据1
```

### SQLAlchemy软件

**SQLAlchemy是Python编程语言下的一款开源软件，提供了SQL工具包及对象关系映射（ORM）工具，使用MIT许可证发行，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型。**

SQLAlChemy的三个最重要的部分是：**SQL表达式语言、对象关系映射器(ORM)以及Core 。**

**SQL表达式语言是一个完全独立于ORM包的工具包，它提供了一个构造由可组合对象表示的SQL表达式的系统，针对特定事务范围内的目标数据库“执行”这些SQL表达式，并返回结果集。**

**对象关系映射（英语：Object Relational Mapping，简称ORM），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。简单的说：ORM相当于中继数据。**

**由于关系数据库本身是可变服务，不同之处在于Core/SQL表达式语言是面向命令的，而ORM是面向状态的。**在使用ORM时，SQL语句的构造方式与使用Core时基本相同，**但是插入、更新和删除(即 DML)的任务(这里指的是数据库中业务对象的持久性)是使用称为 unit of work ，它将针对可变对象的状态更改转换为INSERT、UPDATE和DELETE构造，然后根据这些对象调用这些构造。**

![938876-20160814190600531-930266102](image/938876-20160814190600531-930266102.png)

?> 提示：本章节使用的SQLAlchemy版本为1.4（安装要求最低python3.6），所有的例子也都适用于1.4以上的版本，有一点要注意的就是1.4版本与1.3版本有较大改动，以下案例或许不能通用。

#### 安装并连接

下载安装SQLAlchemy：

```
pip install SQLAlchemy
```

检查SQLAlchemy的安装版本：

```python
import sqlalchemy

print(sqlalchemy.__version__)  # 1.4.29
```

**任何SQLAlchemy程序开始都是有一个只为特定数据库服务器创建一次的名为 `Engine` 的全局对象，此对象会通过一个URL字符串（该字符串将描述如何连接到数据库主机或后端）进行配置连接到特定数据库的中心源。**

```python
from sqlalchemy import create_engine

# 初始化数据库连接
engine = create_engine("mysql+pymysql://用户名:密码@IP:端口/数据库名称", 
         echo=True,  # 输出SQL执行过程，调试的时候更方便（可选）
         future=True  # 启用2.0版API（用于1.4及以上版本，可选）
         max_overflow=10,  # 最大连接数（默认为5，可选）
         pool_size=10,  # 连接池大小（可选）
         pool_timeout=60,  # 池中没有线程最多等待的时间，否则报错（可选）
         pool_recycle=60 * 60 * 2  # 限制多久没连接自动断开，默认为-1或没有超时（可选）
)

# 建立Engine对象负责连接到数据库，并使用范围限制在特定上下文中
with engine.connect() as conn:
    ...
```

#### 执行文本SQL

`text()` 方法允许编写文本SQL语句。

`conn.execute()` 方法执行文本SQL语句。

```python
from sqlalchemy import text
from sqlalchemy import create_engine

engine = create_engine("mysql+pymysql://root:123456@127.0.0.1:3306/new_origin_data")

with engine.connect() as conn:
    # text()方法编写文本SQL语句
    # conn.execute()方法执行文本SQL语句
    result = conn.execute(text("select 'hello world'"))
    print(result.all())  # [('hello world',)]
    result = conn.execute(text("SELECT 3*8"))
    print(result.all())  # [(24,)]

# 使用冒号格式“变量名:变量”接受变量传递的参数
with engine.connect() as conn:
    result = conn.execute(text("SELECT 3*8 WHERE 5>:y"), {"y": 1})
    print(result.all())  # [(24,)]
    result = conn.execute(text("SELECT 3*8 WHERE 5>:y"), {"y": 10})
    print(result.all())  # []

# 同样的我们还可以对表做出一些更改操作
with engine.connect() as conn:
    # 建表语句
    conn.execute(text("CREATE TABLE some_table (x int, y int)"))
    # 插入语句
    conn.execute(text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),[{"x": 1, "y": 1}, {"x": 2, "y": 4}, {"x": 6, "y": 8}, {"x": 9, "y": 10}])
```

`Result` 有很多用于获取和转换行的方法，**例如，上面 `Result.all()` 方法一次性接受所有结果，它返回所有 Row 物体。**下面我们将演示访问行的各种方法：

- **元组赋值** -这是Python最惯用的风格，即在接收到变量时将变量按位置分配给每一行：

  ```python
  with engine.connect() as conn:
      result = conn.execute(text("select x, y from some_table"))
      for x, y in result:
          print(f'x: {x}, y: {y}')
  ```

- **整数索引** -元组是Python序列，因此也可以进行常规整数访问：

  ```python
  with engine.connect() as conn:
      result = conn.execute(text("select x, y from some_table"))
          for row in result:
              x = row[0]
  ```

- **属性名称** -由于这些是Python命名的元组，这些元组具有与每个列的名称相匹配的动态属性名。这些名称通常是SQL语句为每行中的列指定的名称。虽然它们通常是相当可预测的，也可以由标签控制，但在定义较少的情况下，它们可能会受到特定于数据库的行为的影响：

  ```python
  with engine.connect() as conn:
      result = conn.execute(text("SELECT x, y FROM some_table"))
      for row in result:
          print(f"x: {row.x}  y: {row.y}")
  '''
  x: 1  y: 1
  x: 2  y: 4
  x: 6  y: 8
  x: 9  y: 10
  '''
  ```

- **映射访问** -以Python形式接收行 **映射** 对象，它本质上是Python的公共接口的只读版本 `dict` 对象 `Result` 可能是 **转化** 变成一个 `MappingResult` 对象使用 `Result.mappings()` 修饰符；这是一个结果对象，它生成类似dictionary的 `RowMapping` 对象而不是 `Row` 物体：：

  ```python
  with engine.connect() as conn:
      result = conn.execute(text("select x, y from some_table"))
      for dict_row in result.mappings():
          x = dict_row['x']
          y = dict_row['y']
  ```

!> 注意：SQLAlchemy的1.4.29版本已经没有 `conn.commit()` 方法来提交更改，都是 `conn.execute()` 边走边执行。

#### 映射类建表

**Table类：首先需要创建基本结构 Table 表对象来对应操作的数据库表。**在SQLAlchemy中提供了Table类来创建表对象，构造函数如下：

```python
from sqlalchemy import Table

Table.__init__(self, name, metadata, *args, **kwargs)
```

| 名称            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| **name**        | **数据库表名**                                               |
| **metadata**    | **共享的元数据**                                             |
| **\*args**      | **Column，用来定义列**                                       |
| **\*\*kwargs**  | **数据库表属性的可变参数（具体如下）**                       |
| schema          | 表的结构名称，默认None                                       |
| autoload        | 自动从现有表中读入表结构，默认False                          |
| autoload_with   | 从其他engine读取结构，默认None                               |
| include_columns | 如果autoload设置为True，则此项数组中的列明将被引用，没有写的列明将被忽略，None表示所有都列明都引用，默认None |
| mustexist       | 如果为True，表示这个表必须在其他的python应用中定义，必须是metadata的一部分，默认False |
| useexisting     | 如果为True，表示这个表必须被其他应用定义过，将忽略结构定义，默认False |
| owner           | 表所有者，用于Orcal，默认None                                |
| quote           | 设置为True，如果表明是SQL关键字，将强制转义，默认False       |
| quote_schema    | 设置为True，如果列明是SQL关键字，将强制转义，默认False       |
| mysql_engine    | mysql专用，可以设置'InnoDB'或'MyISAM'                        |

**Column类：在上面的Table类中有一参数 `*args` 是专门用来定义列的，及数据库表中的字段。**同样的，在SQLAlchemy中提供了Column类来创建表对象，构造函数如下：

```python
from sqlalchemy import Column

Column.__init__(self, name, type_, *args, **kwargs)
```

| 名称             | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| **name**         | **列名**                                                     |
| **type_**        | **列的类型，详见 `sqlalchemy.types`**                        |
| **\*args**       | **列的约束参数（具体如下）**                                 |
| ForeignKey('列') | 列的外键                                                     |
| ColumnDefault    | 默认                                                         |
| Sequenceobjects  | 序列                                                         |
| key              | 列的别名                                                     |
| **\*\*kwargs**   | **列中的可变参数（具体如下）**                               |
| primary_key      | 如果为True，则是主键                                         |
| nullable         | 是否可为Null，默认是True                                     |
| default          | 默认值，默认是None                                           |
| index            | 是否是索引，默认是True                                       |
| unique           | 是否唯一键，默认是False                                      |
| onupdate         | 指定一个更新时候的值，这个操作是定义在SQLAlchemy中，不是在数据库里的，当更新一条数据时设置，大部分用于updateTime这类字段 |
| autoincrement    | 设置为整型自动增长，只有没有默认值，并且是Integer类型，默认是True |
| quote            | 如果列明是关键字，则强制转义，默认False                      |

**type类型：在上面Column类中type_是专门定义列的类型的，大部分常用的类型都在sqlalchemy中的 `types.py` 文件里面，通过 `from sqlalchemy import types` 即可看到。**导入方式如下：

```python
from sqlalchemy import Integer, String
```

常用类型内容如下：

```python
__all__ = ['TypeEngine', 'TypeDecorator', 'UserDefinedType', 'ExternalType', 'INT', 'CHAR', 'VARCHAR', 'NCHAR', 'NVARCHAR', 'TEXT', 'Text', 'FLOAT', 'NUMERIC', 'REAL', 'DECIMAL', 'TIMESTAMP', 'DATETIME', 'CLOB', 'BLOB', 'BINARY', 'VARBINARY', 'BOOLEAN', 'BIGINT', 'SMALLINT', 'INTEGER', 'DATE', 'TIME', 'TupleType', 'String', 'Integer', 'SmallInteger', 'BigInteger', 'Numeric', 'Float', 'DateTime', 'Date', 'Time', 'LargeBinary', 'Boolean', 'Unicode', 'Concatenable', 'UnicodeText', 'PickleType', 'Interval', 'Enum', 'Indexable', 'ARRAY', 'JSON']
```

**还有一部分不常用的类型在 `from sqlalchemy.dialects import mysql` 当中。如果需要使用上述类型，则需从 `sqlalchemy.dialects.mysql` 进行导入。**导入方式如下：

```python
from sqlalchemy.dialects.mysql import MEDIUMTEXT
```

不常用类型内容如下：

```python
__all__ = ('BIGINT', 'BINARY', 'BIT', 'BLOB', 'BOOLEAN', 'CHAR', 'DATE', 'DATETIME', 'DECIMAL', 'DOUBLE', 'ENUM', 'DECIMAL', 'FLOAT', 'INTEGER', 'INTEGER', 'JSON', 'LONGBLOB', 'LONGTEXT', 'MEDIUMBLOB', 'MEDIUMINT', 'MEDIUMTEXT', 'NCHAR', 'NVARCHAR', 'NUMERIC', 'SET', 'SMALLINT', 'REAL', 'TEXT', 'TIME', 'TIMESTAMP', 'TINYBLOB', 'TINYINT', 'TINYTEXT', 'VARBINARY', 'VARCHAR', 'YEAR', 'dialect', 'insert', 'Insert')
```

**前面提到首先需要创建基本结构 Table 表对象来对应操作的数据库表，即表的模型。** 首先建立 `user`、`address` 表模型，模型可以在ORM持久性和查询操作中使用。内容如下：

```python
# 导入工厂函数构造基类
from sqlalchemy.ext.declarative import declarative_base
# 导入数据类型和约束
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey

engine = create_engine("mysql+pymysql://root:123456@127.0.0.1:3306/new_origin_data")

# declarative_base()是一个工厂函数，它为声明性类定义构造基类。
Base = declarative_base()

# Base作为我们声明的ORM映射类的基类。
class User(Base):
    # user表
    __tablename__ = 'user'
    # id字段，主键
    id = Column(Integer, primary_key=True)
    # name姓名字段
    name = Column(String(30))
    # fullname全名字段
    fullname = Column(String(100))

class Address(Base):
    # address表
    __tablename__ = 'address'
    # id字段，主键
    id = Column(Integer, primary_key=True)
    # user_id字段
    user_id = Column(Integer, ForeignKey('user.id'), nullable=False)
    # email_address字段
    email_address = Column(String(100), nullable=False)

'''
注释：
Table - 表示数据库表。
Column - 表示数据库表中的列，通常包括一个字符串名和一个类型对象。
Integer、String - 表示SQL数据类型， 例如给“name”列指定长度为30就写为了String(30)。
primary_key=True - 表示该Column是此表的主键的一部分。
ForeignKey('user.id') - 关联外键user表id列。
nullable=False - 非空。
'''
```

!> 注意：在建立模型时，数据库表名称必须放在第一行。

现在我们可以使用定义好模型来安全的创建或删除表。使用下面方法：

```python
# 使用映射类来安全创建上述所有表（操作会先判断表是否存在，存在不创建，否则创建）
Base.metadata.create_all(engine)
# 使用映射类来删除上述所有表
Base.metadata.create_all(engine)
```

#### CRUD

在最开始我们和数据库成功建立了连接，还进行了查询操作、建立了数据表，但这只是常规操作的一小部分，还有更新、插入等操作，但这些操作就比较特殊了，**因为查询、建表的操作要么成功要么失败，而更新、插入操作有可能成功一半后失败，因此我们需要一个原子性的操作对象，而这个对象就是session。**

- Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

ORM通过session与数据库建立连接进行通信，如下所示：**通过sessionmake方法创建一个Session工厂，然后在调用工厂的方法来实例化一个Session对象。**

```python
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey

engine = create_engine("mysql+pymysql://root:123456@127.0.0.1:3306/new_origin_data")
# 实例化session对象
DBSession = sessionmaker(bind=engine)
session = DBSession()

# declarative_base()是一个工厂函数，它为声明性类定义构造基类。
Base = declarative_base()

# Base作为我们声明的ORM映射类的基类
class User(Base):
    # user表
    __tablename__ = 'user'
    # id字段，主键
    id = Column(Integer, primary_key=True)
    # name姓名字段
    name = Column(String(30))
    # fullname全名字段
    fullname = Column(String(100))
```

##### 插入操作

```python
# 实例化对象
User1 = User(id=1001, name='ling', fullname="ling jing")
User2 = User(id=1002, name='molin', fullname="molin xi")
User3 = User(id=1003, name='karl', fullname="karl zhou")

# 添加对象
session.add_all([User1, User2, User3])
# 提交session操作
session.commit()
# 关闭session
session.close()
```

##### 查询操作

查询操作是CRUD里面最为复杂，最为繁琐的一个步骤。**在Sqlalchemy中，数据库的查询操作是通过Query对象来实现的。Session提供了创建Query对象的接口。Query对象返回的结果是一组同一映射（Identity Map）对象组成的集合。所谓同一映射，是指每个对象有一个唯一的ID，如果两个对象（的引用）ID相同，则认为它们对应的是相同的对象。事实上，集合中的一个对象，对应于数据库表中的一行（即一条记录）。**

查询操作格式：

```
session.query(映射类名).过滤条件.返回形式
```

常用的过滤条件如下表格：

| 过滤条件                                      | 含义                                           |
| --------------------------------------------- | ---------------------------------------------- |
| filter(类.id==1001)                           | 筛选id为1001的数据                             |
| filter(类.id==None)                           | 筛选id为空的数据                               |
| filter(类.id!=1001)                           | 筛选id不为1001的数据                           |
| filter(类.name.like("%m%"))                   | 模糊查询name中有m字符的数据（区分大小写）      |
| filter(类.name.ilike("%m%"))                  | 模糊查询name中有m或M字符的数据（不区分大小写） |
| filter(类.name.contains("m"))                 | 模糊查询name中有m字符的数据                    |
| filter(and_(类.id>=1001, 类.name.like("%m%")) | 筛选id大于等于1001且name中有m字符的数据        |
| filter(or_(类.id>=1001, 类.name.like("%m%"))  | 筛选id大于等于1001或name中有m字符的数据        |
| filter(类.id.in_([1001, 1002]))               | 筛选id等于1001或等于1002的数据                 |
| filter(类.id.notin_([1001, 1002]))            | 筛选id不等于1001且不等于1002的数据             |
| order_by(类.id)                               | 以id字段排序将数据升序输出                     |
| order_by(类.id.desc())                        | 以id字段排序将数据降序输出                     |
| limit(3)                                      | 返回最前面3条数据                              |

常用的返回形式如下表格：

| 返回形式 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| one()    | 当结果只有一个返回该结果，当结果不足一个或者多个时会报错。   |
| first()  | 当结果不足一个返回None，当结果只有一个返回该结果，当结果多个返回第一个结果。 |
| all()    | 以列表形式返回所有结果，当结果不足一个返回空列表。           |
| count()  | 返回查询结果的数量。                                         |

简单查询操作例子：

```python
# filter方法可以像sql那样写where条件使用>、<等符号，但引用列名时，需要通过`类名.属性名`的方式，等号用==
user_1 = session.query(User).filter(User.id==1001).first()
print(user_1)           # <__main__.User object at 0x000001F71E244508>
print(user_1.name)      # ling
print(user_1.fullname)  # ling jing
# filter_by方法的where条件不能使用>、<等符号，指定列名时，`参数名`即对应名类中的`属性名`，等号用=
user_2 = session.query(User).filter_by(id=1002).first()
print(user_2)           # <__main__.User object at 0x000001F71E244D48>
print(user_2.name)      # molin
print(user_2.fullname)  # molin xi
'''
注释：可以看到查询出来的数据sqlalchemy直接给映射成一个对象了，这个对象和我们创建表时候的class是一致的，我们就也可以直接通过对象的属性就可以直接调用就可以了。
'''
```

##### 更新操作

**更新操作就比较简单了，直接查询出来重新赋值就可以了。**

```python
user_1 = session.query(User).filter(User.id==1001).first()
print(user_1)           # <__main__.User object at 0x000001F71E244508>
print(user_1.name)      # ling
print(user_1.fullname)  # ling jing
# 重新赋值
user_1.name = 'xiao'
user_1.fullname = 'xiao hong'
# 提交session操作
session.commit()

# 再次查询，信息已经被更新
user_1 = session.query(User).filter(User.id==1001).first()
print(user_1)           # <__main__.User object at 0x000001F71E244508>
print(user_1.name)      # xiao
print(user_1.fullname)  # xiao hong
# 关闭session
session.close()
```

##### 删除操作

删除其实也是跟查询相关的，直接查出来，调用 `delete()` 方法直接就可以删除掉。

```python
# 删除id为1001的数据
session.query(User).filter(User.id==1001).delete()
# 提交session操作
session.commit()
# 关闭session
session.close()
```

### reids-py库

redis-py 库提供两个类 Redis 和 StrictRedis 来实现 Redis 的命令操作。

**StrictRedis 实现了绝大部分官方的命令，参数一一对应(官方推荐)。**

**Redis是 StrictRedis 的子类，它的主要功能是用于向后兼容旧版本库里的几个方法。**

#### 安装并连接

安装要求：Python3.6+

安装命令：`pip install redis-py`

?> redis-py 的API保留了Redis API的原始风格，所以使用起来不会有不习惯的感觉。

在执行下面操作时，确保电脑中安装了Redis，并且已经在本机的6379端口启动了Redis服务。

```python
# 导入redis
from redis import StrictRedis

# StrictRedis对象，默认传入地址localhost、端口6379、选择0号数据库（不写默认0号）、密码为None。
client = StrictRedis(host='localhost', port=6379, db='0', password='None')
```

#### 常用数据类型

```python
#1.字符串string 
client.set("hello","world")  # True 
print(client.get("hello"))   # world 

#2.哈希hash 
client.hset("myhash","f1","v1") 
client.hset("myhash","f2","v2") 
print(client.hgetall("myhash"))  # {'f1': 'v1', 'f2': 'v2'} 

#3.列表list 
client.rpush("mylist","1") 
client.rpush("mylist","2") 
client.rpush("mylist","3") 
print(client.lrange("mylist", 0, -1))  # ['1', '2', '3']

#4.集合set 
client.sadd("myset","a") 
client.sadd("myset","b") 
client.sadd("myset","a")         
print(client.smembers("myset"))  # set(['a', 'b']) 

#5.有序集合zset 
client.zadd("myzset","99","tom") 
client.zadd("myzset","66","peter") 
client.zadd("myzset","33","james") 
print(client.zrange("myzset", 0, -1, withscores=True))  # [('james', 33.0), ('peter', 66.0), ('tom', 99.0)] 
```

#### Pipeline管道

**redis中client（客户端）与server（服务端）之间采用的是请求应答的模式：**

```
Client: command1
Server: response1
Client: command2
Server: response2
...
```

在这种情况下，如果要完成10个命令，则需要20次交互才能完成。因此，即使redis处理能力很强，仍然会受到网络传输影响，导致吞吐量上不去。而在管道（pipeline）模式下，多个请求可以变成只需要2次交互。这样网络传输上能够更加高效，加上redis本身强劲的处理能力，给数据处理带来极大的性能提升。

```
Client: command1, command2...
Server: response1, response2...
```

redis-py支持Redis的Pipeline功能，大家知道redis提供了 `mset`、`mget`方法，但没有提供 `mdel` 方法，如果想实现，可以借助pipeline实现：

```python
import redis
# 生成连接
client = redis.StrictRedis(host='localhost', port=6379)
# 生成Pipeline，参数transaction等于False代表不使用事务
pipeline = client.pipeline(transaction=False)

def mdel(keys):
    for key in keys:
        # 将删除命令封装到Pipeline中，此时命令并没有真正执行
        print(pipeline.delete(key))
    # 执行Pipeline
    return pipeline.execute()
```

### pymongo库

**pymongo是一个专门用于连接MongoDB数据库的第三方库。**

#### 安装并连接

在执行下面操作时，确保电脑中安装了MongoDB，且将MongoDB的路径添加到了环境变量中。命令行窗口输入下面命令，启动MongoDB服务：

```
net start mongodb
```

安装pymongo库：

```
pip install pymongo
```

连接数据库：

```python
# 导入pymongo
from pymongo import MongoClient

# 连接本地的MongoDB数据库
client = MongoClient()
# 连接其他机器的MongoDB数据库
client = MongoClient('mongodb://主机IP:27017')
client = MongoClient(host='主机IP', port = 27017)
# 连接对象，假设要连接的数据库名为:primer
db = client.primer
db = client['primer']
# 操作游标，连接到对应的数据表
coll = db.dataset
coll = db['dataset']
```

#### CRUD

插入数据：

```python
# 插入数据
coll.insert(document)
# 插⼊一条数据
coll.insert_one(document)
# 插入多条数据
coll.insert_many(documents, ordered=True)

# 插入一条字典类型数据：students集合，新建一条学生数据，这条数据以字典形式表示：
student = { 'id':'20170101', 
            'name':'Jordan',
            'age', 20, 
            'gender':'male'}

# 执行插入数据方法
result = coll.insert(student) 
# 在MongoDB 中，每条数据都有一个＿id 属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个 ObjectId 类型的＿id 属性。insert()方法会在执行后返回＿id值。
print(result) 	# 932a68615c2606814c91f3d
```

查询数据：

```python
# find：查询出来的是一个列表集合
# 查询所有数据
cursor = coll.find()
# 查询字段是最上层的
cursor = coll.find({"borough": "Manhattan"})
# 查询字段在内层嵌套中
cursor = coll.find({"address.zipcode": "10075"})
# 查询得分大于30的数据
cursor = coll.find({"grades.score": {"$gt": 30}})
# 查询得分小于10的数据
cursor = coll.find({"grades.score": {"$lt": 10}})
# and条件查询，find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。
cursor = coll.find({"cuisine": "Italian", "address.zipcode": "10075"})
# or条件查询
cursor = coll.find({"$or": [{"cuisine": "Italian"}, {"address.zipcode": "10075"}]})

# find_one：查找一条数据，返回的是一个JSON式文档，所以可以直接使用！

# sort排序使用的列表，当排序的标准只有一个，且是递增时，可以直接写在函数参数中：
# 升序
pymongo.ASCENDING = 1
# 升序排列
cursor = coll.find().sort(“borough”)
# 降序
pymongo.DESCENDING = -1
# 降序排列
cursor = coll.find().sort([(“borough”, pymongo.ASCENDING),(“address.zipcode”, pymongo.DESCENDING)])
```

修改数据：

```python
# 更新⽂档的函数有三个(不能更新_id字段)
# 更新匹配的第一条数据
update_one(filter, update, upsert=False)
# 更新匹配的每一条数据
update_many(filter, update, upsert=False)
# 替换匹配的第一条数据
replace_one(filter, replacement, upsert=False)
# 查找并更新匹配的第一条数据
find_one_and_update(filter, update, projection=None, sort=None, 
return_document=ReturnDocument.BEFORE, **kwargs)
```

删除数据：

```python
# 删除⼀个
result = coll.delete_one({‘x’: 1})
# 删除多个
result = coll.delete_many({“borough”: “Manhattan”})
# 删除全部
result = coll.delete_many({})
# 删除整个集合，是drop_collection()的别名
coll.drop()
```

### SSH链接

SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。

以往我们访问数据库的方式都是直连的，也就是直接访问数据库。**但在项目当中，处于安全的考虑，很多情况下线上的数据库都不允许直接访问，大多是通过SSH链接访问。**例如：数据库在A机器，但只能通过B机器来访问，C机器想要访问A机器的数据库，就只能链接B机器再链接A机器访问数据库了。

在Python中可以使用 `mysqldb` 模块通过ssh隧道来链接线上的MySQL数据库：

```python
import pymysql
import yagmail
from sshtunnel import SSHTunnelForwarder

class Spider_Mail(object):
    def __init__(self):
        self.server = None
        self.db = None
        self.cursor = None

    def connect_mysql(self):
        try:
            # 链接到SSH主机上
            self.server = SSHTunnelForwarder(
                ('0.0.0.0', 22),  # SSH主机的IP地址和开放端口
                ssh_username="username",  # SSH的链接的用户名
                ssh_password="password",  # SSH的链接的密码
                remote_bind_address=('0.0.0.0', 3306))  # 数据库所在的IP和端口
            self.server.start()
            # 选择要连接的数据库
            self.db = pymysql.connect(host="127.0.0.1",  # 固定写法
                                 port=self.server.local_bind_port,
                                 user="user",  # 数据库账号
                                 passwd="passwd",  # 数据库密码
                                 db="database")  # 访问特定的数据库
            self.cursor = self.db.cursor()
            print('-'*40+'连接线上数据库成功'+'-'*40)
        except Exception as e:
            print(f'连接线上数据库出错：{e}')

    def main(self):
        self.connect_mysql()
        if self.server and self.db and self.cursor:
            try:
                # 这里执行数据库里面的一些操作
                # 关闭连接
                self.db.close()
                self.server.close()
                print('-' * 40 + '关闭线上数据库连接' + '-' * 40)
            except Exception as e:
                print(f'程序出错：{e}')
```

假如我们的MySQL数据库在服务器上，且不能通过IP直连，就需要通过SSH链接来连接：

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sshtunnel import SSHTunnelForwarder

try:
    ssh_mysql_server = SSHTunnelForwarder(
            ('服务器IP地址', 22),  # 服务器IP地址
            ssh_username="root",  # 登录服务器的用户名
            ssh_password="密码",  # 登录服务器用户名的密码
            remote_bind_address=('172.19.216.186', 3306)) # 再跳转到内网186服务器上的3306端口的MySQL
    ssh_mysql_server.start()
    temp_new_engine = create_engine(
            "mysql+pymysql://root:123456@127.0.0.1:3306/数据库名",
            max_overflow=10,
            pool_size=10,  # 连接池大小
            pool_timeout=60,  # 池中没有线程最多等待的时间，否则报错
            pool_recycle=60 * 60 * 2
        )
    SSH_MYSQL_SESSION = sessionmaker(bind=temp_new_engine)
except Exception as e:
    print(e)
```

### 简单总结

总体上来说，采用数据库来存储数据的方式是最适合的，同样也是我们必须要掌握的，在公司项目中采用数据库存储数据是必然的选择之路。
