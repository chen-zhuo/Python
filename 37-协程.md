# 协程

### 定义

协程（Coroutines）

**协程，又称微线程。一个进程可以有多个线程，一个线程可以有多个协程。**（**进程>=线程>=协程**）

**进程和线程都是由系统控制，协程是由程序猿控制。**

### 特点

优点：内存开销更小，可根据事件切换，避免了无意义的调度，更有效的利用CPU，提高性能。

缺点：程序员必须自己承担调度责任，同时协程也失去了标准线程使用多cpu的能力。

### 效率

协程最大的优势就是极高的执行效率。

协程的切换是由程序自身控制，和线程相比，没有线程切换的开销；和多线程比，线程数量越多，协程的性能优势就越明显。

协程不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，要利用多核CPU，最简单的方法是：多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

### 生成器

Python对协程的支持是通过generator实现的。

在generator中，不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值，并且还可以接收调用者发出的参数。

传统的生产者-消费者模型是：一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：

```
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)

输出：
[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
```

注意到consumer函数是一个generator，把一个consumer传入produce后：

1.首先调用c.send(None)启动生成器；

2.然后，一旦生产了东西，通过c.send(n)切换到consumer执行；

3.consumer通过yield拿到消息，处理，又通过yield把结果传回；

4.produce拿到consumer处理的结果，继续生产下一条消息；

5.produce决定不生产了，通过c.close()关闭consumer，整个过程结束。

整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。
