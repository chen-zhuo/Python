```python
with open('file.txt', rb) as lines:
    for line in lines:
        print(line.encode('utf-8'))
```



### 

  selenium方法：输入账号密码登录——浏览器对象.get_cookies()——获取Cookies——循环取出Cookies中的Cookie——循环添加Cookie——浏览器对象.add_cookies(Cookie)——访问登录后页面。

import time
from io import BytesIO
from PIL import Image
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

USER = '...'  # ⽤户名
PASSWORD = '...'  # 密码

class CrackGeetest():

	# 对象初始化
	def __init__(self):
	    self.url = 'https://passport.bilibili.com/login'
	    self.browser = webdriver.Chrome()
	    self.wait = WebDriverWait(self.browser, 10)
	    self.email = USER
	    self.password = PASSWORD
	
	# 打开链接，等待节点加载，输入字符
	def open(self):
	    self.browser.get(self.url)
	    email = self.wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="login-username"]')))
	    password = self.wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="login-passwd"]')))
	    email.send_keys(self.email)
	    password.send_keys(self.password)
	
	# 获取验证码元素，返回验证码位置元组
	def get_position(self):
	    img = self.wait.until(EC.presence_of_element_located((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_widget gt_clean gt_show"]')))
	    time.sleep(2)
	    location = img.location
	    top, bottom, left, right = location['y'] + 60, location['y'] + 205, location['x'] + 218, location['x'] + 480
	    return top, bottom, left, right
	
	# 获取⽹⻚截图，返回截图对象
	def get_screenshot(self):
	    screenshot = self.browser.get_screenshot_as_png()
	    screenshot = Image.open(BytesIO(screenshot))
	    return screenshot
	
	# 获取验证码图⽚，返回图⽚对象
	def get_geetest_image(self, name='captcha.png'):
	    top, bottom, left, right = self.get_position()
	    print('验证码位置', top, bottom, left, right)
	    screenshot = self.get_screenshot()
	    captcha = screenshot.crop((left, top, right, bottom))
	    captcha.save(name)
	    return captcha
	
	# 获取按钮周围节点，返回按钮对象
	def get_geetest_button(self):
	    button = self.wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_guide_tip gt_show"]')))
	    return button
	
	# 获取滑块按钮节点，返回按钮对象
	def get_slider(self):
	    button = self.wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_slider_knob gt_show"]')))
	    return button
	
	# 判断两个像素是否相同
	def is_pixel_equal(self, image1, image2, x, y):
	    """
	    :param image1: 图⽚1
	    :param image2: 图⽚2
	    :param x: 位置x
	    :param y: 位置y
	    :return: 像素是否相同
	    """
	    # 取两个图⽚的像素点
	    pixel1 = image1.load()[x, y]
	    pixel2 = image2.load()[x, y]
	    threshold = 80
	    # ⽐较像素点的RGB值,本⽂设置的差值在80以内,可以根据情况调整
	    if abs(pixel1[0] - pixel2[0]) < threshold and abs(pixel1[1] - pixel2[1]) < threshold and abs(pixel1[2] - pixel2[2]) < threshold:
	        return True
	    else:
	        return False
	
	# 返回图⽚左边多余不⽤进⾏对⽐的距离
	def get_gap_1(self):
	    return 15
	
	# 遍历图片像素点，返回缺⼝偏移量
	def get_gap_2(self, image1, image2):
	    """
	    :param image1: 不带缺⼝图⽚
	    :param image2: 带缺⼝图⽚
	    """
	    left = 15  # left 是图⽚左边多余不⽤进⾏对⽐的距离
	    high = 37  # 图⽚下⾯多余不⽤进⾏对⽐的距离
	    for i in range(image1.size[0] - 1, left, -1):
	        for j in range(image1.size[1] - high):
	            if not self.is_pixel_equal(image1, image2, i, j):
	                left = i
	                return left
	    return left
	    
	# 根据偏移量，计算移动距离，返回移动轨迹
	def get_track(self, distance):
	    """
	    :distance: 偏移量
	    """
	    # 移动轨迹
	    track = []
	    # 当前位移
	    current = 0
	    # 计算间隔
	    t = 0.2
	    # 初速度
	    v = 0
	    # 只有正加速，速度越大，后面距离偏差越大，适当减少
	    if distance <= 70:
	        pass
	    elif distance <= 100:
	        distance -= 5
	    elif distance <= 110:
	        distance -= 7
	    elif distance <= 120:
	        distance -= 10
	    elif distance <= 130:
	        distance -= 12
	    elif distance <= 140:
	        distance -= 14
	    elif distance <= 150:
	        distance -= 16
	    elif distance <= 160:
	        distance -= 18
	    elif distance <= 180:
	        distance -= 22
	    elif distance <= 190:
	        distance -= 27
	    elif distance <= 200:
	        distance -= 32
	    elif distance <= 210:
	        distance -= 35
	    while current < distance:
	        # 加速度
	        a = 4
	        # 初速度v0
	        v0 = v
	        # 当前速度v = v0 + at
	        v = v0 + a * t
	        # 移动距离x = v0t + 1/2 * a * t^2
	        move = v0 * t + 1 / 2 * a * t * t
	        # 当前位移
	        current += move
	        # 加⼊轨迹
	        track.append(round(move))
	    return track
	
	# 根据移动轨迹来拖动滑块到缺口处
	def move_to_gap(self, slider, track):
	    """
	    :param slider: 滑块
	    :param track: 轨迹
	    """
	    ActionChains(self.browser).click_and_hold(slider).perform()
	    for x in track:
	        ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform()
	    time.sleep(0.5)
	    ActionChains(self.browser).release().perform()
	
	# 汇总使用上面方法
	def crack(self):
	    # 输⼊⽤户名密码
	    self.open()
	    # 点击验证按钮
	    button = self.get_geetest_button()
	    button.click()
	    # 获取验证码图⽚
	    image1 = self.get_geetest_image('captcha1.png')
	    # 点按呼出缺⼝
	    slider = self.get_slider()
	    slider.click()
	    # 获取带缺⼝的验证码图⽚
	    image2 = self.get_geetest_image('captcha2.png')
	    # 获取缺⼝1位置
	    gap1 = self.get_gap_1()
	    # 获取缺⼝2位置
	    gap2 = self.get_gap_2(image1, image2)
	    gap = gap2 - gap1
	    print('缺⼝1位置', gap1)
	    print('缺⼝2位置', gap2)
	    print('缺⼝距离', gap)
	    # 获取移动轨迹
	    track = self.get_track(gap)
	    print('滑动轨迹', track)
	    # 拖动滑块
	    self.move_to_gap(slider, track)

def main():
    crack = CrackGeetest()
    crack.crack()
    # 验证成功后，休息50秒
​    time.sleep(50)

if __name__ == '__main__':
    main()

### 虚拟环境

**本次搭建的项目环境适用于后面所有项目，其操作步骤都相同。**

### Python环境和虚拟环境

**python环境**：指程序运行的基础环境，只要安装了Python3，python环境就具备了。

**虚拟环境**：指以Python环境为基础针对某一个项目而建立的私有环境。

​	简单说，Python环境是大环境，所有项目都可使用它；虚拟环境是私有环境，只有一个项目适用它。

### 虚拟环境的作用

所有项目共用一个环境不是很好吗？每个项目都创建私有环境岂不是很麻烦？

​	我们所做的许多事都是为了尽可能的提高效率或降低资源占有率。如果所有的项目都共用一个环境，那么在运行项目时，环境会加载许多项目用不上的包，这样反而浪费了系统的资源。因此虚拟环境轻装上阵就显得很有必要了。

**虚拟环境的作用**：将不同项目所用的包隔离开来，为项目创建私有的环境。

### 搭建虚拟环境

##### 新建文件夹

在磁盘中确定一个位置新建文件夹(名称通常是env)，用来存放虚拟环境。为了方便管理，所有的项目环境最好都放在此文件夹下。（这里我在F盘下，新建了Env文件夹用来存放虚拟环境）

##### 安装virtualenv

打开命令行窗口，输入下面命令安装virtualenv（virtualenv是用来创建虚拟环境的包）

```
pip3 install virtualenv
```

##### 创建虚拟环境

将命令行窗口的操作路径切换到Env文件夹下，或者在Env文件夹下shift+鼠标右键，打开命令行窗口。输入下面命令：

```
F:\Env>virtualenv --no-site-packages project_env（环境名称）
```

如果命令行窗口不在Env文件夹下，我们则可以指定路径创建虚拟环境：

```
F:\>virtualenv --no-site-packages   .\Env\project_env（环境名称）
```

这样就在F盘Env文件夹下面新建了一个project_env文件夹，并在此文件夹里创建了一个干净的、没有多余安装包、名称为project_env的虚拟环境。

**参数说明：**

- --no-site-packages：新建的虚拟环境里不安装Python环境里面已经安装的包，是个纯净的环境
- -p:   指定是哪个版本的python （如系统内只装了一个python版本就不用此参数了）

```
virtualenv --no-site-packages  -p +python的路径  +（安装项目环境路径）.\Env\project_env
```

创建成功界面：

![QQ截图20181225151559](F:\Project Notebook\Picture\QQ截图20181225151559.png)

可以看到该虚拟环境的Python版本为3.6.5，该虚拟环境的可执行文件F:\Env\project_env\Scripts\python.exe，安装了一些必要的包。

回到Env文件夹，可以看到里面多了一个project_env文件夹，里面就放着虚拟环境。

##### 激活虚拟环境

在命令行窗口内进入刚创建环境名称为project_env文件夹下面的Scripts文件夹下，输入下面命令：

```
activate
```

执行后，命令行前端发生变化，前面多了（project_env）说明已经激活且进入了所创建的虚拟环境里。

![QQ截图20181225153825](F:\Project Notebook\Picture\QQ截图20181225153825.png)

**命令：**

activate： 激活虚拟环境   

pip list：查看**当前环境**的已安装的包

deactivate：退出虚拟环境

注：project_env环境中安装的包存放位置：F:\Env\Project_env\Lib\site-packages

### Pycharm配置虚拟环境

通过Pycharm打开项目后，进入下方的Terminal

![QQ截图20181225154731](F:\Project Notebook\Picture\QQ截图20181225154731.png)

可以看到并没有在虚拟环境里面，接下来就要配置了。

在Pycharm的File—Settings—Project里面

![QQ截图20181225155651](F:\Project Notebook\Picture\QQ截图20181225155651.png)

点击‘齿轮’，点击Show All，展示已有的环境（包括一个Python环境和多个虚拟环境）

![QQ截图20181225155825](F:\Project Notebook\Picture\QQ截图20181225155825.png)

点击加号，添加环境

![QQ截图20181225160321](F:\Project Notebook\Picture\QQ截图20181225160321.png)

**注意：**这里我们要选择下面Existing environment（已经存在的环境），因为我们上面已经创建了project_env虚拟环境，路径要特别指定虚拟环境project_env\Scripts\python.exe可执行文件，点击ok即可添加。

​	而上面的New environment（新环境）是重新创建一个新虚拟环境，在Location指定一个**空文件夹**（文件夹不存在也可以，它会自动新建）路径，用来存放存放环境，下方的Base interpreter（基础环境）就是指定Python环境里面Python.exe可执行文件的路径。通过这种方法创建的虚拟环境也是干净的。

![QQ截图20181225162659](F:\Project Notebook\Picture\QQ截图20181225162659.png)

这里可以看到列表里面多了一个带（project_env）环境，点击ok

![QQ截图20181225162726](F:\Project Notebook\Picture\QQ截图20181225162726.png)

这里就可以看到该环境已经安装的三个包（和上面的pip list看到的结果是一样的），所以该环境是很干净的虚拟环境，点击Apply应用。

关闭Pycharm下面的Terminal，再次打开，就不同了

![QQ截图20181225163323](F:\Project Notebook\Picture\QQ截图20181225163323.png)

可以看见前面多了（project_env），说明该项目默认是在project_env虚拟环境中运行了。



### 爬取网页信息

```
import pymysql
import requests
from lxml import etree
from fake_useragent import UserAgent

# 请求头
headers = {'User-Agent': UserAgent().random,}
# 地址
url = '...'
# 获取响应
response = requests.get(url=url, headers=headers)
# 转码
response.encoding = 'utf-8'


# 解析页面
def analyze():
    info = etree.HTML(response.text)
    # text()获取文本
    user = info.xpath('.../text()')
    # @src获取src属性
    image = info.xpath('.../@src')
    return user, image


# 存入MySQL数据库
def save_mysql(info):
    # 连接数据库
    host = '127.0.0.1'
    user = 'root'
    password = '...'
    database = '...'
    port = 3306
    db = pymysql.connect(host, user, password, database, charset='utf8', port=port)
    # 生成操作游标（对数据库进行操作）
    cursor = db.cursor()
    # sql语句，INSERT INTO插入，table_name数据表名，user,image字段名，values值，%s字符串，info就是上面方法的信息元祖
    sql = "INSERT INTO table_name(user, image) values('%s','%s')" % info
    # 通过操作游标的execute()执行sql语句
    cursor.execute(sql)
    # 提交执行结果（没有这它，数据库存不进数据）
    db.commit()

if __name__ == '__main__':
    info = analyze()
    save_mysql(info)
```



