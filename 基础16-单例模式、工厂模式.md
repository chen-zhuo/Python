# 单例模式、工厂模式

### 单例模式

##### 单例模式定义

**单例模式**：**一个类**从始至终**只能创建一个实例**，是一种常用的软件设计模式。

##### 类的方法和私有属性

运用单例模式我们需要先回顾类的一些方法和属性。

**`__init__` 方法**：**初始化新创建的对象**，在一个对象创建以后被会立即调用。

```python
# 创建类People
class People:
	
	# self代表通过类创建的对象
    def __init__(self, age, sex):
        self.age = age
        self.sex = sex
        print('实例人物已构造')

# 这里通过类People创建chen对象，立即执行People类里面的__init__方法，来初始化对象chen
chen = People(18, '男')
print(chen.age)
print(chen.sex)
'''
结果：
实例人物已构造
18
男
'''
```

**`__new__`方法**：**新建并且返回新的对象。**

```python
# __new__方法不创建和返回对象
class Earth:
    def __init__(self):
        print('执行init')
	
	# 重定义__new__方法
    def __new__(cls):
        print('执行new')

a = Earth()
print(a)
'''
结果：
执行new
None
# 注释1：通过结果可知道最先执行了__new__方法，print打印结果为：None（空），说明这个对象并没有创建。
# 注释2：__new__方法，在未被重新定义时，功能是创建和返回对象，而在程序中我们重新定义了该方法，只打印了一句字符串，既没有创建对象，也没返回对象，也就无法执行__init__方法来初始化对象来执行下面的打印语句。对象都没有创建，所以print结果为None。
'''

# __new__方法创建和返回对象
class Earth:
    def __init__(self):
        print('执行init')

    def __new__(cls):
        print('执行new')
        # 返回通过object类的__new__方法创建的对象
        return object.__new__(cls)

a = Earth()
print(a)
'''
结果：
执行new
执行init
<__main__.Earth object at 0x0000000D599C8978>
# 注释：和上面的例子比就多了一行代码。在__new__方法里执行了默认object类的__new__方法，即object.__new__(cls)，创建了对象，并且通过return返回了该对象，注意这里的对象必须要返回，如果没有return，则这个例子的结果和上个例子的结果相同。
'''
```

**`__instance` 私有属性**：**`__` 私有（在外部不能直接使用,可在类的内部使用），`instance` 属性名称**。

```python
class Earth:
    __instance = None
    print(__instance)
    
    def __new__(cls):
        print(cls.__instance)
        # 这里改变了类对象的私有属性
        cls.__instance = True

a = Earth()
'''
结果：
None
None
# 注释：在Earth类里面定义了一个__instance私有属性，然后打印了这个私有属性，又在__new__方法里再次打印了这个私有属性，结果都为None，再将这个私有属性赋值为True。
'''

class Earth:                    # 1.程序开始运行，
    __instance = None           # 2.定义私有属性赋值为None(类中，方法外的代码，直接执行)
    print(__instance)           # 3.打印私有属性，输出：None

    def __new__(cls):           # 6.创建对象调用方法__new__。10.创建对象调用方法__new__
        print(cls.__instance)   # 7.打印私有属性，输出：None。11.打印私有属性，输出：True
        cls.__instance = True   # 8.重新赋值私有属性为True。12.再次赋值私有属性为True

a = Earth()                     # 4.创建对象a
b = Earth()                     # 9.创建对象b
'''
结果：
None
None
True
# 注释：说明在创建a对象时，改变了类方法里面的私有属性__instance的值，创建b对象时，会沿用私有属性__instance被改变的值。
'''
```

##### 单例模式

运用上面的的方法和属性我们可以来写一个单例模式

```python
class Earth:
    # 定义私有属性__instance赋值为None
    __instance = None
    
    def __new__(cls):
    	# 如果__instance为空，说明是第一次执行
        if cls.__instance == None:
        	# 执行object.__new__(cls)，建立对象，赋值给私有属性__instance
            cls.__instance = object.__new__(cls)
            # 返回新建对象
            return cls.__instance
        # 如果__instance不为空，说明对象存在直接返回
        return cls.__instance

a = Earth()
print(id(a))
b = Earth()
print(id(b))
'''
结果：
846411303120
846411303120
# id相同，说明a、b是同一对象。
'''
```

##### 传参单例模式

我们向单例模式传递参数

```python
# 属性覆盖
class Earth:
    __instance = None

	# 定义__init__方法，name形参接收实参
    def __init__(self, name):
        self.name = name

	# 多传了姓名参数，这里也要添加name形参
    def __new__(cls, name):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        return cls.__instance

a = Earth('地球')
print(a.name, id(a))
b = Earth('火星')
print(b.name, id(b))
print(a.name, id(a))
'''
结果：
地球 53131512912
火星 53131512912
火星 53131512912
# 根据id说明，对象只有一个。但是第一次打印a.name结果为‘地球’，没问题，当创建完b对象后，第二次打印a.name结果为‘火星’，说明a对象属性被b对象属性覆盖了。
'''

# 属性不覆盖
class Earth:
    __instance = None
    # 新增__first属性
    __first = False

    def __init__(self, name):
    	# 如果__first为False，说明是第一次初始化
        if self.__first == False:
            self.name = name
            self.__first = True

    def __new__(cls, name):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        return cls.__instance

a = Earth('地球')
print(a.name, id(a))
b = Earth('火星')
print(b.name, id(b))
print(a.name, id(a))
'''
结果：
地球 114167941496
地球 114167941496
地球 114167941496
# 注释：从相同结果说明该对象创建后，属性从未变动过。
'''
```

### 工厂模式

##### 工厂模式定义

**工厂模式：在软件开发中用来创建对象的设计模式。**

工厂模式，也称之为“简单工厂模式”或者是“静态工厂模式”，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时，**不会对客户端暴露创建逻辑**，所谓的“**创建逻辑**”是**指我必须要知道创建函数的构造函数的逻辑组成，才能创建对象**。

##### 创建对象

```python
class Student:
    def __init__(self,name,age):
        self.name=name
        self.age=age
 
student=Student('张三',23)
'''
# 注释：通过姓名 、年龄 这两项基本信息创建一个学生对象，这两个信息就是所谓的创建逻辑。
'''
```

在实际中，可能需要更多知道的信息，如身高、性别等，才能完全创建一个学生实例，但在不知道这些信息的情况下创建一个学生实例，这就是工厂模式要做的事情。说的更通俗一点，就是专门创建类型的实例的工厂(类) 。

##### 工厂模式

作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是，**复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式**。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 

```python
import math
 
#定义4个图形类，并且每一个图形都有一个可以计算面积的方法
class Circle:
    def Area(self,radius):
        return math.pow(radius,2)*math.pi
 
class Rectangle:
    def Area(self,longth,width):
        return 2*longth*width
 
class Triangle:
    def Area(self,baselong,height):
        return baselong*height/2
 
class Ellipse:
    def Area(self,long_a,short_b):
        return long_a*short_b*math.pi
 
#=================================
#定义创建对象的一个工厂
class Factory:
    def create_shape(self, name):
        if name =='Circle':
            return Circle()
        elif name == 'Rectangle':
            return Rectangle()
        elif name == 'Triangle':
            return Triangle()
        elif name == 'Ellipse':
            return Ellipse()
        else:
            return None
 
if __name__=='__main__':
    factory=Factory()
 
    circle=factory.create_shape('Circle')
    circle_area=circle.Area(2)
    print(f'这是一个圆，它的面积是：{circle_area}')
 
    rectangle=factory.create_shape('Rectangle')
    rectangle_area=rectangle.Area(2,3)
    print(f'这是一个长方形，它的面积是：{rectangle_area}')
 
    triangle=factory.create_shape('Triangle')
    triangle_area=triangle.Area(2,3)
    print(f'这是一个三角形，它的面积是：{triangle_area}')
 
    ellipse=factory.create_shape('Ellipse')
    ellipse_area=ellipse.Area(3,2)
    print(f'这是一个椭圆，它的面积是：{ellipse_area}')
'''
输出：
这是一个圆，它的面积是：12.566370614359172
这是一个长方形，它的面积是：12
这是一个三角形，它的面积是：3.0
这是一个椭圆，它的面积是：18.84955592153876
# 注释：从上面可以看出，在创建某一个图形类的时候，根本不关心这个类的构造函数到底是什么，只需要告诉工厂，创建一个什么类即可，除此以外，不需要知道任何的额外信息，这就是所谓的“隐藏创建类的代码逻辑” 。
'''
```

### 虚拟环境

**本次搭建的项目环境适用于后面所有项目，其操作步骤都相同。**

### Python环境和虚拟环境

**python环境**：指程序运行的基础环境，只要安装了Python3，python环境就具备了。

**虚拟环境**：指以Python环境为基础针对某一个项目而建立的私有环境。

​	简单说，Python环境是大环境，所有项目都可使用它；虚拟环境是私有环境，只有一个项目适用它。

### 虚拟环境的作用

所有项目共用一个环境不是很好吗？每个项目都创建私有环境岂不是很麻烦？

​	我们所做的许多事都是为了尽可能的提高效率或降低资源占有率。如果所有的项目都共用一个环境，那么在运行项目时，环境会加载许多项目用不上的包，这样反而浪费了系统的资源。因此虚拟环境轻装上阵就显得很有必要了。

**虚拟环境的作用**：将不同项目所用的包隔离开来，为项目创建私有的环境。

### 搭建虚拟环境

##### 新建文件夹

在磁盘中确定一个位置新建文件夹(名称通常是env)，用来存放虚拟环境。为了方便管理，所有的项目环境最好都放在此文件夹下。（这里我在F盘下，新建了Env文件夹用来存放虚拟环境）

##### 安装virtualenv

打开命令行窗口，输入下面命令安装virtualenv（virtualenv是用来创建虚拟环境的包）

```
pip3 install virtualenv
```

##### 创建虚拟环境

将命令行窗口的操作路径切换到Env文件夹下，或者在Env文件夹下shift+鼠标右键，打开命令行窗口。输入下面命令：

```
F:\Env>virtualenv --no-site-packages project_env（环境名称）
```

如果命令行窗口不在Env文件夹下，我们则可以指定路径创建虚拟环境：

```
F:\>virtualenv --no-site-packages   .\Env\project_env（环境名称）
```

这样就在F盘Env文件夹下面新建了一个project_env文件夹，并在此文件夹里创建了一个干净的、没有多余安装包、名称为project_env的虚拟环境。

**参数说明：**

- --no-site-packages：新建的虚拟环境里不安装Python环境里面已经安装的包，是个纯净的环境
- -p:   指定是哪个版本的python （如系统内只装了一个python版本就不用此参数了）

```
virtualenv --no-site-packages  -p +python的路径  +（安装项目环境路径）.\Env\project_env
```

创建成功界面：

![QQ截图20181225151559](F:\Project Notebook\Picture\QQ截图20181225151559.png)

可以看到该虚拟环境的Python版本为3.6.5，该虚拟环境的可执行文件F:\Env\project_env\Scripts\python.exe，安装了一些必要的包。

回到Env文件夹，可以看到里面多了一个project_env文件夹，里面就放着虚拟环境。

##### 激活虚拟环境

在命令行窗口内进入刚创建环境名称为project_env文件夹下面的Scripts文件夹下，输入下面命令：

```
activate
```

执行后，命令行前端发生变化，前面多了（project_env）说明已经激活且进入了所创建的虚拟环境里。

![QQ截图20181225153825](F:\Project Notebook\Picture\QQ截图20181225153825.png)

**命令：**

activate： 激活虚拟环境   

pip list：查看**当前环境**的已安装的包

deactivate：退出虚拟环境

注：project_env环境中安装的包存放位置：F:\Env\Project_env\Lib\site-packages

### Pycharm配置虚拟环境

通过Pycharm打开项目后，进入下方的Terminal

![QQ截图20181225154731](F:\Project Notebook\Picture\QQ截图20181225154731.png)

可以看到并没有在虚拟环境里面，接下来就要配置了。

在Pycharm的File—Settings—Project里面

![QQ截图20181225155651](F:\Project Notebook\Picture\QQ截图20181225155651.png)

点击‘齿轮’，点击Show All，展示已有的环境（包括一个Python环境和多个虚拟环境）

![QQ截图20181225155825](F:\Project Notebook\Picture\QQ截图20181225155825.png)

点击加号，添加环境

![QQ截图20181225160321](F:\Project Notebook\Picture\QQ截图20181225160321.png)

**注意：**这里我们要选择下面Existing environment（已经存在的环境），因为我们上面已经创建了project_env虚拟环境，路径要特别指定虚拟环境project_env\Scripts\python.exe可执行文件，点击ok即可添加。

​	而上面的New environment（新环境）是重新创建一个新虚拟环境，在Location指定一个**空文件夹**（文件夹不存在也可以，它会自动新建）路径，用来存放存放环境，下方的Base interpreter（基础环境）就是指定Python环境里面Python.exe可执行文件的路径。通过这种方法创建的虚拟环境也是干净的。

![QQ截图20181225162659](F:\Project Notebook\Picture\QQ截图20181225162659.png)

这里可以看到列表里面多了一个带（project_env）环境，点击ok

![QQ截图20181225162726](F:\Project Notebook\Picture\QQ截图20181225162726.png)

这里就可以看到该环境已经安装的三个包（和上面的pip list看到的结果是一样的），所以该环境是很干净的虚拟环境，点击Apply应用。

关闭Pycharm下面的Terminal，再次打开，就不同了

![QQ截图20181225163323](F:\Project Notebook\Picture\QQ截图20181225163323.png)

可以看见前面多了（project_env），说明该项目默认是在project_env虚拟环境中运行了。