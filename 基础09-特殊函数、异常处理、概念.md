# 特殊函数、异常处理、概念

### 特殊函数

##### 匿名函数 `lambda`

**匿名函数**：本质还是函数，以另外一种简单的方式来声明的

`lambda`：声明匿名函数

匿名函数格式：`函数名 = lambda 参数列表：返回值表达式`

```python
# 普通函数
def my_sum1(x,y):
    return x+y
print(my_sum1(10, 20))			# 30

# 匿名函数
my_sum2 = lambda x, y: x+y
print(my_sum2(10, 20))			# 30
```

##### 递归函数

**递归函数**：在**函数中调用函数本身**的函数称为**递归函数**。

1. 递归效率低下，每调用一次函数，系统都要为其分配内存空间。
2. 循环能做的事情，虽然递归函数也可以做，但**尽量不使用递归**。

```python
def fun1():
    print('===')
    fun1()

fun1()	# 输出多个===后，出现递归错误：调用python对象超过了最大递归深度
```

### 异常处理

举例：使用代码打开一个文件，假如文件不存在，代码就会报错，但为了能让程序继续执行下去，就需要对文件不存在的情况进行异常处理。

**异常处理**：简单说，**让代码不崩溃变得更加健壮，就需要在代码可能会报错的地方进行特殊的处理**。

##### `pass`

**关键字 `pass`**：空语句，**不做任何事情**，一般用做占位语句，目的为了保持程序结构的完整性。

```python
if 2 > 1:
    pass			# 空
else:
    print('2小于1')
```

#####  `try`、`except`、`finall`

**关键字 `try`**：尝试执行下面一个缩进的代码块，无论是否报错。

**关键字 `except`**：当 `try` 下面的报错时，**根据报错类型**，来执行 `except` 下面的代码块。

**关键字 `finally`**：不管 `try` 下面的代码块是否报错，**都要执行 `finally` 下面的代码块**。

```python
# 不指定错误类型异常处理
try:
    代码1
except:		# 这里只要代码1出现错误，不管是什么类型的错误，都会执行代码2
    代码2
'''
流程1：执行代码1——>没有错误——>程序结束
流程2：执行代码1——>出现错误——>执行代码2——>程序结束
'''    

# 指定错误类型异常处理
try:
    代码1
except 错误类型:  # 指定错误的类型，若要同时捕获多个类型的异常：except（错误类型1，错误类型2...）
    代码2
'''
流程1：执行代码1——>没有错误——>程序结束
流程2：执行代码1——>出现错误——>错误类型不一样——>程序结束
流程3：执行代码1——>出现错误——>错误类型一样——>执行代码2——>程序结束
'''

# 异常处理
try:
    代码1
except:
    代码2
finally:
    代码块3
'''
流程：不管代码块1中是否出现异常都会执行代码3
'''
```

**若代码块1中的输出语句报错，是不会输出的内容的。**

```python
try:
    print({'a': 'b', 'b': 1}['c'])		# 前面字典中没有c键，因此键错误。
except KeyError:						# 指定错误类型为键错误
    print('键错误')					  # '键错误'，报错和指定错误类型相同因此会输出
finally:
    print('异常捕获结束')			        # '异常捕获结束'，无论上面代码是否报错都会输出

'''
输出：
键错误
异常捕获结束
'''
```

##### `raise`、`Exception`

**关键字 `raise`**：抛出一个指定的异常。

`Exception`：抛出异常的内容。

```python
def ThorwErr():
    raise Exception("抛出一个异常")  
ThorwErr()

'''
报错：
Exception: 抛出一个异常
'''
```

### 概念

##### 概念整合

**变量**：变量就是存储各种类型数据的的**容器**。

**函数**：对实现特定功能的**代码块的封装**。

**类**：对有相同属性和功能的**群体的封装**。

**对象**：通过类创建的**一个实体**。

**方法**：使用对象调用在**类中声明的函数**。

##### 概念区别

**函数与方法**：一般函数是用类名去调用，方法是用对象去调用；函数要手动传 `self`，方法不用传 `self`。

**名称和地址**：其实变量名、函数名、类名很相似，**就是一个名字对应内存地址中的一些内容**。

1. `func` 表示的是函数名，实质是**函数的内存地址**，类也是如此。
2. `func()` 表示的是调用 `func` 函数，实质是**调用 `func` 函数内存地址里面的内容**，类也是如此。

**变量指向函数**：即 `变量名=函数名`，指变量被赋值为**函数的地址**。

```python
def func(a,b):
    print(a+b)

a = func        # a被赋值为函数func地址
print(id(func))
print(id(a))
a(5,3)          # 8，a()就等于func()，a(5,3)就等于func(5,3)
'''
输出：
305402617640
305402617640
8
'''
```

**变量赋值返回值**：即 `变量=函数`，指变量被赋值为**函数的返回值**。

1. **在变量赋值为函数的返回值过程中，函数会先被调用一次**。
2. **变量被赋值为函数的返回值后，变量存储的就是函数的返回值。**
3. 变量指向函数的过程中，函数名不要带括号；变量赋值返回值的过程中，函数名要带括号。

```python
def func1():
    print(1)
    return 100

a = func1()  # 先调用一次函数，输出1，再将返回值100赋值给了变量a
print(a)     # 等于print(func1())，输出函数函数func1返回值
'''
输出：
1
100
'''
```

##### 编程方式

**面向过程编程**：通过一步一步的写代码来实现功能的方式 -->工具：逻辑和算法

**函数式编程**：面对问题考虑有没有存在某种功能的函数 --->工具:函数

**面向对象编程**：面对问题考虑有没有相应的对象来解决这个问题 --> 工具：类和对象