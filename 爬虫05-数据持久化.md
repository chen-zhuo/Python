# 数据持久化

现在我们已经能采集数据了，但采集下来的数据没有进行持久化保存，电脑关机就没有了，想要用数据又的重新采集一遍，会很麻烦费时。这时，数据的持久化就显得特别重要了。

### 持久化方法

数据持久化常用的有两种方法：

**存储到json文件**：将采集下来的数据**转换成json格式，存储到json文件**。

**存储到数据库**：将采集下来的数据通过**执行存储语句，保存到数据库中**。

##### 存储到json文件

之前已经讲解过json文件的读写，这里就不在赘述，留下一个方法作为参考：

```python
# name参数，确定json文件的名称；content参数，即存储的内容
def JsonFile(name, content):
    # a保留以前数据进行写操作
    with open(f'./{name}.json', 'a', encoding='utf-8') as f:
        # json.dumps转成json格式，编码为utf-8，再解码为Unicode写入(参考记事本工作流程)
        f.write(json.dumps(content).encode('utf-8').decode('unicode_escape')+'\n')
```

##### 存储到数据库

将数据存储到数据库也是数据持久化最基本、最常用的方式。主要优点：

1. 相比于文件存储，数据库的存储量更大。
2. 易于增，删，改，查的操作，能极大的减少了工作量。
3. 提高了保护数据的安全性。

这节主要内容讲解Python与各类常用数据库的对接操作，包括MySQL、MongoDB、Redis。

```python
# MySQL默认端口：3306
# MongoDB默认端口：27017
# 
```

### 操作MySQL

在执行下面操作时，确保电脑中安装了MySQL，且将MySQL的路径添加到了环境变量中。

##### 启动MySQL服务

在命令行窗口输入下面命令，启动MySQL服务：

```
net start mysql
```

##### 安装pymysql

安装第三方库pymysql，用于连接数据库：

```
pip install pymysql
```

##### 配置连接参数

```python
# 导入pymysql
import pymysql

# 主机地址
host = '127.0.0.1'
# 用户名
user = 'root'
# 密码
password = '123456'
# 数据库名称
database = 'lb'
# MySQL数据库的默认端口
port = 3306
# 生成连接db对象
db = pymysql.connect(host, user, password, database, charset='utf8', port=port)
# 生游标cursor操作对象
cursor = db.cursor()
.
.
.
# 关闭MySQL连接
db.close()

'''
# 解释：
1.db对象负责开启\关闭连接MySQL数据库、提交执行结果，游标cursor对象负责操作数据库。
2.将MySQL的连接对象、操作游标对象定义成全局变量，方便函数调用。
3.cursor和db.cursor()是有区别的，使用cursor去执行sql语句，自始至终只有一个操作游标，如果使用db.cursor()去执行sql语句，则会生成多个操作游标，而且还可能会报错。
**注意：关闭MySQL连接不要写在循环中，若频繁的关闭数据库，可能会导致数据库崩溃。**

常见错误：
(1049, Unknown database 'lb') # 没有名称为lb的数据库
(1045, Access denied for user 'rooot'@'localhost'(using password: YES)) # 密码或用户名错误
'''
```

##### 执行SQL语句

```python
# SQL建表语句：创建一张名为USER的数据表，表中三个字段，id字段为主键、自增型，NAME字段为字符串类型最大长度为10，HOBBY字段为字符串类型最大长度为100。
sql1 = "CREATE TABLE USER( Id INT PRIMARY KEY AUTO_INCREMENT, \
						  NAME VARCHAR(10), \
						  HOBBY VARCHAR(100)\
						 )"
# 操作游标cursor使用execute方法执行sql1中的SQL语句
cursor.execute(sql1)

# SQL插入语句：向USER表中的NAME、HOBBY字段插入变量name、hobby的值(%s代表插入的变量是字符型)
sql2 = 'INSERT INTO USER(NAME,HOBBY) VALUES("%s","%s")' % ('chen','sport')
# 执行sql2中的SQL语句
cursor.execute(sql2)

# SQL插入语句：向USER表中的NAME、HOBBY字段中插入值为"zhuo"、"computer"的字符串
sql3 = "INSERT INTO USER(NAME,HOBBY) VALUES('zhuo','computer')"
# 执行sql3中的SQL语句
cursor.execute(sql3)

# 使用连接对象db提交操作数据，若不提交，以上操作全部无效
db.commit()
```

##### 动态数据插入

```python
# 数据的插入是通过SQL语句实现的
sql = 'INSERT INTO students(id, name, age) values(%s, %s, %s)

# 有一个极其不方便的地方，比如突然增加了某一个字段sex，此时SQL语句就要改成：
sql = 'INSERT INTO students(id, name, age, sex) values(%s, %s, %s, %s)

# 这显然不是我们想要，这时我们就需要一个通用的插入动态变化的字典的方法：
table = 'students'
data = {
        'id': 1,
        'name': 'chen',
        'age': 20
    	}
keys = ','.join(data.keys())
values = ','.join(['%s'] * len(data))

sql = f'INSERT INTO {table}({keys}) VALUES({values})'
    
try:
   if cursor.execute(sql, tuple(data.values())):
        # 尝试执行SQL语句，如果成功提交操作数据
     	print('Successful')
        db.commit()
except:
   # 操作失败就回滚再次执行SQL语句
   print('Failed')
   db.rollback()
```

##### 返回执行结果

```python
# sql查询语句
sql = f'SELECT cookie FROM 表名 WHERE 条件语句'
# 执行sql
cursor.execute(sql)
# 将执行结果保存在res
res = cursor.fetchall()
# 结果形式是大元祖包含小元祖，每个小元祖里面包含一个结果和一个空
print(res)				# ((结果1,),(结果2,),(结果3,),...)
print(res[0][0])		# 结果1
```

### 操作MongoDB

同样，在执行下面操作时，确保电脑中安装了MongoDB，且将MongoDB的路径添加到了环境变量中。

##### 启动MongoDB服务

在命令行窗口输入，启动MongoDB服务：

```
net start mongodb
```

##### 安装pymongo

安装第三方库pymongo，用于连接数据库：

```
pip install pymongo
```

##### 配置连接参数

```python
# 导入pymongo
from pymongo import MongoClient

# 连接本地的MongoDB数据库
client = MongoClient()
# 连接其他机器的MongoDB数据库
client = MongoClient('mongodb://主机IP:27017')
client = MongoClient(host='主机IP', port = 27017)
# 连接对象，假设要连接的数据库名为:primer
db = client.primer
db = client['primer']
# 操作游标，连接到对应的数据表
coll = db.dataset
coll = db['dataset']
```

##### 插入数据

插入数据方法：

```python
# 插入数据
coll.insert(document)
# 插⼊一条数据
coll.insert_one(document)
# 插入多条数据
coll.insert_many(documents, ordered=True)
```

插入一条字典类型数据：

```python
# 插入数据 students 这个集合，新建一条学生数据，这条数据以字典形式表示：
student = { 'id':'20170101', 
            'name':'Jordan',
            'age', 20, 
            'gender':'male'}

# 执行插入数据方法
result = coll.insert(student) 
# 在MongoDB 中，每条数据都有一个＿id 属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个 ObjectId 类型的＿id 属性。insert()方法会在执行后返回＿id值。
print(result) 	# 932a68615c2606814c91f3d
```

##### 查询数据

```
# find 查询出来的是⼀个列表集合
# 查询所有数据
cursor = coll.find()
# 查询字段是最上层的
cursor = coll.find({“borough”: “Manhattan”})
# 查询字段在内层嵌套中
cursor = coll.find({“address.zipcode”: “10075”})
# 操作符查询
cursor = coll.find({“grades.score”: {“$gt”: 30}})
cursor = coll.find({“grades.score”: {“$lt”: 10}})
AND
cursor = coll.find({“cuisine”: “Italian”, “address.zipcode”: “10075”})
cursor = coll.find({“$or”: [{“cuisine”: “Italian”}, {“address.zipcode”: “10075”}]})

# find_one，查找一条数据，返回的是⼀个JSON式⽂档，所以可以直接使⽤！

### sort排序时要特别注意，使⽤的并不是和mongo shell的⼀样，⽽是使⽤了列表，
### 当排序的标准只有⼀个，且是递增时，可以直接写在函数参数中：
pymongo.ASCENDING = 1
pymongo.DESCENDING = -1
cursor = coll.find().sort(“borough”)
cursor = coll.find().sort([(“borough”, pymongo.ASCENDING),(“address.zipcode”, pymongo.DESCENDING)])
```

##### 修改数据

```
# 更新⽂档的函数有三个(不能更新_id字段)
update_one(filter, update, upsert=False)
update_many(filter, update, upsert=False)
replace_one(filter, replacement, upsert=False)
find_one_and_update(filter, update, projection=None, sort=None, 
return_document=ReturnDocument.BEFORE, **kwargs)

# update_one返回结果是⼀个：UpdateResult ，如果查找到多个匹配，则只更新第⼀个！
result = coll.update_one(
 {“name”: “Juni”},
 {
 “$set”: {
 “cuisine”: “American (New)”
 },
 “$currentDate”: {“lastModified”: True}
 }
)
update_many
# 查找到多少匹配，就更新多少。
result = coll.update_many(
 {“address.zipcode”: “10016”, “cuisine”: “Other”},
 {
 “$set”: {“cuisine”: “Category To Be Determined”},
 “$currentDate”: {“lastModified”: True}
 }
)
```

##### 删除数据

```
删除⼀个
result = coll.delete_one({‘x’: 1})
删除多个
result = coll.delete_many({“borough”: “Manhattan”})
删除全部
result = coll.delete_many({})
删除整个集合，是drop_collection()的别名
coll.drop()
```

# 操作Redis

##### 安装Redis 

```
pip install Redis
```

##### 安装redis-py

redis-py 库提供两个类 Redis 和 StrictRedis 来实现 Redis 的命令操作。

StrictRedis 实现了绝大部分官方的命令，参数一一对应(官方推荐)。

Redis是StrictRedis 的子类，它的主要功能是用于向后兼容旧版本库里的几个方法。

```
pip install redis-py
```

##### 连接Redis	

现在我们已经在本地安装了 Redis 并运行在 6379 端口，密码默认为None。那么，可以用如下示例连接 Redis 并测试：

```
# 导入redis
import redis

# 声明 StrictRedis 对象，默认传入地址localhost、端口6379、选择0号数据库（不写默认0号）、密码为None。
con = redis.StrictRedis(host='localhost', port=6379, db='0', password='None')
```

##### 键值对string

```
# set()方法，设置一个键值对
con.set('name', 'Bob') 

# 获取键值并打印
print(con.get('name')) 	# b'Bob'
```

##### 集合set

```
# 集合save_url中加入123456
con.sadd('save_url','123456')

# 判断集合save_url是否存在123456
print(con.sismember('save_url','123456'))    # True

# 集合save_url中删除123456
con.srem('save_url','123456')

# 判断集合save_url是否存在123456
print(con.sismember('save_url','123456'))    # False
```

