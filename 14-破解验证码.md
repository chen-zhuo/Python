# 破解验证码

### 图形验证码

在爬虫过程中，难免会遇到各种各样的验证码，而大多数验证码还是图形验证码，这时候我们可以直接用 OCR 来识别。

tesserocr 是 Python 的一个 OCR 识别库 ，但其实是对 tesseract 做的一 层 Python API 封装，所以它的核心是 tesseract。 **因此，在安装 tesserocr 之前，我们需要先安装 tesseract 。**

对于图形验证码，我们可以通过 OCR 技术将其转换成电子文本，然后爬虫将识别的结果提交给服务器，便可以达到自动识别验证码的过程。

```
import tesserocr
from PIL import Image

image = Image.open('图片.jpg')
print(tesserocr.image_to_text(image))	 # 以图片对象的形式来识别的验证码

print(tesserocr.file_to_text('图片.jpg'))	# 以图片文件的形式来识别的验证码
```

tesserocr，对于没有什么背影影响的验证码，直接通过这个库来识别就可以。但是对于有嘈杂的背景的验证码这种，直接识别识别率会很低，遇到这种我们就得需要先处理一下图片，先对图片进行灰度化，然后再进行二值化，再去识别，这样识别率会大大提高。

灰度图像的每个像素点色值在0-255,0代表纯黑，255代表纯白，二其实化值的原理通俗说就是我们对灰度二维码图像做浅灰色统一设置为白色（ 255），深灰色统一设置为黑色（0）。

```
import tesserocr
from PIL import Image

image = Image.open('图片.jpg')
image.show()
# 图片灰度化
image1 = image.convert("L")
image1.show()
# 图片二值化，129是二值化的阈值
image2 = image1.point(lambda x: 255 if x > 129 else 0)
image2.show()
# 去噪点
def denoising(image):
    pixdata = image.load()
    w, h = image.size
    for j in range(1, h - 1):
        for i in range(1, w - 1):
            count = 0
            l = pixdata[i, j]
            if l == pixdata[i, j - 1]:
                count = count + 1
            if l == pixdata[i, j + 1]:
                count = count + 1
            if l == pixdata[i + 1, j - 1]:
                count = count + 1
            if l == pixdata[i + 1, j + 1]:
                count = count + 1
            if l == pixdata[i + 1, j]:
                count = count + 1
            if l == pixdata[i - 1, j + 1]:
                count = count + 1
            if l == pixdata[i - 1, j - 1]:
                count = count + 1
            if l == pixdata[i - 1, j]:
                count = count + 1
            if count < 4:
                pixdata[i, j] = 255
    return image
image3 = denoising(image2)
image3.show()
# 识别验证图片对象
res = tesserocr.image_to_text(image3)
print(res)
```

### 滑块验证码

这里破解的滑块验证码是以bilibili（B站）的登录页面为例，使用的是Selenium工具，操作步骤：

1. 访问登录页面，确保必要的元素加载完成
2. 获取验证码元素的位置
3. 点击**按钮周围**节点，获**不带缺口**的验证码，截屏
4. 点击**按钮**节点，获取**带缺口**的验证码，截屏
5. 根据获取上面验证码位置，对两个截屏图片进行裁剪
6. 裁剪后获取大小相同，只包含验证码的图片
7. 通过遍历两张图片的像素点，比较RGB值
8. 超出一定范围的值认定为缺口，获得缺口位置
9. 根据缺口位置计算出滑块需要滑动的距离
10. **模拟人类操作，需要对滑块进行加速直线运动**，
11. **根据距离和加速度公式，生成移动轨迹**
12. **让滑块根据移动轨迹来滑动，到达缺口**

```
import time
from io import BytesIO
from PIL import Image
from selenium import webdriver
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

USER = '...'  # ⽤户名
PASSWORD = '...'  # 密码


class CrackGeetest():

	# 对象初始化
    def __init__(self):
        self.url = 'https://passport.bilibili.com/login'
        self.browser = webdriver.Chrome()
        self.wait = WebDriverWait(self.browser, 10)
        self.email = USER
        self.password = PASSWORD

	# 打开链接，等待节点加载，输入字符
    def open(self):
        self.browser.get(self.url)
        email = self.wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="login-username"]')))
        password = self.wait.until(EC.presence_of_element_located((By.XPATH, '//*[@id="login-passwd"]')))
        email.send_keys(self.email)
        password.send_keys(self.password)

	# 获取验证码元素，返回验证码位置元组
    def get_position(self):
        img = self.wait.until(EC.presence_of_element_located((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_widget gt_clean gt_show"]')))
        time.sleep(2)
        location = img.location
        top, bottom, left, right = location['y'] + 60, location['y'] + 205, location['x'] + 218, location['x'] + 480
        return top, bottom, left, right

	# 获取⽹⻚截图，返回截图对象
    def get_screenshot(self):
        screenshot = self.browser.get_screenshot_as_png()
        screenshot = Image.open(BytesIO(screenshot))
        return screenshot

	# 获取验证码图⽚，返回图⽚对象
    def get_geetest_image(self, name='captcha.png'):
        top, bottom, left, right = self.get_position()
        print('验证码位置', top, bottom, left, right)
        screenshot = self.get_screenshot()
        captcha = screenshot.crop((left, top, right, bottom))
        captcha.save(name)
        return captcha

	# 获取按钮周围节点，返回按钮对象
    def get_geetest_button(self):
        button = self.wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_guide_tip gt_show"]')))
        return button
	
	# 获取滑块按钮节点，返回按钮对象
    def get_slider(self):
        button = self.wait.until(EC.element_to_be_clickable((By.XPATH, '//div[@ id="gc-box"] // div[@class ="gt_slider_knob gt_show"]')))
        return button

	# 判断两个像素是否相同
    def is_pixel_equal(self, image1, image2, x, y):
        """
        :param image1: 图⽚1
        :param image2: 图⽚2
        :param x: 位置x
        :param y: 位置y
        :return: 像素是否相同
        """
        # 取两个图⽚的像素点
        pixel1 = image1.load()[x, y]
        pixel2 = image2.load()[x, y]
        threshold = 80
        # ⽐较像素点的RGB值,本⽂设置的差值在80以内,可以根据情况调整
        if abs(pixel1[0] - pixel2[0]) < threshold and abs(pixel1[1] - pixel2[1]) < threshold and abs(pixel1[2] - pixel2[2]) < threshold:
            return True
        else:
            return False
	
	# 返回图⽚左边多余不⽤进⾏对⽐的距离
    def get_gap_1(self):
        return 15

	# 遍历图片像素点，返回缺⼝偏移量
    def get_gap_2(self, image1, image2):
        """
        :param image1: 不带缺⼝图⽚
        :param image2: 带缺⼝图⽚
        """
        left = 15  # left 是图⽚左边多余不⽤进⾏对⽐的距离
        high = 37  # 图⽚下⾯多余不⽤进⾏对⽐的距离
        for i in range(image1.size[0] - 1, left, -1):
            for j in range(image1.size[1] - high):
                if not self.is_pixel_equal(image1, image2, i, j):
                    left = i
                    return left
        return left
        
	# 根据偏移量，计算移动距离，返回移动轨迹
    def get_track(self, distance):
        """
        :distance: 偏移量
        """
        # 移动轨迹
        track = []
        # 当前位移
        current = 0
        # 计算间隔
        t = 0.2
        # 初速度
        v = 0
        # 只有正加速，速度越大，后面距离偏差越大，适当减少
        if distance <= 70:
            pass
        elif distance <= 100:
            distance -= 5
        elif distance <= 110:
            distance -= 7
        elif distance <= 120:
            distance -= 10
        elif distance <= 130:
            distance -= 12
        elif distance <= 140:
            distance -= 14
        elif distance <= 150:
            distance -= 16
        elif distance <= 160:
            distance -= 18
        elif distance <= 180:
            distance -= 22
        elif distance <= 190:
            distance -= 27
        elif distance <= 200:
            distance -= 32
        elif distance <= 210:
            distance -= 35
        while current < distance:
            # 加速度
            a = 4
            # 初速度v0
            v0 = v
            # 当前速度v = v0 + at
            v = v0 + a * t
            # 移动距离x = v0t + 1/2 * a * t^2
            move = v0 * t + 1 / 2 * a * t * t
            # 当前位移
            current += move
            # 加⼊轨迹
            track.append(round(move))
        return track

	# 根据移动轨迹来拖动滑块到缺口处
    def move_to_gap(self, slider, track):
        """
        :param slider: 滑块
        :param track: 轨迹
        """
        ActionChains(self.browser).click_and_hold(slider).perform()
        for x in track:
            ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform()
        time.sleep(0.5)
        ActionChains(self.browser).release().perform()

	# 汇总使用上面方法
    def crack(self):
        # 输⼊⽤户名密码
        self.open()
        # 点击验证按钮
        button = self.get_geetest_button()
        button.click()
        # 获取验证码图⽚
        image1 = self.get_geetest_image('captcha1.png')
        # 点按呼出缺⼝
        slider = self.get_slider()
        slider.click()
        # 获取带缺⼝的验证码图⽚
        image2 = self.get_geetest_image('captcha2.png')
        # 获取缺⼝1位置
        gap1 = self.get_gap_1()
        # 获取缺⼝2位置
        gap2 = self.get_gap_2(image1, image2)
        gap = gap2 - gap1
        print('缺⼝1位置', gap1)
        print('缺⼝2位置', gap2)
        print('缺⼝距离', gap)
        # 获取移动轨迹
        track = self.get_track(gap)
        print('滑动轨迹', track)
        # 拖动滑块
        self.move_to_gap(slider, track)


def main():
    crack = CrackGeetest()
    crack.crack()
    # 验证成功后，休息50秒
    time.sleep(50)


if __name__ == '__main__':
    main()
```
