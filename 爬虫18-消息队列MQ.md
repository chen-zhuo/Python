# 消息队列MQ

前面我们学习了异步爬虫，在很大程度上提升了采集的效率，其“策略”就是**将所有要爬取的链接先获取下来，用列表存储，再启动爬虫程序，不重复的获取链接，省掉了其他爬虫等待链接的时间和本身的闲置时间，因此能成倍提升采集效率。**这里存储链接的列表，就可以称之为**消息队列**。

消息队列：**简称MQ，是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。**

消息队列特点：**阅后即焚**，即消息队列里面的消息被使用后就被销毁了。

消息队列作用：在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，**通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力**。

## 消息队列模型

生产者(producer)：**发送消息的程序。**

![20170524102259570](image/20170524102259570.png)

队列(queue)：**存储消息的队列。** 一个队列只受到主机的内存和磁盘的限制，它实际上是个大的消息缓冲区。

![20170524104231217](image/20170524104231217.png)

消费者(consumer)：**等待接收消息的程序**。

![20170524104158185](image/20170524104158185.png)

消息流：**生产者只管创建消息并发布到队列中，消费者只管监听或使用队列中的消息。**

![1436447-20181121135142706-7726795](image/1436447-20181121135142706-7726795.png)

?> 提示：多个生产者可以发送消息到一个队列，多个消费者可以监听或使用同一个队列中的消息。

## Queue队列

python中有支持队列的两个标准库：进程队列模块 `multiprocessing`、线程队列模块 `queue`（两个模块的用法一模一样）

进程队列模块 `multiprocessing`：**用于多进程，它通过管道以及锁和信号量机制来协调多个进程，数据可以在多进程之间共享同一个变量的数据。**

```python
import multiprocessing

# 创建一个进程队列
q = multiprocessing.Queue()
```

线程队列模块 `queue`：**用于多线程，它可以指定缓冲区大小的阻塞队列，但数据无法在多个进程之间共享。**

```python
import queue

# 创建线程队列，Queue先进先出模式
q1 = queue.Queue()

# empty()判断队列是否为空
print(q1.empty())	# True
# 获取队列q的长度
print(q1.qsize())	# 0

for i in range(3):
	# 向队列q中插入变量数据i
    q1.put(i)

# empty()判断队列是否为空
print(q1.empty())	# False
# 获取队列q的长度
print(q1.qsize())	# 3

# get()获取数据，每次get只能取一个数据
print(q1.get())  # 0
print(q1.get())  # 1
print(q1.get())  # 2


# 创建线程队列，LifoQueue先进后出模式
# maxsize参数表示队列中能存放的数据个数的上限；默认等于0，表示队列大小没有限制。
q2 = queue.LifoQueue(maxsize=4)

# 插入数据0，1，2，3后，消息队列数据达到上限，发生阻塞，不会执行下面的print语句。
for i in range(5):
    q2.put(i)	
print('程序结束')

# 队列q2中一边插入数据，一边消费数据，所以不会发生阻塞，可以执行下面的print语句。
for i in range(5):
    q2.put(i)
    print(q2.get())	
print('程序结束')	
'''
输出：4 3 2 1 0 程序结束
解释：put(i)插入一次数据，get()获取一次数据，数据量不会达到队列上限4，能执行print语句。
'''
```

?> 提示：`queue` 和 `multiprocessing` 模块，两者 `Queue` 队列的 `get`、`put`、`empty`、`qsize` 等方法名称是相同的。

## Redis消息队列

**Redis是时下比较火的内存数据库，以简单高效著称，具有丰富的数据类型，常用于缓存数据，也支持队列queue，我们可以将Redis作为message broker（消息中间人）。**

Redis目前只能实现简单的消息队列功能，它所具有的优点：

- 极低延迟：得益于Redis本身的高效，消息可以极低延迟传递。
- 上手容易：只需组合使用两三个命令，即可完成消息传递。
- 查看便利：可以便利地查看队列内容；利用 `MONITOR` 命令甚至可以实时监控消息入队和出队。
- 单线程锁：**Redis本身是一个单线程的，相当于所有操作都有一把天然的排他锁，因此我们不用担心在并发下同一条消息会传递给多个使用者**。

### 可靠消息队列

可靠消息队列：**由两个列表组成，一个存储待处理（`pending`）的消息，另一个存储处理中（`processing`）的消息。**

可靠消息队列运行流程：

1. **生产者将所有任务添加至待处理列表里面；**
2. **消费者从待处理列表里面获取任务，并将该任务添加至处理中列表；**
3. **消费者成功处理任务后，再将处理中列表里面的任务删除。**

使用可靠消息队列的优势在于，可以防止处理异常，而导致任务丢失。详情请阅读：《DataBase》中的《Redis-消息队列》

### 启动配置服务

首先确保本机已经安装了Redis，接着修改Redis的配置文件`redis.windows.conf`，方便使用：

1. 注释绑定，在 `bind 127.0.0.1` 前面加上一个注释，允许其他IP能连接Redis。

![QQ截图20200917224556](image/QQ截图20200917224556.png)

2. 设置密码，取消 `requirepass` 前面的注释，在后面加上自己的密码 。

![QQ截图20200917223824](image/QQ截图20200917223824.png)

3. 配置启动，为了让修改的配置起作用，在命令行通过配置文件来启动Redis。

```
redis-server "Redis安装路径\redis.windows.conf"
```

![QQ截图20200917225122](image/QQ截图20200917225122.png)

4. 连接Reids，再启一个命令行，通过密码来连接Redis进行操作。

```
方法一：连接时，通过密码进行身份验证
redis-cli -a 密码

方法二：连接后，通过密码进行身份验证
redis-cli
auth 密码
```

![QQ截图20200917230443](image/QQ截图20200917230443.png)

### 任务处理

**添加任务**：向 Redis 里面添加需要处理的任务：

```python
# 导入Redis模块
from redis import StrictRedis

# 连接局域网内IP为192.168.0.3上密码为123456的Redis的0号数据库
client = StrictRedis(host='192.168.0.3', port=6379, db='0', password='123456')

# 循环添加任务
for message in ['任务1', '任务2', '任务3']:    
    # 通过lpush命令将任务添加到pending待处理列表左侧    
    print(client.lpush("pending", message))
```

**获取任务**：弹出 `pending` 待处理列表最右边的任务，并且将任务添加到处理中的 `processing` 任务列表的最左边。

```python
# 弹出pending待处理列表最右边的任务，并且将任务添加到处理中的processing任务列表中
message = client.rpoplpush('pending', 'processing')
```

**删除任务**：当任务成功处理完毕，再将任务从处理中的 `processing` 任务列表删除。

```python
# 删除处理中的processing任务列表中从左至右与message内容相同的第一条任务
client.lrem('processing', 1, message)
```

## RabbitMQ框架

**RabbitMQ是一个使用Erlang语言开发、基于AMQP协议（高级消息队列协议）实现专门做队列的框架，其主要特点有面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全性。在队列方面要比redies队列性能要好，支持的功能会更多，消息的可靠性更强，且支持多种语言: Java、.NET、PHP、Python、JavaScript、Ruby、Go等。**

### 模型介绍

既然RabbitMQ也是一种队列，那和前面说的线程queue和进程queue有什么区别呢？

- **线程queue只能在同一个进程下进行数据交互；**
- **进程queue只能在父进程和子进程之间，或者同一父进程下的子进程之间做数据交互。**

但如果需要对不同进程（eg：微信和qq）两个独立的程序间通信，那么有如下三种解决方法：

- 方法1：就是直接把数据写在硬盘（disk）上然后各自的进程读取数据就可以，但是由于硬盘的读写速度太慢，效率太低；
- 方法2：自己写个socket，直接做数据交互，问题是如果改变程序，或者再加一个程序，需要对写好的socket进行修改，还要处理黏包什么的复杂的连接关系，维护成本太高。
- 方法3：**利用已有的中间商（代理），这个broker其实就是封装好的socket，我们拿来直接用就好了。这里的broker，就有RabbitMQ，ZeroMQ，ActiveMQ等。**

![QQ截图20220405175826](image/QQ截图20220405175826.png)

**RabbitMQ是一个消息中间人（broker）: 它接收、存储并且发送消息。**

可以想象一个邮局：当你把想要寄出的信放到邮筒里时，邮递员会把信件送到收信人那里。 在这个比喻中, RabbitMQ 就是一个邮筒（接收）, 同时也是邮局（存储）和邮递员（转发） 。和邮局的主要不同点在于RabbitMQ不处理纸质信件, 而是 接收（accepts）, 存储（stores） 和转发（forwards）二进制数据块 —— 消息（messages）。

### 安装RabbitMQ

以下资源在官网下载太慢，这里介绍另外一个资源下载地址：https://sourceforge.net/，直接在搜索栏输入需要的资源下载即可。

安装我们首先看看[官网](https://www.rabbitmq.com/install-windows.html)声明的依赖项：

![QQ截图20220405173833](image/QQ截图20220405173833.png)

因为RabbitMQ使用Erlang语言开发，因此首先我们需要安装一个Erlang的语言环境。这里我们下载的版本为：Erlang/OTP 24.3.3。**下载好了我们进行安装，注意要按照官网说明的“以管理员身份运行”安装：**

![QQ截图20220405184348](image/QQ截图20220405184348.png)

安装好后，我们将Erlang安装路径添加到系统变量当中，名称为ERLANG_HOME：

![QQ截图20220405184612](image/QQ截图20220405184612.png)

接着继续修改Path的值，添加Erlang安装路径下的bin路径：

![QQ截图20220405184838](image/QQ截图20220405184838.png)

保存修改，我们打开命令行，执行 `erl` 命令，出现下图说明安装成功：

![QQ截图20220405185117](image/QQ截图20220405185117.png)

接下来我们安装RabbitMQ，其版本为3.9.14版本，同样“以管理员身份运行”安装：

![QQ截图20220405185441](image/QQ截图20220405185441.png)

安装好后，我们将RabbitMQ安装路径添加到系统变量当中，名称为RABBITMQ_SERVER：

![QQ截图20220405185857](image/QQ截图20220405185857.png)

接着继续修改Path的值，添加RabbitMQ安装路径下的sbin路径：

![QQ截图20220405190014](image/QQ截图20220405190014.png)

保存后，在重启命令行加载新的信息，执行 `rabbitmq-plugins.bat enable rabbitmq_management` 命令安装插件，出现下面信息说明安装成功：

![QQ截图20220405190623](image/QQ截图20220405190623.png)

这时我们再去访问本机的15672端口：http://localhost:15672/，出现如下页面：

![QQ截图20220405190952](image/QQ截图20220405190952.png)

**用户名和密码都为guest**，点击Login登录，进到如下页面，则说明配置成功了：该页面展示了一些基本的信息，例如RabbitMQ版本、Erlang版本、Nodes节点状态等。

![QQ截图20220405191722](image/QQ截图20220405191722.png)

### 操作RabbitMQ

这里所有的用法都是基于上面RabbitMQ是工作在‘localhost’上且端口号为15672，能在浏览器里访问http://localhost:15672这个地址。

![1415597-20190306075858416-1490847372](image/1415597-20190306075858416-1490847372.png)

python操作RabbitMQ需要的模块有上述几种选择，我们用最简单的pika，用pip直接安装：

```
pip install pika
```

#### 生产消费模型

首先，我们来实现**进程间的通信，从本质上讲是一个生产者-消费者模型，即一个进程作为生产者往RabbitMQ消息队列放入消息，另一个进程作为消费者监听并处理消息队列中的消息。**

![QQ截图20220405225256](image/QQ截图20220405225256.png)

##### 消息分发

**定义一个消息队列**，执行后就会生成一个名称为scrape的队列：

```python
import pika

# 连接本地的RabbitMQ服务
connect = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
# 声明一个频道，即channel
channel = connect.channel()
# 声明一个名称为scrape的队列
channel.queue_declare(queue='scrape')
# 确认完成后，可以将连接关闭
connect.close()
```

回看之前的RabbitMQ管理页面，就会看到Queues的值变为了1：

![QQ截图20220405202749](image/QQ截图20220405202749.png)

点进去，就就可以看到该消息队列的详细信息，例如名称、类型、消息数量等：

![QQ截图20220405202920](image/QQ截图20220405202920.png)

**定义一个生产者**，执行后将消息 `b'Hello world!'` 放入队列中：

```python
import pika

connect = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connect.channel()
# exchange先赋值一个空字符串（后面讲），routing_key队列名称，body放入的消息体（byte类型数据）
channel.basic_publish(exchange='', routing_key='scrape', body='Hello world!'.encode())
connect.close()
```

在页面上也能看到，消息的总数量也变成了1，且有1个消息准备好被使用了，消息使用速率是每秒0个：

![QQ截图20220405204541](image/QQ截图20220405204541.png)

**定义一个消费者**，启动后会监听scrape队列的变动，如果有消息进入，就获取并消费，回调callback方法，打印输出结果：

```python
import pika

connect = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connect.channel()

def callback(ch, method, properties, body):
    print(f'Get {body}')  # Get b'Hello world!'

# queue='scrape'消息来源scrape队列
# auto_ack=True获取消息后，通知消息队列移除该消息；
# on_message_callback=callback消息来临时，执行回调函数callback。
channel.basic_consume(queue='scrape', auto_ack=True, on_message_callback=callback)

channel.start_consuming()
```

执行后，回看管理页面，State状态由running变为idle，而且Ready和Total的数量也变为了0个：

![QQ截图20220405224927](image/QQ截图20220405224927.png)

!> 注意：执行启动生产者或消费者前，都要保证所用的消息队列存在。



