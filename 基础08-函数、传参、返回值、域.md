# 函数、传参、返回值、域

## 函数

举例：游戏的通关操作是 `上下左右 上下左右 上下左右`，我们一共要操作12次才能通关，假如说我们把 `上下左右` 设置称为1个流程，那我们操作3次流程就可以通关了，这样就大大提高了我们的操作效率。我们就认为这样的流程就是函数。

### 函数定义

**函数就是对实现特定功能的代码块的封装，提高代码使用效率。**

在Python中有许多已经定义好的内置函数：

```python
# abs()绝对值函数
print(abs(-10))		     # 10

# sum()求和函数
print(sum([5, -4, -1]))	 # 0

# round()四舍五入函数
print(round(5.5))	     # 6
print(round(5.4))	     # 5
```

如果我们要自定义函数实现某些功能，就必须按照以下格式：

```python
def 函数名(形参列表):
    '''函数说明'''
    函数体

'''
def：声明函数的关键字
函数名：函数名称，最好见名知义。（命名规范参照PEP8）
()：固定格式，必须有
形参列表：函数接收外部传递的数据。（若没有数据接收，可以为空）
函数说明：对函数的功能和参数以及返回值进行说明
函数体：实现函数功能的代码块
'''
```

**函数一定要先定义，再调用。**使用以下调用格式：

```python
# 调用方式
函数名(实参列表)
'''
函数名：调用的函数必须是已经声明过的，而且是先声明后调用
实参列表：给函数接内部传递数据（若没有数据传递，可以为空）
'''

# 函数调用过程
'''
1. 调用函数
2. 回到函数声明的地方
3. 使用实参给形参赋值
4. 执行函数体
5. 函数体执行完成后，回到函数调用的位置。
'''
```

### 简单调用

**一个定义好的函数可以被调用任意次数。**

```python
han1()  # 报错，此时han1函数还未被定义

def han1():    # 定义han1函数
    print('开始学习函数')

han1()         # 调用han1函数
han1()
'''
输出：
开始学习函数
开始学习函数
# 注释：函数调用一定要写在函数声明后面
'''
```

### 函数地址

**其实变量名、函数名很相似，就是一个名字对应内存地址中的一些内容。**

1. `han1` 表示的是函数名，实质是函数的内存地址。
2. `han1()` 表示的是调用 `han1` 函数，实质是调用 `han1` 函数内存地址里面的内容。

```python
def han1():    # 定义han1函数
    print('开始学习函数')

han1()
print(id(han1))
a = han1         # 变量a被赋值为函数han1地址
a()              # a()就等于han1()
print(id(a))
'''
输出：
开始学习函数
305402617640
开始学习函数
305402617640
'''
```

### 递归函数

**递归函数**：在**函数中调用函数本身**的函数称为**递归函数**。

1. 递归效率低下，每调用一次函数，系统都要为其分配内存空间。
2. 循环能做的事情，虽然递归函数也可以做，但**尽量不使用递归**。
3. **函数内最好有结束函数的语句，否则就会超过python最大递归深度，出现递归错误。**

```python
def fun1():             # 定义fun1函数
    print('开始学习函数')
    fun1()              # 程序执行到这里时，fun1函数已经被定义

fun1()  # 解释：输出多个'开始学习函数'后，超过python最大递归深度，出现递归错误
```

### 调用函数

**函数里面可以调用其它已经定义好的函数。**

```python
def han():         # 定义函数han
    print('函数A')

def han1():        # 定义函数han1
    han()		   # 在函数han1里面调用函数han
    print('函数B')

han1()             # 调用函数han1 
'''
输出：
函数A               # 执行了函数han
函数B
'''
```

### 嵌套函数

嵌套函数：在**函数内部**声明**其他的函数**。

1. **函数只能调用和它同级别以及上级的变量或函数**。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。
2. 在调用嵌套函数时，内部函数**在嵌套函数里**可以**直接**调用，在嵌套函数外**不能直接**调用。

```python
def han():               # 2.开始执行函数han
    print('开始学习函数')  # 3.输出：开始学习函数
    def han1():          # 4.定义函数han1
        print('休息一下')
        
han()                    # 1.执行函数han            
'''
输出：
开始学习函数	
# 注释：函数han1只是被定义了，但没有被调用，因此没有输出
'''

def han():               # 2.开始执行函数han
    print('开始学习函数')  # 3.输出：开始学习函数
    def han1():          # 4.定义函数han1
        print('休息一下')
       
han()                    # 1.执行函数han
han1()                   # 5.报错，han1未定义，函数han1在函数han内定义，不能在函数han外部调用
'''
输出：
开始学习函数	
# 注释：在调用嵌套函数时，内部函数不会执行，只在嵌套函数里面调用内部函数才会执行。
'''


# 在调用嵌套函数时，内部函数可以在嵌套函数里面调用执行。
def han():               # 2.开始执行函数han
    print('开始学习函数')  # 3.输出：开始学习函数
    def han1():          # 4.定义函数han1。6.开始执行函数han1
        print('休息一下') # 7. 输出：休息一下
    han1()               # 5.执行函数han1
        
han()                    # 1.执行函数han    
'''
输出：
开始学习函数
休息一下
'''
```

## 传参

### 形参实参

举例：有一个计算圆的面积的函数，假如需要求半径为 `r` 的圆的面积，我们就需要把半径 `r` 传递给函数，让函数来计算，我们就可以认为半径 `r` 就是传递的参数。

**参数的作用**：传递数据的“邮递员”。

**形参**：定义在**声明函数**的**形参列表**里面的参数，是数据的接收方。

```python
# a, b, c都是形参，都在func1函数的形参列表里面
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))
```

**实参**：定义在**调用函数**的**实参列表**里面的参数，是数据的发送方。

```python
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

# 10, 20, 30都是实参，都在func1函数的实参列表里面
func1(10, 20, 30)
```

**注意：传递参数时，实际就是实参给形参赋值的过程，一定要保证每个形参都有对应的实参。**

### 参数传递方式

**位置参数**：传参的时候，实参按**位置顺序**给形参赋值。

1. **传递位置参数的时候，形参的个数必须要和实参的个数完全一样，否则会报错**。

```python
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

func1(10, 20, 30)
'''
输出：
a=10
b=20
c=30
'''
```

**关键字参数**：传参的时候，按照**实参列表**中**形参的名称**进行传递。

1. 传递关键字参数的时候，形参的个数必须要和实参的个数完全一样，否则会报错。
2. **实参列表中，关键字参数必须放在所有位置参数后面**。

```python
def func1(a, b, c):
    print('a=' + str(a))
    print('b=' + str(b))
    print('c=' + str(c))

func1(b=20, a=10, c=30)
'''
输出：
a=10
b=20
c=30
'''
```

**默认参数**：在函数声明的时候，形参可以设置默认值。

1. 默认参数在没有实参传递数据的情况下，使用默认值。
2. 默认参数在有实参传递数据的情况下，使用传递的值。
3. **形参列表中，默认参数必须放在所有位置参数后面**。

```python
def func11(a, b='cc', c='bb', d='a'):
    print(a, b, c, d)

func11(10,d='100')
'''
输出：
10 cc bb 100
'''
```

**不定参数**：在传递参数时存在**实参个数不确定**的情况，就需要将形参列表里面的形参变成容器类型。

`*args`：接收实参传递给形参过程中多出来的**位置参数**或者**空值**，以**元祖**的方式呈现。

```python
def foo(x, *args):
    print(x)        # 1
    print(args)     # (2, 3, 4, 5)
# 其中的2,3,4,5都给了args
foo(1,2,3,4,5)

def foo(x, y=1, *args):
    print(x)        # 1
    print(y)        # 2
    print(args)     # (3, 4, 5)
# 其中的x为1，y=1的值被2重置了，3,4,5都给了args
foo(1,2,3,4,5)


def func1(char, *numbers):
    print(char, type(char))         # a <class 'str'>
    print(numbers, type(numbers))   # ()<class 'tuple'>
# 不定参数，也可接收空值，对应的参数的值就是一个空的元祖
func1('a')
```

`**kwargs`：接收实参传递给形参过程中多出来的**关键字参数**或者**空值**，以**字典**的方式呈现。

```python
def foo(x, **kwargs):
    print(x)            # 1
    print(kwargs)       # {'y': 1, 'a': 2, 'b': 3, 'c': 4}

#将y=1,a=2,b=3,c=4以字典的方式给了kwargs    
foo(1,y=1,a=2,b=3,c=4)


# **kwargs必须要写在*args后面
def foo(x, *args, **kwargs):
    print(x)        # 1
    print(args)     # (2, 3, 4)
    print(kwargs)   # {'y': 1, 'a': 2, 'b': 3, 'c': 4}
# 将1传给了x，将2,3,4以元组方式传给了args，y=1,a=2,b=3,c=4以字典的方式给了kwargs
foo(1,2,3,4,y=1,a=2,b=3,c=4)
```

### 参数位置

在**混用参数**的过程中，必须要规范化参数的所在位置，否则会报错。

**形参列表**：位置参数、默认参数、`*args`、`**kwargs`。

**实参列表**：位置参数、关键字参数。

```
def func(a, b=2, *args):             (正确)
def func(a=1, b=2, **kwargs, *args): (顺序错误，**kwargs必须要写在*args后面)
def func(a, b=2, c):                 (顺序错误，默认参数必须放在所有位置参数后面)
def func(a, b, c: int=3):            (正确，相当于 def func(a, b, c=3):)
```

## 返回值

返回值：**每个函数运行结束以后，都会返回一个值，默认为None**。

1. **调用函数时，函数的返回值是不会被输出的（交互终端除外）**。
2. 在 `print` 函数里面调用函数，**最后**才会输出函数的返回值。

```python
def han():
    print('123')

han()
print(han())
'''
输出：
123   # 第一次调用函数han，输出123
123   # print里面第二次调用函数han，输出123
None  # 函数han运行结束后，print打印其返回值
'''
```

### 关键字 `return`

`return`：**结束函数运行，并返回指定的值**。

1. `return` 会**结束函数**的运行，**其后面的代码一律不运行**。
2. `return` 会在函数结束以后，**会返回跟在后面的值（可以是多个值或空值）**，多个值得返回类型是**元祖**。
3. 函数的返回值默认为 `None`，是因为函数默认自带了 `return  None` 语句，只是没有显示而已。

使用`return` 结束函数：

```python
def han():
    print('函数开始')
    return 				# 这里结束函数
    print('函数结束')
    
han()  # 这里调用函数
'''
输出：
函数开始
'''
```

使用 `return` 设置返回值：

```python
def han():
	print('123')
    return 10000	# 设置返回值为10000

print(han())
'''
输出：
123    # 函数han里面的print('123')输出
10000  # print输出函数han的返回值
'''

def han():
    return 10, 100, 'a'
# return后面返回多个值，返回类型是元祖
print(han(), type(han()))  # (10, 100, 'a') <class 'tuple'>
```

**函数的最终结果就是 `return` 后面的返回值。**

```python
def func1():
    print(1)
    return 100

a = func1()  # 先调用一次函数，输出1，再将返回值100赋值给了变量a
print(a)     # print(a)等于print(func1()返回值)
'''
输出：
1
100
'''

def han():
    print('加油吧，年轻人！')
    return 10000

fan = han()+1	 # 这里han()执行了一次han函数输出'加油吧，年轻人！'后返回了10000
print(fan)       
'''
输出:
加油吧，年轻人！
10001
'''
```

### 高阶嵌套

前面提过嵌套函数的内部函数可以在内部调用，但在嵌套函数外部**不能直接调用**，但**可以通过返回函数地址在外部调用**。

```python
# 嵌套返回值高阶函数
def func():             # 2.开始执行函数func
    print('学习函数')    # 3.输出：学习函数
    def deco():         # 4.定义函数deco。8.开始执行函数deco
       print('休息一下') # 9.输出：休息一下
    return deco         # 5.返回函数deco的地址
    
deco1 = func()          # 1.执行函数func。6.函数deco的地址赋值给变量deco1，deco1=deco
deco1()                 # 7.deco1=deco，deco1()=deco(),执行函数deco()
'''
输出：
学习函数
休息一下
'''
```

### 匿名 `lambda`

匿名函数：**本质还是函数，只不过以另外一种简单的方式来构建功能简单的函数。**

匿名函数格式：`函数名 = lambda 形参列表：返回值表达式`

```python
# 普通函数
def my_sum1(x, y):
    return x + y
print(my_sum1(10, 20))			# 30

# 匿名函数
my_sum2 = lambda x, y: x+y
print(my_sum2(10, 20))			# 30
```

### 过滤 `filter`

过滤器：**用于过滤可迭代对象，将对象的每个元素传递给函数判断，返回符合条件元素组成的迭代器。**

过滤函数格式：`filter(过滤函数, 可迭代对象)`

```python
# 可迭代对象
it = [1, 2, 3, 4, 5]

# 过滤函数
def is_odd(n):
    return n % 2 == 1
# 结合过滤函数
print(list(filter(is_odd, it)))  # [1, 3, 5]，因为filter返回迭代器，可以用容器类型方法取值

# 结合匿名函数
print(list(filter(lambda x: x % 2 == 1, it)))  # [1, 3, 5]
```

## 作用域

作用域：在函数的不同位置定义变量，变量的可使用范围是不一样的，简单讲，就是**变量的可使用范围**。

1. **定义新的函数或类会影响变量的作用域**，而 `for`、`if`、`while` 等语句不会影响变量的作用域。
2. **这里说的是使用变量（输出变量），而不是赋值变量（定义变量），这是两回事。**
3. 不同变量的作用域一般划为分为：**全局变量、局部变量**。

### 全局变量

全局变量：**在程序任何位置都可以使用的变量**，作用域是从**声明开始到文件结束**。

```python
a = 10  	             # a是全局变量
print('第一次：',a)

if True:
    print('第二次：',a)

for x in range(1):
    print('第三次：',a)

def func():
    print('第四次：',a)   # a是全局变量，函数内部也可以使用。

func()
'''
输出：
第一次： 10
第二次： 10
第三次： 10
第四次： 10
'''
```

**在一个作用域给一个变量赋值时，会自动认为这个变量是这个作用域的本地变量，并屏蔽作用域外的同名的变量。**

```python
a = 1         # 这里的a是全局变量

def func():
    a = 2     # 函数func里面定义的变量a是本地变量，和上面的全局变量a类似于‘同名不同人’
    print(a)  # 输出本地变量a

print(a)      # 1，这里print在函数func外部，输出的是全局变量a
func()        # 2
```

**函数内部可以使用全局变量，但不能直接赋值全局变量。**

```python
a = 1           # 这里的a是全局变量

def func():
    print(a)    # 使用全局变量a
    
func()          # 1
print(a)        # 1


def func1():
    print(a+1)  # 使用全局变量a加1
    
func1()         # 2
print(a)        # 1


def func2():
    a += 1      # 报错，变量a默认为函数func2的本地变量，但未定义本地变量a
    print(a)    
    
func2()		    
print(a)        # 1
```

### 局部变量

局部变量：**在函数或类中声明的变量**，作用域是从**声明开始到函数结束**。

```python
def func3():
    aaa = 10    # aaa在函数内声明，为局部变量，作用域是函数内部
    print(aaa)

func3()         # 10
print(aaa)      # 报错,aaa没定义
```

**嵌套的内层函数可以使用外层函数的局部变量，但直接不能赋值。**

```python
# 嵌套的内层函数可以使用外层函数的局部变量
def func1():
    a = 1
    def func2():
        print(a)	# 使用func1中的局部变量a
    func2()

func1()             # 1


def func1():
    a = 1
    def func2():	
        a += 1      # 变量a默认为函数func2的局部变量，但函数func2里面并未定义局部变量a
        print(a)
    func2()

func1()
```

**注意：变量名引用会分作用域进行查找，首先是本地，然后是函数内（如果有的话），之后是全局，最后是内置。**

### 关键字 `global`

`global` 作用：**在函数或类中声明一个全局变量。**

1. **全局变量的声明和使用是两回事**。
2. 在函数中声明一个全局变量，**必须先执行该函数才能让变量成为可以全局使用的变量**。

```python
def func3():
    global a # 声明a为全局变量
    a = 10
    print(a)

def func4():
    print(a) # 因为在函数func3声明了a为全局变量，因此函数fun4也能使用变量a

# 正确输出顺序：
func3()      # 10，这里首先执行了函数func3，让a成为了全局可以使用的变量
print(a)     # 10，这里使用的变量a是有意义的
func4()      # 10，这里使用的变量a是有意义的

# 错误输出顺序：
func4()      # 报错，此时a还未被定义
print(a)     # 报错，此时a还未被定义
func3()      # 10，这里开始定义a是全局变量
```

声明全局变量的情况：

1. **全局变量赋值**：对一个全局变量赋值，就需要声明 `global` 表示在对一个全局变量进行赋值。
2. **积累变化**：当参数在方法中被改变，若需把变化积累下来，而不是每一次重新变化，就需要声明为全局变量。

```python
names = '唱歌'	   # 全局变量names

def func1():
    names += '跳舞'  # 报错，这里对names进行了赋值，但本地没有定义names变量
    print(names)

func1()             # 报错，本地没有定义names变量
print(names)        # '唱歌'

def func2():
    global names    # 声明函数func2内的变量names为全局变量
    names += '跳舞'  # 这里对names进行了字符串拼接的赋值操作
    print(names)    # 上面声明names为全局变量，这里输出全局变量

# 顺序一：
func2()             # '唱歌跳舞'
print(names)		# '唱歌跳舞'

# 顺序二(积累变化)：       
print(names)		# '唱歌'，这里在函数func2里面全局变量names重新赋值之前进行了输出
func2()             # '唱歌跳舞'
func2()             # '唱歌跳舞跳舞'
```

### 关键字 `nonlocal`

`nonlocal` 作用：**在内层函数中声明最外层函数的局部变量**。

```python
def func1():
    a = 10
    print('func1函数', a)      # 2.输出：'func1函数10'
    
    def func2():
        nonlocal a            # 4.因为下面对变量a重新赋值，需要声明a为最外层函数func1的局部变量
        a += 10               # 5.对函数func1局部变量a重新赋值
        print('func2函数', a)  # 6.输出：'func2函数20'

    func2()                   # 3.执行内部函数func2()
    print('func1函数', a)      # 7.输出：'func1函数100'

func1()                       # 1.调用外部函数func1()
print(a)                      # 8.a还是函数func1里面的局部变量，在外部不能输出
```