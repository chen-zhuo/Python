# 数据类型区别

### 八种数据类型

整型（int），浮点型（float），字符型（str），布尔型（bool），列表（list），字典（dict），元祖（tuple），集合（set）

**注意：Python 没有 char 或 byte 类型。**

### 计算机存储

**一个数据有type（类型）、id（数据存储在计算机中的地址）、value（值）三个属性。**

##### id值

**Python会为每个出现的对象分配内存，每个内存都有其对应内存地址，即id值。（因此每个对象都会有一个id值）**

方法：id（数据）

作用：查看数据的内存地址

```
print(id(4))	# 1965911152
print(id(4))	# 1965911152
print(id(5))    # 1965911184
print(id(4.0))  # 725934351056
print(id('4'))  # 725935556288
```

**注意：只有在相同类型，且相同数值的情况下，id值才会一样；其他任何情况，id值都不一样。**

```
a = 2.0
b = 2
print(a is b) 	# False
print(a == b)   # True
```

**注意：is，判断两个对象的id是否相同； == ，判断的两个对象的值是否相同。**

##### 存储方式

**变量是存储数据的容器，在存储不同类型的数据时，存储方式也不一样，这就看数据对象的属性。**

```
a = 1
print(id(1), id(a))    # 1965911056 1965911056

b = [1]
print(id([1]), id(b))  # 39344487560 39344487944
```

### 可变对象

##### 定义

**指内存中对象的值可以被改变，内存地址（id值）不会被改变的对象**。通俗点说就是**原地改变**。

##### 类型

**Python中列表（list）、字典（dict）、集合（set）都是属于可变类型，属于这些类型的数据就是可变对象。**

```
list_1 = [4]
print(list_1, id(list_1))	# [4] 	  927911656968
list_1.append(5)
print(list_1, id(list_1))	# [4, 5]  927911656968

dict_1 = {'name': 'chen'}
print(dict_1, id(dict_1))	# {'name': 'chen'} 927909112784
dict_1['age'] = 18
print(dict_1, id(dict_1))	# {'name': 'chen', 'age': 18} 927909112784
```

##### 特点

**除了切片、copy类操作**，当多个变量操作同一个可变对象时，**可变对象的数量不会改变，所有的操作都是针对这一个可变对象**。

```
list_1 = [4]
print(list_1, id(list_1))	# [4] 	    1095727791624

a = list_1
a.append(5)
print(a, id(a))	                # [4, 5]    1095727791624

b = list_1
b.append(6)
print(b, id(b))	                # [4, 5, 6] 1095727791624
print(a, id(a))	                # [4, 5, 6] 1095727791624

list_2 = list_1[:]	        # 这里出现了切片，产生新对象
print(list_2, id(list_2))	# [4] 	    871593557128
```

**注意：通过一个列表变量给另一个列表变量赋值的时候，赋的是地址。两个列表对元素进行操作的时候会相互影响，想要避免这个问题就是用copy或者切片。**

### 不可变对象

##### 定义

**指内存中对象的值不能被改变的对象。**

##### 类型

**Python中整型（int）、浮点型float）、字符型（str）、元组（tuple）都属于不可变类型，属于这些类型的数据就是不可变对象。**

```
a = 10
print(a, id(a))		# 10 1965911344
a += 1
print(a, id(a))		# 11 1965911376
```

当修改变量时候，由于其所指的值不能被改变，**就把原来的值复制一份后再改变，这会开辟一个新的内存地址，变量再指向这个新的地址**。

##### 特点

**除copy类操作**，多个变量操作同一个不可变对象时，不可变对象的**数量会改变，每个变量操作都是不同的不可变对象**。

```
a = 10
print(a, id(a))  # 10 1965911344

b = a
b += 1
print(b, id(b))  # 11 1965911376

c = a
c += 2
print(c, id(c))  # 12 1965911408

d = a
print(d, id(d))  # 10 1965911344
```

### 对象拷贝

##### 赋值

= 赋值，**就是拷贝对象的地址，增加指向同一地址的对象**。**地址对应的值改变时，对象的的值都改变**。（**多层嵌套列表都只拷贝地址**）

```
alist=[1,2,3,["a","b"]]
b=alist
print(b)		# [1, 2, 3, ['a', 'b']]

alist.append(5)
print(alist)	        # [1, 2, 3, ['a', 'b'], 5]
print(b)		# [1, 2, 3, ['a', 'b'], 5]
```

![img](https://img2018.cnblogs.com/blog/546188/201810/546188-20181031094701785-1018065288.png)

##### 浅拷贝

copy浅拷贝，就是拷贝一个**单层数据**相同的值放到一个新的内存地址中。（**浅拷贝只拷贝多层嵌套列表最外层的值，内层的列表就只拷贝地址**）

```
import copy

alist=[1,2,3,["a","b"]]
c=copy.copy(alist)
print(alist)		# [1, 2, 3, ['a', 'b']]
print(c)	        # [1, 2, 3, ['a', 'b']]

alist.append(5)
print(alist)		# [1, 2, 3, ['a', 'b'], 5]
print(c)		# [1, 2, 3, ['a', 'b']]

alist[3].append('cccc')
print(alist)		# [1, 2, 3, ['a', 'b', 'cccc'], 5]
print(c)		# [1, 2, 3, ['a', 'b', 'cccc']]
```

![img](https://img2018.cnblogs.com/blog/546188/201810/546188-20181031095328930-1590606034.png)

##### 深拷贝

deepcopy深拷贝，就是**完全拷贝所有的值**放到一个新的内存地址中，**形成一个新的对象，两个对象修改任何的值都不会影响对方。**（**deepcopy深拷贝，只拷贝值，不拷贝地址**）

```
import copy

alist=[1,2,3,["a","b"]]
d=copy.deepcopy(alist)
print(alist)		# [1, 2, 3, ['a', 'b']]
print(d)		# [1, 2, 3, ['a', 'b']]

alist.append(5)
print(alist)		# [1, 2, 3, ['a', 'b'], 5]
print(d)		# [1, 2, 3, ['a', 'b']]

alist[3].append("ccccc")
print(alist)		# [1, 2, 3, ['a', 'b', 'ccccc'], 5]
print(d)		# [1, 2, 3, ['a', 'b']]
```

![img](https://img2018.cnblogs.com/blog/546188/201810/546188-20181031095505004-75839266.png)

**注意：以上方法是对于可变对象来试验的，对于不可变对象来说赋值、浅拷贝、深拷贝所产生的新的变量都是指向原值的地址，没有新的值产生。**

```
from copy import copy, deepcopy
a = 1
b = a
c = copy(a)
d = deepcopy(a)
print(id(a))	# 1978231824
print(id(b))	# 1978231824
print(id(c))	# 1978231824
print(id(d))	# 1978231824
```

### 类型选择思路

1. 同时存储多个信息 -->考虑使用容器类型（列表、字典、集合、元祖）
2. 是否可以对数据进行增删改查 -->是：列表、字典  否：元祖、集合
3. 看存储的数据是否是同一类数据  -->是：列表  否：字典

