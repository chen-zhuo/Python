# 生成器

##### 说明

将列表[0，1，2，3，4，5，6，7，8，9]中的每个值加1，实现方法

新列表+遍历：

```
info = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
b = []
for i in info:
    b.append(i+1)
print(b)
```

列表生成式：

```
a = [i+1 for i in range(10)]
print(a)
```

假如列表里面包含1亿个元素，仅需要访问前10个元素，通过上面的方法，不仅会浪费时间，而且不必要元素还会占用很大的存储空间。

因此我们需要**一种不必创建完整的列表，而列表元素可以按照某种算法推算出来的机制**。

### 生成器

**Python中一边循环一边计算的机制，称为生成器：generator**

##### 创建生成器

第一种：

**将列表生成式中的 [  ] 改为 (  )，就创建一个生成器**

```
#列表生成式
lis = [x*x for x in range(5)]
print(lis)				# [0, 1, 4, 9, 16]

#生成器
generator_ex = (x*x for x in range(5))
print(generator_ex)		# <generator object <genexpr> at 0x000002A4CBF9EBA0>
```

**使用xrange函数来生成生成器。**

**注意：在生成很长的数字序列的时候，xrange比range性能优很多，因为不用一上来就开辟很大的内存空间。**

```
range 函数说明：range([start,] stop[, step])，根据start与stop指定的范围以及step设定的步长，生成一个序列。
>>> range(5)
[0, 1, 2, 3, 4]
>>> range(1,5)
[1, 2, 3, 4]
>>> range(0,6,2)
[0, 2, 4]

xrange 函数说明：用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。
>>> xrange(5)
xrange(5)
>>> list(xrange(5))
[0, 1, 2, 3, 4]

>>> xrange(1,5) 
xrange(1, 5)
>>> list(xrange(1,5))
[1, 2, 3, 4]

>>> xrange(0,6,2)
xrange(0, 6, 2)
>>> list(xrange(0,6,2))
[0, 2, 4]
```

##### 生成数据

生成器可以看成一个存储数据的容器，需要数据的时候就用next()方法取一个。

```
generator_ex = (x*x for x in range(3))
print(next(generator_ex))
print(next(generator_ex))
print(next(generator_ex))
print(next(generator_ex))

结果：
0
1
4
报错，没有数据能生成
```

**注意：里面的数据只能从前往后一个一个生产，不能跳跃，也不能从后往前。**

**注意：没有数据能生成时，使用next()方法会报错。生成后的数据，不能再生成。**

上面生成多个数据需要多个next()，而且超出还会报错。**正确的方法是使用for循环来取数据**。

```
generator_ex = (x*x for x in range(3))
for i in generator_ex:
    print(i)
     
结果：
0
1
4
```

##### 关键字yield

作用：**返回后面的值，并暂停循环，当外部使用next()取数据时，继续循环。**

**注意：只要函数声明中有yield关键字就是一个生成器，不管yield在哪个位置**

普通函数

```
def fun():
    print(1)

fun()
print(fun())

输出：
# 下面由fun()输出
1
# 下面有print(fun())输出
1
None
```

生成器

```
def fun():
    print(1)
    yield 2
    print(3)
    yield 4

fun()               # 这里fun()不会有任何输出，因为有yield存在，fun()变成了一个生成器
print(fun())
print(next(fun()))  # 生成器，需要配合next()方法来使用
print(next(fun()))
c = fun()           # 同样这里也不会有任何输出
print(c)
print(next(c))
print(next(c))

输出：
# 下面由print(fun())输出
<generator object fun at 0x00000077C755CF10>
# 下面由第一个print(next(fun()))输出
1
2
# 下面由第二个print(next(fun()))输出，因为是重新调用了生成器，所以输出了与上面相同的值
1
2
# 下面由print(c)输出
<generator object fun at 0x00000077C755CF10>
# 下面由第一个print(next(c))输出
1
2
# 下面由第二个print(next(c))输出，因为是第二次调用同一生成器，所以输出的值与上面不同
3
4
```

**\_\_next\_\_方法**

生成器.\_\_next\_\_() 和 next(生成器)效果一样。

```
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
 
a = fib(5)
print(fib(5))
print(a.__next__())
print(a.__next__())
print(a.__next__())
print("可以顺便干其他事情")
print(a.__next__())
print(a.__next__())
print(a.__next__())
 
结果：
<generator object fib at 0x0000023A21A34FC0>
1
1
2
可以顺便干其他事情
3
5
报错，元素生成不了

# 注释：执行程序时，遇到yield语句返回并暂停，调用next()时候，从上次的返回yield语句处继续执行，也就是用多少，取多少，不占内存。
```

**注意：调用next()和\_\_next\_\_方法时，会继续执行，直到找到下一个yield，如果后面没有yield了，会拋出异常。**

**send(msg)方法**

next()只能传递None，而send(msg)可以传递 yield msg 的值，所以next() 和 send(None)作用是一样的。

```
def s():
    print('study yield')
    m = yield 1
    print(m)
    yield 2

c = s()
print(next(c)) # 相当于send(None)
print(next(c)) 
d = s()
print(next(d))
print(d.send('new'))

输出：
# 下面由第一个print(next(c))输出
study yield
1
# 下面由第二个print(next(c))输出，并将yield 1变成了None并赋值给了m
None
2
# 下面由print(next(d))输出
study yield
1
# 下面由print(d.send('new'))输出，并将yield 1变成了new并赋值给了m
new
2
```

**for循环**

**需要不断调用yield代码，程序才不会暂停中断**。正确方法使用for循环。

```
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'
for i in fib(5):
    print(i)
     
结果：
1
1
2
3
5
```

但是用for循环拿不到return语句的返回值，如果想要拿到返回值，必须捕获StopIteration错误。

```
def fib(max):
    n,a,b =0,0,1
    while n < max:
        yield b
        a,b =b,a+b
        n = n+1
    return 'done'

g = fib(5)
while True:
    try:
        x = next(g)
        print('generator: ',x)
    except StopIteration as e:
        print("生成器返回值：",e.value)
        break

结果：
generator:  1
generator:  1
generator:  2
generator:  3
generator:  5
生成器返回值： done
```

**中断generator**

上面的例子中，当没有可执行程序的时候，会抛出一个StopIteration, 开发过程中，中断Generator是一个非常灵活的技巧

```
def g4():
    yield 1
    yield 2
    yield 3

g = g4()
print(next(g))      # 1
print(next(g))      # 2
g.close()           # 中断generator
print(next(g))      # StopIteration，因为上面中断生成器，所以yield 3并不会输出。
```

##### yield和return区别

yield：返回后面的值，暂停函数，生成器。

return：返回后面的值，结束函数，函数。
