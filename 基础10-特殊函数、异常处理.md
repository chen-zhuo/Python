# 特殊函数、异常处理、概念

### 特殊函数

特殊函数：带有特殊功能性的函数。

##### 匿名函数 `lambda`

**匿名函数**：本质还是函数，以另外一种简单的方式来声明的

匿名函数格式：`函数名 = lambda 参数列表：返回值表达式`

`lambda`：声明匿名函数

```python
# 普通函数
def my_sum1(x, y):
    return x + y
print(my_sum1(10, 20))			# 30

# 匿名函数
my_sum2 = lambda x, y: x+y
print(my_sum2(10, 20))			# 30
```

##### 过滤函数 `filter`

 `filter()`：用于**过滤可迭代对象**，将对象的每个元素传递给函数判断，返回符合条件元素组成的**迭代器**。

过滤函数格式：`filter(function, iterable)`

`function`：函数

`iterable`：可迭代对象

```python
# 基本的过滤函数
# 函数
def is_odd(n):
    return n % 2 == 1

# 可迭代对象
iter = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

newlist = filter(is_odd, iter)
print(next(newlist))  # 1，因为返回的newlist是迭代器，因此用next()方法取值
print(next(newlist))  # 3
print(next(newlist))  # 5
print(next(newlist))  # 7
print(next(newlist))  # 9

#过滤函数结合匿名函数
# 函数
def delete_list(lt):
    a = filter(lambda x: x != "", lt)  # 过滤掉空字符 
    lt = list(a)                       # 将迭代器a给列表化
    return lt                          # 返回lt

# 可迭代对象
lt = ["", 1, 2, 3, ""]
print(delete_list(lt))                 # [1, 2, 3]
```

##### 计数函数 `counter`

`counter`：属于 `collections` 模块中的一个子类，**用于统计对象中元素出现的次数**。

```python
from collections import Counter

def list_():
    list1 = [1, 1, 1, 7, 8, 4, 4, 7, 7, 7]
    list_count = Counter(list1)
    print(list_count)

def tuple_():
    tuple1 = (1, 1, 1, 7, 8, 4, 4, 7, 7, 7)
    tuple_count = Counter(tuple1)
    print(tuple_count)

if __name__ == '__main__':
    list_()
    tuple_()
'''
输出：
Counter({7: 4, 1: 3, 4: 2, 8: 1})
Counter({7: 4, 1: 3, 4: 2, 8: 1})
# 注释：这里输出了列表和数组中某个数字出现的次数，并从多到少进行了排序
'''

# 拓展
a = ['apple', 'banana', 'apple', 'tomato', 'apple', 'banana']
b = {}
for i in a:
    b[i] = b.get(i, 0) + 1

print(b)    # {'apple': 3, 'banana': 2, 'tomato': 1}
```

##### 递归函数

**递归函数**：在**函数中调用函数本身**的函数称为**递归函数**。

1. 递归效率低下，每调用一次函数，系统都要为其分配内存空间。
2. 循环能做的事情，虽然递归函数也可以做，但**尽量不使用递归**。

```python
def fun1():
    print('===')
    fun1()

fun1()	# 输出多个===后，出现递归错误：调用python对象超过了最大递归深度
```

### 异常处理

举例：使用代码打开一个文件，假如文件不存在，代码就会报错，但为了能让程序继续执行下去，就需要对文件不存在的情况进行异常处理。

**异常处理**：简单说，**让代码不崩溃变得更加健壮，就需要在代码可能会报错的地方进行特殊的处理**。

##### 异常处理关键字

关键字 `pass`：空语句，**不做任何事情**，一般用做占位语句，目的为了保持程序结构的完整性。

```python
if 2 > 1:
    pass			# 空
else:
    print('2小于1')
```

关键字 `try`：尝试执行下面一个缩进的代码块，无论是否报错。

关键字 `except`：当 `try` 下面的代码块**报错时**，**根据报错类型**，执行 `except` 下面的代码块。

关键字 `else`：当 `try` 下面的代码块**不报错时**，执行 `else` 下面的代码块。

关键字 `finally`：不管 `try` 下面的代码块是否报错，**都要执行 `finally` 下面的代码块**。

```python
# 不指定错误类型异常处理
try:
    代码1
except:		# 这里只要代码1出现错误，不管是什么类型的错误，都会执行代码2
    代码2
'''
流程1：执行代码1——>没有错误——>程序结束
流程2：执行代码1——>出现错误——>执行代码2——>程序结束
'''    

# 指定错误类型异常处理
try:
    代码1
except 错误类型:  # 指定错误的类型，若要同时捕获多个类型的异常：except（错误类型1，错误类型2...）
    代码2
'''
流程1：执行代码1——>没有错误——>程序结束
流程2：执行代码1——>出现错误——>错误类型不一样——>程序结束
流程3：执行代码1——>出现错误——>错误类型一样——>执行代码2——>程序结束
'''

# else异常处理
try:
    代码1
except:
    代码2
else:
    代码块3
'''
流程1：执行代码1——>没有错误——>执行代码3——>程序结束
流程2：执行代码1——>出现错误——>执行代码2———>程序结束
'''

# finally异常处理
try:
    代码1
except:
    代码2
finally:
    代码块3
'''
流程1：执行代码1——>没有错误——>执行代码3——>程序结束
流程2：执行代码1——>出现错误——>执行代码2———>执行代码3———>程序结束
'''
```

**若代码块1中的输出语句报错，是不会输出的内容的。**

```python
try:
    print({'a': 'b', 'b': 1}['c'])		# 前面字典中没有c键，因此键错误。
except KeyError:						# 指定错误类型为键错误
    print('键错误')					  # '键错误'，报错和指定错误类型相同因此会输出
finally:
    print('异常捕获结束')			        # '异常捕获结束'，无论上面代码是否报错都会输出

'''
输出：
键错误
异常捕获结束
'''
```

关键字 `raise`：抛出一个指定的异常。

关键字 `Exception`：抛出异常的内容。

```python
def ThorwErr():
    raise Exception("抛出一个异常")  
ThorwErr()

'''
报错：
Exception: 抛出一个异常
'''
```

##### 超时跳出

关于函数执行超时的问题，就是某一步执行时间过长，或者程序直接卡死了，可以使用 `Eventlet` 库来解决。

**`Eventlet` 主要是用于网络并发的库**，专注于代码运行逻辑。

**注意：`Eventlet`也存在一定的问题，就是针对子进程无法跳出。**

首先安装 `Eventlet` 库：

```
pip install eventlet -i https://pypi.org/simple/
```

设置函数超时时间：

```python
import time
#导入eventlet这个模块
import eventlet  

# 猴子补丁，必须加这条代码
eventlet.monkey_patch()
# 设置事件的超时时间为2秒
with eventlet.Timeout(2,False):  
   print('第一条语句')
   time.sleep(5)
   print('第二条语句')
print('结束')

'''
输出：
    第一条语句
    (暂停2秒后)
    结束
'''
```