# 消息队列

##### 简介

消息队列（Message Queue，简称MQ）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。

##### 过程

发布者只管把消息发布到 MQ 中而不用管谁来取，使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。

**消息模型**

所有 MQ 产品从模型抽象上来说都是一样的过程：

一个发送消息的程序就是生产者（ producer） : 

![producer](https://img-blog.csdn.net/20170524102259570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdmaDE5OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

队列（queue） 就是存储消息的队列， 一个队列只受到主机的内存和磁盘的限制, 它实际上是个大的消息缓冲区. **许多生产者可以发送消息到一个队列, 许多消费者可以从队列中接收数据**. 下面是队列的示意图: 

![这里写图片描述](https://img-blog.csdn.net/20170524104231217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdmaDE5OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

消费者（consumer）就是等待接收消息的程序 : 

![这里写图片描述](https://img-blog.csdn.net/20170524104158185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdmaDE5OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。

![img](https://img2018.cnblogs.com/blog/1436447/201811/1436447-20181121135142706-7726795.png)

**注意：生产者、消费者、中间人不必在同一主机上，实际上大多数情况下它们都不在同一台主机上。**

##### 作用

在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。

##### 阅后即焚

消息队列的特点：阅后即焚。

当使用者使用了消息队列里面的消息后，消息队列里面的消息就被销毁了。

### 队列

##### 队列模块

协调多个线程和多个进程都可以使用 Queue 队列。

**queue 模块的 Queue ，用于多线程，它可以指定缓冲区大小的阻塞队列。**

**multiprocessing 模块的 Queue ，用于多进程，它通过管道以及锁和信号量机制来协调多个进程。**

**坑：在queue模块生成的队列能正常使用，但是加入多进程multiprocessing后，报错 TypeError: can't pickle _thread.lock objects。因为在多进程模式下，queue模块的队列，数据无法在多个进程之间共享。multiprocessing模块的队列，可以在多进程之间共享同一个变量的数据。将 from queue import Queue 修改为 from multiprocessing import Queue 即可。**

**注意：queue 模块和multiprocessing 模块中Queue，使用get、put、empty、qsize等方法是相同的。**

##### 创建队列

```
import queue

# 创建一个队列
q = queue.Queue()
```

##### 插入获取判断

```
import queue

q = queue.Queue()

for i in range(3):
	# put(i)插入数据i
    q.put(i)

# empty()判断队列是否为空
print(q.empty())	# False

# get()获取数据，每次get只能取一个数据
print(q.get())		# 0
print(q.get())		# 1
print(q.get())		# 2

# 每取一个数据，队列就少一个数据，直到为空
print(q.empty())	# True
```

##### 队列长度

```
import queue

q = queue.Queue()

for i in range(5):
    q.put(i)

# qsize()获取队列长度
print(q.qsize())	# 5
```

maxsize参数表示队列中能存放的数据个数的上限；不写该参数或maxsize等于0，表示队列大小没有限制。

**注意：数据量一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。**

```
import queue

# 创建一个长度为4的队列
q = queue.Queue(maxsize=4)

# 插入数据0，1，2，3后，消息队列数据达到上限，发生阻塞，不会执行下面的print语句。
for i in range(5):
    q.put(i)	

print('程序结束')
```

消除阻塞

```
import queue

q = queue.Queue(maxsize=4)

# 每插入一次数据，就会获取一次数据，因此数据量不会达到队列上限4
for i in range(5):
    q.put(i)
    print(q.get())	# 0，1，2，3，4

print('程序结束')	 # 程序结束
```

##### 队列顺序

Queue先进先出模式

```
import queue

q = queue.Queue()

for i in range(3):
    q.put(i)
print(q.get())		# 0
print(q.get())		# 1
print(q.get())		# 2
```

LifoQueue先进后出模式

```
import queue

q = queue.LifoQueue()

for i in range(3):
    q.put(i)
print(q.get())		# 2
print(q.get())		# 1
print(q.get())		# 0
```

### Redis消息队列

##### 简介

Redis是时下比较火的**内存数据库**，以简单高效著称，具有丰富的数据类型，常用于缓存数据。

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- Redis支持数据的备份，即master-slave模式的数据备份。
- Redis供提了丰富的API以操作这些数据结构。

Redis不仅仅支持简单的key-value类型的数据，同时还提供string，list，set，zset，hash等数据结构的存储，当然也支持队列queue，利用这些数据结构，我们可以将Redis作为message broker（消息中间人）。

说起message broker，大家可能更容易想到Kafka、ActiveMQ或RabbitMQ等功能全面的应用。相比于它们，Redis目前只能实现简单的消息队列功能。那为什么我们还会想用Redis呢？在我看来，它有如下几个优点：

- 极低延迟：得益于Redis本身的高效，消息可以极低延迟传递
- 上手容易：只需组合使用两三个命令，即可完成消息传递
- 查看便利：可以便利地查看队列内容；利用`MONITOR`命令甚至可以实时监控消息入队和出队

如果应用场景只需要简单的消息传递，不妨尝试使用Redis。

##### 模式

Redis提供了两种方式来作消息队列。一个是使用生产者消费模式模式，另外一个是发布订阅者模式。

生产者消费模式模式会让一个或者多个客户端监听消息队列，一旦消息到达，消费者马上消费，谁先抢到算谁的，如果队列里没有消息，则消费者继续监听。

发布订阅者模式也是一个或多个客户端订阅消息频道，只要发布者发布消息，所有订阅者都能收到消息，订阅者都是ping的。

##### FIFO队列

FIFO（先进先出）队列是队列的基本形式，也是最简单的消息队列。使用一个列表和`LPUSH`、`RPOP`两个命令即可实现一条FIFO队列。

![img](https://upload-images.jianshu.io/upload_images/13773631-455b7c7bbe9b02ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

生产者通过`LPUSH`将消息发送到Redis：

```
127.0.0.1:6379> LPUSH queue "message-1"
127.0.0.1:6379> LPUSH queue "message-2"
```

消费者使用`RPOP`从队列中依次获取消息：

```
127.0.0.1:6379> RPOP queue
"message-1"
127.0.0.1:6379> RPOP queue
"message-2"

# 当队列为空时，RPOP会直接返回空
127.0.0.1:6379> RPOP queue
(nil)
```

**注意：如果希望在队列为空时能够阻塞连接等待消息，直到队列接收到新的消息或超时，可以使用`BRPOP`。**

`RPOP`或`BRPOP`之后，消息就会从队列中删除。因此，当有多个消费者时，一条消息只能传递给其中一个消费者。我们不用担心在并发下同一条消息会传递给多个消费者，因为**Redis本身是一个单线程的程序，相当于所有操作都有一把天然的排他锁**。

##### 可靠队列

FIFO队列中的消息一经发送出去，便从队列里删除。如果由于网络原因消费者没有收到消息，或者消费者在处理这条消息的过程中崩溃了，就再也无法还原出这条消息。也就是说，**FIFO队列不能保证消息会传递成功**。

究其原因，在于FIFO队列缺乏**消息确认机制**，即消费者向队列报告消息已收到或已处理的机制。可靠队列便是加入了这一机制的消息队列。

Redis在`RPOPLPUSH`命令的[文档](https://redis.io/commands/rpoplpush#pattern-reliable-queue)中提供了一种利用这一命令实现可靠队列的方式。这个命令可以在从一个list中获取消息的同时把这条消息复制到另一个list里，并且这个过程是**原子的**。

![img](https://upload-images.jianshu.io/upload_images/13773631-9cea6b22be07afec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

利用`RPOPLPUSH`实现的可靠队列由两个列表组成，一个存储**待处理**（pending）的消息，另一个存储**处理中**（processing）的消息。

生产者通过`LPUSH`将消息发送到待处理列表：

```
127.0.0.1:6379> LPUSH queue:pending "message"
```

消费者使用`RPOPLPUSH`从待处理列表获取消息，同时将它加入处理中列表：

```
127.0.0.1:6379> RPOPLPUSH queue:pending queue:processing
"message"
```

此时这条消息已经从待处理列表中删除，并且复制到了处理中列表：

```
127.0.0.1:6379> LRANGE queue:pending 0 -1
(empty list or set)
127.0.0.1:6379> LRANGE queue:processing 0 -1
1) "message"
```

消费者在收到消息或者处理完消息后，使用`LREM`命令从处理中列表删除这条消息，即完成了**消息确认**：

```
127.0.0.1:6379> LREM queue:processing 1 "message"
```

使用`LREM`而不是`RPOP`的原因在于，在并发时，不能保证处理中的消息能按加入列表的先后顺序被确认；而`RPOP`会按顺序删除消息。

##### 延迟队列

延迟队列非常适用于对消费次序或时间没有强一致性需要的场景，主要特性是**进入队列的消息会被推迟到指定的时间才出队被消费**。因此，**延迟队列中的一条消息，除了消息本身外，还需要附加一个“何时出队”的信息**。

![img](https://upload-images.jianshu.io/upload_images/13773631-c490541562d418c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620/format/webp)



**Sorted Set是一个有序的集合，集合内元素的排序基于其加入集合时指定的score**。通过`ZRANGEBYSCORE`命令，我们可以取得score在指定区间内的元素。**将集合中的元素做为消息，score视为延迟的时间，这便是一个延迟队列的模型**。

生产者通过`ZADD`将消息发送到队列中：

```
127.0.0.1:6379> ZADD delay-queue 1520985600 "publish article"
```

消费者通过`ZRANGEBYSCORE`获取消息。如果时间未到，将得不到消息；当时间已到或已超时，都可以得到消息：

```
127.0.0.1:6379> ZRANGEBYSCORE delay-queue -inf 1520985599
(empty list or set)
127.0.0.1:6379> ZRANGEBYSCORE delay-queue -inf 1520985600 WITHSCORES
1) "publish article"
2) "1520985600"
127.0.0.1:6379> ZRANGEBYSCORE delay-queue -inf 1520985601 WITHSCORES
1) "publish article"
2) "1520985600"
```

使用`ZRANGEBYSCORE`取得消息后，消息并没有从集合中删出。需要调用`ZREM`删除消息：

```
127.0.0.1:6379> ZREM delay-queue "publish article"
```

美中不足的是，消费者组合使用`ZRANGEBYSCORE`和`ZREM`的过程不是原子的，当有多个消费者时会存在竞争，可能使得一条消息被消费多次。此时需要使用Lua脚本保证消费操作的原子性：

```
local message = redis.call('ZRANGEBYSCORE', KEYS[1], '-inf', ARGV[1], 'WITHSCORES', 'LIMIT', 0, 1);
if #message > 0 then
  redis.call('ZREM', KEYS[1], message[1]);
  return message;
else
  return {};
end
```

**注意：原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。**

### RabbitMQ框架

##### 简介

RabbitMQ是一个专门做队列的框架，在队列方面要比redies队列性能要好，支持的功能会更多，消息的可靠性更强。

##### 模型

RabbitMQ 是一个消息中间人（broker）: 它接收并且发送消息. 

可以想象一个邮局：当你把想要寄出的信放到邮筒里时，邮递员会把信件送到收信人那里。 

在这个比喻中, RabbitMQ 就是一个邮筒（接收）, 同时也是邮局（存储）和邮递员（转发） 。和邮局的主要不同点在于RabbitMQ不处理纸质信件, 而是 接收（accepts）, 存储（stores） 和转发（forwards）二进制数据块 —— 消息（messages）. 
